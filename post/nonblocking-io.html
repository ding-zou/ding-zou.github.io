<!DOCTYPE html>




<html class="theme-next mist" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">


















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/2.JPG?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/2.JPG?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Java基础,Java,NIO,异步,NonBlockingIO,socket,网络通信">





  <link rel="alternate" href="/atom.xml" title="Dzou's Blog" type="application/atom+xml">






<meta name="description" content="io面向流编程，只能作为输入或者输出流的一种，是同步阻塞的，每一个连接过来都要创建一个线程去处理，线程上下文切换开销很大，造成了很大的瓶颈；于是有了线程池实现的伪阻塞IO，一定程度解决了线程创建过多的问题，但是没有从根本上解决阻塞的问题，并且线程过多而线程池过小时也会造成很大的瓶颈；NIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的">
<meta name="keywords" content="Java基础,Java,NIO,异步,NonBlockingIO,socket,网络通信">
<meta property="og:type" content="article">
<meta property="og:title" content="多次尝试的学习—搞懂NIO">
<meta property="og:url" content="https://www.dzou.top/post/nonblocking-io.html">
<meta property="og:site_name" content="Dzou&#39;s Blog">
<meta property="og:description" content="io面向流编程，只能作为输入或者输出流的一种，是同步阻塞的，每一个连接过来都要创建一个线程去处理，线程上下文切换开销很大，造成了很大的瓶颈；于是有了线程池实现的伪阻塞IO，一定程度解决了线程创建过多的问题，但是没有从根本上解决阻塞的问题，并且线程过多而线程池过小时也会造成很大的瓶颈；NIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://dzou.wangminwei.top/static/images/nio/1.png">
<meta property="og:image" content="http://dzou.wangminwei.top/static/images/nio/2.png">
<meta property="og:image" content="http://dzou.wangminwei.top/static/images/nio/6.png">
<meta property="og:image" content="http://dzou.wangminwei.top/static/images/nio/3.png">
<meta property="og:image" content="http://dzou.wangminwei.top/static/images/nio/4.png">
<meta property="og:image" content="http://dzou.wangminwei.top/static/images/nio/5.png">
<meta property="og:image" content="http://dzou.wangminwei.top/static/images/nio/8.png">
<meta property="og:image" content="http://dzou.wangminwei.top/static/images/nio/7.png">
<meta property="og:image" content="http://dzou.wangminwei.top/static/images/nio/9.png">
<meta property="og:image" content="http://dzou.wangminwei.top/static/images/nio/10.png">
<meta property="og:image" content="http://dzou.wangminwei.top/static/images/nio/11.png">
<meta property="og:image" content="http://dzou.wangminwei.top/static/images/nio/12.png">
<meta property="og:image" content="http://dzou.wangminwei.top/static/images/nio/13.png">
<meta property="og:image" content="http://dzou.wangminwei.top/static/images/nio/14.png">
<meta property="og:updated_time" content="2019-10-27T09:18:03.232Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="多次尝试的学习—搞懂NIO">
<meta name="twitter:description" content="io面向流编程，只能作为输入或者输出流的一种，是同步阻塞的，每一个连接过来都要创建一个线程去处理，线程上下文切换开销很大，造成了很大的瓶颈；于是有了线程池实现的伪阻塞IO，一定程度解决了线程创建过多的问题，但是没有从根本上解决阻塞的问题，并且线程过多而线程池过小时也会造成很大的瓶颈；NIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的">
<meta name="twitter:image" content="http://dzou.wangminwei.top/static/images/nio/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'Q66404JRFM',
      apiKey: '27dd0e53d330bf96c9826662fc30055a',
      indexName: 'dzou',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://www.dzou.top/post/nonblocking-io.html">





<link href="/js/google-code-prettify/tomorrow-night-eighties.min.css" type="text/css" rel="stylesheet">



  <title>多次尝试的学习—搞懂NIO | Dzou's Blog</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  
  
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="bg_content">
    <canvas id="canvas"></canvas>
  </div>

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Dzou's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">No pains,no gains.</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.dzou.top/post/nonblocking-io.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/2.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dzou's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">多次尝试的学习—搞懂NIO</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-26T19:32:01+08:00">
                2019-10-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java基础/" itemprop="url" rel="index">
                    <span itemprop="name">Java基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/post/nonblocking-io.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="post/nonblocking-io.html" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>&nbsp浏览次数：
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6.1k字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  26分
                </span>
              
            </div>
          

          
              <div class="post-description">
                  io面向流编程，只能作为输入或者输出流的一种，是同步阻塞的，每一个连接过来都要创建一个线程去处理，线程上下文切换开销很大，造成了很大的瓶颈；于是有了线程池实现的伪阻塞IO，一定程度解决了线程创建过多的问题，但是没有从根本上解决阻塞的问题，并且线程过多而线程池过小时也会造成很大的瓶颈；NIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的（没有可干的事情必须要阻塞），剩余的I/O操作都是纯CPU操作，没有必要开启多线程
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="NIO—NonBlocking-IO-new-IO"><a href="#NIO—NonBlocking-IO-new-IO" class="headerlink" title="NIO—NonBlocking IO(new IO)"></a>NIO—NonBlocking IO(new IO)</h2><ol>
<li>io面向流编程，只能作为输入或者输出流的一种，是同步阻塞的，每一个连接过来都要创建一个线程去处理，线程上下文切换开销很大，造成了很大的瓶颈</li>
<li>于是有了线程池实现的伪阻塞IO，一定程度解决了线程创建过多的问题，但是没有从根本上解决阻塞的问题，并且线程过多而线程池过小时也会造成很大的瓶颈</li>
<li>既然根本瓶颈原因是线程数和阻塞IO，那么我们有没有办法只用1个线程去处理多个客户端连接呢？这就是NIO出现的原因</li>
</ol>
<p>NIO主要有<strong>三个核心部分组成</strong>：</p>
<ul>
<li><strong>buffer缓冲区</strong></li>
<li><strong>Channel管道</strong></li>
<li><strong>Selector选择器</strong></li>
</ul>
<blockquote>
<p>nio面向block块，buffer缓冲区编程，底层是数组，buffer提供数据访问，channel读写到buffer，buffer读写到channel，从buffer读取到程序channel是双向的</p>
<p>理解NIO需要理解事件编程模型</p>
</blockquote>
<p>NIO核心：</p>
<p>NIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的（没有可干的事情必须要阻塞），剩余的I/O操作都是纯CPU操作，没有必要开启多线程。</p>
<blockquote>
<p>单线程处理I/O的效率确实非常高，没有线程切换，只是拼命的读、写、选择事件。</p>
</blockquote>
<p>NIO带个我们：</p>
<ol>
<li>事件驱动模型—异步编程都离不开事件</li>
<li>单线程处理多连接—多路复用使得处理更加高效</li>
<li>非阻塞IO，只阻塞获取可操作事件</li>
<li>基于block传输比基于流传输更加高效</li>
<li>零拷贝—DirectBuffer</li>
</ol>
<p>缺点：</p>
<p>NIO并没有完全屏蔽平台差异，它仍然是基于各个操作系统的I/O系统实现的，差异仍然存在。使用NIO做网络编程构建事件驱动模型并不容易，陷阱重重。</p>
<blockquote>
<p>推荐使用NIO成熟框架Netty</p>
</blockquote>
<h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p><strong>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。</strong></p>
<h4 id="Capacity、Position、Limit"><a href="#Capacity、Position、Limit" class="headerlink" title="Capacity、Position、Limit"></a>Capacity、Position、Limit</h4><img src="http://dzou.wangminwei.top/static/images/nio/1.png">

<p>0 <code>&lt;=</code> <em>mark</em> <code>&lt;=</code> <em>position</em> <code>&lt;=</code> <em>limit</em> <code>&lt;=</code> <em>capacity</em></p>
<ul>
<li>capacity</li>
</ul>
<blockquote>
<p>作为一个内存块，Buffer有一个固定的大小值，也叫“capacity”.你只能往里写capacity个byte、long，char等类型。一旦Buffer满了，需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据。</p>
</blockquote>
<ul>
<li>position</li>
</ul>
<blockquote>
<p>当你写数据到Buffer中时，position表示当前的位置。初始的position值为0.当一个byte、long等数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity – 1.</p>
</blockquote>
<p>当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式，position会被重置为0. 当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。</p>
<ul>
<li>limit</li>
</ul>
<blockquote>
<p>在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。 写模式下，limit等于Buffer的capacity。</p>
</blockquote>
<p>当切换Buffer到读模式时， limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。换句话说，你能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是position）</p>
<p><strong>同一个buffer可以存储不同数据类型的数据，但是获取的时候要指定类型获取</strong></p>
<pre><code class="java">ByteBuffer buffer = ByteBuffer.allocate(1024);
buffer.putInt(1);
buffer.putLong(387524875628742L);
buffer.putChar(&#39;s&#39;);
buffer.flip();
System.out.println(buffer.getInt());
System.out.println(buffer.getLong());
System.out.println(buffer.getChar());</code></pre>
<blockquote>
<p>put方法只能放入byte型，不能放入int</p>
</blockquote>
<h4 id="flip、clear、rewind、mark"><a href="#flip、clear、rewind、mark" class="headerlink" title="flip、clear、rewind、mark"></a>flip、clear、rewind、mark</h4><ul>
<li>flip</li>
</ul>
<p><strong>flip方法将Buffer从写模式切换到读模式。调用flip()方法会将position设回0，并将limit设置成之前position的值。</strong></p>
<pre><code class="java">    public final Buffer flip() {
        this.limit = this.position;
        this.position = 0;
        this.mark = -1;
        return this;
    }</code></pre>
<ul>
<li>clear</li>
</ul>
<p><strong>position将被设回0，limit被设置成 capacity的值。换句话说，Buffer 被清空了。Buffer中的数据并未清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据。</strong></p>
<pre><code class="java">    public final Buffer clear() {
        this.position = 0;
        this.limit = this.capacity;
        this.mark = -1;
        return this;
    }</code></pre>
<ul>
<li>rewind</li>
</ul>
<p><strong>Buffer.rewind()将position设回0，所以你可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素</strong></p>
<pre><code class="java">    public final Buffer rewind() {
        this.position = 0;
        this.mark = -1;
        return this;
    }</code></pre>
<ul>
<li>mark</li>
</ul>
<p><strong>可以标记Buffer中的一个特定position。之后可以通过调用Buffer.reset()方法恢复到这个position。</strong></p>
<pre><code class="java">    public final Buffer mark() {
        this.mark = this.position;
        return this;
    }</code></pre>
<ul>
<li>slice分片</li>
</ul>
<p>将buffer根据设置的position和limit分片一个buffer，有自己的position、limit和capacity，数据共用一个内存地址的buffer数据</p>
<pre><code class="java">public static void test2(){
        ByteBuffer buffer = ByteBuffer.allocate(1024);
        for(int i=0;i&lt;buffer.capacity();i++){
            buffer.put((byte)i);
        }
        buffer.position(10);
        buffer.limit(20);
        ByteBuffer buffer1 = buffer.slice();//buffer分片
        for(int m=0;m&lt;buffer1.capacity();m++){
            byte b = buffer1.get();
            System.out.print(b+&quot; &quot;);
        }
    }

输出：
10 11 12 13 14 15 16 17 18 19</code></pre>
<h4 id="ReadOnlyBuffer"><a href="#ReadOnlyBuffer" class="headerlink" title="ReadOnlyBuffer"></a>ReadOnlyBuffer</h4><p>普通的Buffer(可读可写)可以随时转换为只读Buffer，但是只读Buffer不可以转换为普通Buffer</p>
<pre><code class="java">ByteBuffer readOnlyBuffer = buffer.asReadOnlyBuffer();</code></pre>
<blockquote>
<p>转换后的Buffer是一个新的只读Buffer，拥有独立的position、limit和capacity</p>
</blockquote>
<h4 id="DirectBuffer"><a href="#DirectBuffer" class="headerlink" title="DirectBuffer"></a>DirectBuffer</h4><p><code>堆外内存buffer，本地JNI非JVM堆内存buffer，允许直接访问</code></p>
<p>普通ByteBuffer由JVM管理，在JVM堆上分配内存</p>
<pre><code class="java">ByteBuffer buf = ByteBuffer.allocate(1024);</code></pre>
<p>DirectBuffer会在本地内存中分配，脱离JVM的堆管理</p>
<pre><code class="java">ByteBuffer buf = ByteBuffer.allocateDirect(1024);</code></pre>
<blockquote>
<p>为什么要这样做呢？</p>
<p>———-又是GC——–</p>
<p>我们都知道JVM 在堆上的老年代中，GC时会采取<code>标记-整理</code>策略，会使得对象在堆内存中的地址发生变化，整理时会buffer太大时会很难gc整理</p>
</blockquote>
<p>所以出现了<code>DirectBuffer</code>，它使用<code>unsafe.allocateMemory</code>分配内存，是一个native方法，由buffer的<code>address</code>变量记录这个内存的地址来提供访问</p>
<h5 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h5><ul>
<li>DirectBuffer：本地方法分配内存显然没有JVM堆分配快，但是涉及<code>IO</code>和<code>网络IO</code>的话就是DirectBuffer比较快了</li>
</ul>
<blockquote>
<p>DirectByteBuffer继承了MappedByteBuffer</p>
<p>缓存的使用可以使用DirectByteBuffer和HeapByteBuffer。如果使用了DirectByteBuffer，一般来说可以减少一次系统空间到用户空间的拷贝。</p>
<p>数据量比较小的中小应用情况下，可以考虑使用heapBuffer；反之可以用directBuffer</p>
</blockquote>
<h4 id="MappedByteBuffer"><a href="#MappedByteBuffer" class="headerlink" title="MappedByteBuffer"></a>MappedByteBuffer</h4><p><strong>映射到堆外内存的ByteBuffer，DirectByteBuffer继承此类实现堆外内存的分配</strong></p>
<p>通过下面方式映射buffer到堆外内存</p>
<pre><code class="java">MappedByteBuffer mappedByteBuffer = channel.map(MapMode.READ_WRITE, 0, channel.size());</code></pre>
<p>使用拷贝文件：</p>
<pre><code class="java">RandomAccessFile in = new RandomAccessFile(&quot;nio/1.txt&quot;, &quot;rw&quot;);
RandomAccessFile out = new RandomAccessFile(&quot;nio/2.txt&quot;, &quot;rw&quot;);
FileChannel inChannel = in.getChannel();
FileChannel outChannel = out.getChannel();
MappedByteBuffer inputData = inChannel.map(FileChannel.MapMode.READ_ONLY,0,new File(&quot;nio/1.txt&quot;).length());
Charset charset = Charset.forName(&quot;utf-8&quot;);//编码
CharsetDecoder decoder = charset.newDecoder();
CharsetEncoder encoder = charset.newEncoder();
CharBuffer charBuffer = decoder.decode(inputData);
ByteBuffer buffer = encoder.encode(charBuffer);
outChannel.write(buffer);
in.close();out.close();</code></pre>
<h3 id="Channel—通道"><a href="#Channel—通道" class="headerlink" title="Channel—通道"></a>Channel—通道</h3><h4 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h4><p>NIO提供的一种连接到文件的通道，用于文件的读写</p>
<p><strong>在使用FileChannel时，需要从<code>输入输出流或者RandomAccessFile</code>中获取FIleChannel</strong></p>
<ul>
<li>如果要向FileChannel中读取数据，需要申请一个ByteBuffer，将数据从FileChannel中读取到缓冲区ByteBuffer，<code>read()</code>返回多少个字节被读取，如果返回-1说明文件已经到达末尾</li>
<li>如果要向FileChannel中写入数据，需要先将数据写入到ByteBuffer中，在从ByteBuffer中写入到FileChannel中，调用<code>write()</code>方法</li>
</ul>
<blockquote>
<p>注意读写之间需要Buffer.flip();</p>
</blockquote>
<p>例子：</p>
<p>1.读取文件数据并打印</p>
<pre><code class="java">FileInputStream fileInputStream = new FileInputStream(&quot;1.log&quot;);
FileChannel channel = fileInputStream.getChannel();
ByteBuffer byteBuffer = ByteBuffer.allocate(512);;
channel.read(byteBuffer);
byteBuffer.flip();
while(byteBuffer.remaining()&gt;0){
    byte b = byteBuffer.get();
    System.out.println((char) b);
}
fileInputStream.close();</code></pre>
<p>2.把1.txt数据写入2.txt</p>
<pre><code class="java">FileInputStream inputStream = new FileInputStream(&quot;1.txt&quot;);
FileChannel in = inputStream.getChannel();
FileOutputStream outputStream = new FileOutputStream(&quot;2.txt&quot;);
FileChannel out = outputStream.getChannel();
ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
while(true){
    byteBuffer.clear();//没有的话会一直读取
    int read = in.read(byteBuffer);
    System.out.println(&quot;read:&quot;+read);
    if(read==-1){
        break;//为-1表示文件结束 返回
    }
    byteBuffer.flip();
    out.write(byteBuffer);
}
inputStream.close();
outputStream.close();</code></pre>
<h4 id="ServerSockerChannel"><a href="#ServerSockerChannel" class="headerlink" title="ServerSockerChannel"></a>ServerSockerChannel</h4><p>NIO提供了一种可以监听新进入的TCP连接的通道，就是<code>ServerSocketChannel</code>，对应IO中<code>ServerSocket</code></p>
<ul>
<li>打开监听通道</li>
</ul>
<pre><code class="java">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
serverSocketChannel.socket().bind(new InetSocketAddress(9999));
while(true){
    SocketChannel socketChannel = serverSocketChannel.accept();
    //do something with socketChannel...
}</code></pre>
<h4 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h4><p>NIO提供的一种连接到TCP套接字的通道，就是<code>SocketChannel</code>，对应IO中<code>Socket</code></p>
<ul>
<li>打开一个SocketChannel</li>
</ul>
<pre><code class="java">SocketChannel socketChannel = SocketChannel.open();
socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));</code></pre>
<h4 id="Channel读写"><a href="#Channel读写" class="headerlink" title="Channel读写"></a>Channel读写</h4><ul>
<li>读</li>
</ul>
<pre><code class="java">ByteBuffer buf = ByteBuffer.allocate(48);
int bytesRead = socketChannel.read(buf);</code></pre>
<ul>
<li>写</li>
</ul>
<pre><code class="java">ByteBuffer writeBuffer = ByteBuffer.allocate(48);
String msg = &quot;hello&quot;;
writeBuffer.put(msg.getBytes());
writeBuffer.flip();
channel.write(writeBuffer);</code></pre>
<ul>
<li>读完写</li>
</ul>
<pre><code class="java">ByteBuffer buffer = ByteBuffer.allocate(1024);
int byteRead = channel.read(buffer);
if(byteRead&lt;=0){
    channel.close();
    break;
}
buffer.flip();
channel.write(buffer);
read += byteRead;
buffer.clear();</code></pre>
<blockquote>
<p>每次写完buffer，如果buffer数据不需要再使用，建议clear清空buffer，准备下一次写操作</p>
</blockquote>
<h3 id="Selector—多路复用器-选择器"><a href="#Selector—多路复用器-选择器" class="headerlink" title="Selector—多路复用器(选择器)"></a>Selector—多路复用器(选择器)</h3><p><strong>多路复用器，这个名字很形象，使用一个线程去处理多个channel，从而管理多个channel</strong></p>
<blockquote>
<p>为什么要使用一个线程管理多个channel？</p>
<p>线程上下文切换开销很大，线程越少处理channel更高效</p>
</blockquote>
<img src="http://dzou.wangminwei.top/static/images/nio/2.png">

<h4 id="创建Selector—创建比赛"><a href="#创建Selector—创建比赛" class="headerlink" title="创建Selector—创建比赛"></a>创建Selector—创建比赛</h4><pre><code class="java">Selector selector = Selector.open();</code></pre>
<h4 id="注册channel—购买入场卷"><a href="#注册channel—购买入场卷" class="headerlink" title="注册channel—购买入场卷"></a>注册channel—购买入场卷</h4><p>channel通过注册到selector上来把channel的事件交给Selector管理，并且返回一个SelectionKey</p>
<pre><code class="java">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</code></pre>
<ul>
<li>与 Selector 一起使用时，Channel 必须处于<code>非阻塞模式</code>下。这意味着不能将 FileChannel 与 Selector 一起使用，因为 FileChannel 不能切换到非阻塞模式</li>
</ul>
<pre><code class="java">channel.configureBlocking(false);</code></pre>
<ul>
<li>通过SelectionKey获取channel和selector以及准备好的事件</li>
</ul>
<pre><code class="java">Channel  channel  = selectionKey.channel();
Selector selector = selectionKey.selector();</code></pre>
<h4 id="Selector执行选择—拿着入场卷入场"><a href="#Selector执行选择—拿着入场卷入场" class="headerlink" title="Selector执行选择—拿着入场卷入场"></a>Selector执行选择—拿着入场卷入场</h4><p>把channel注册到Selector后，我们可以使用<code>Selector.select();</code>方法获取准备就绪的通道，返回一个int型整数，表示准备好的channel数</p>
<p>通过<code>selector.selectedKeys();</code>方法获取准备就绪的SelectionKey，再通过SelectionKey获取channel和selector，一般使用迭代器遍历这些准备好的channel</p>
<blockquote>
<p>在每一次处理完一个SelectionKey，必须把它从迭代器中删除，处理完，这个SelectionKey就没有用了，就像一个入场卷，你可以通过它进入赛场并且它上面有入场人和座位对应信息，比赛结束后你无法再通过它执行任何有效的操作。</p>
</blockquote>
<ul>
<li>看完比赛，举办者不会回收所有的票据，需要你们自己处理，不能乱丢在场地中，需要自己丢到垃圾桶中或者带回家</li>
</ul>
<pre><code class="java">iterator.remove()；</code></pre>
<ul>
<li>wakeUp()方法</li>
</ul>
<p>某个线程调用 select() 方法后阻塞了，即使没有通道已经就绪，也无法返回，wakeUp方法使得立马返回。</p>
<h3 id="Scatter、Gather"><a href="#Scatter、Gather" class="headerlink" title="Scatter、Gather"></a>Scatter、Gather</h3><blockquote>
<p>scatter / gather 经常用于需要将传输的数据分开处理的场合，例如传输一个由消息头和消息体组成的消息，你可能会将消息体和消息头分散到不同的 buffer 中，这样你可以方便的处理消息头和消息体。</p>
</blockquote>
<h4 id="Scatter"><a href="#Scatter" class="headerlink" title="Scatter"></a>Scatter</h4><p>分散（scatter）从 Channel 中读取是指在读操作时将读取的数据写入多个 buffer 中。因此，Channel 将从 Channel 中读取的数据 “分散（scatter）” 到多个 Buffer 中。</p>
<h4 id="Gather"><a href="#Gather" class="headerlink" title="Gather"></a>Gather</h4><p>聚集（gather）写入 Channel 是指在写操作时将多个 buffer 的数据写入同一个 Channel，因此，Channel 将多个 Buffer 中的数据 “聚集（gather）” 后发送到 Channel。</p>
<p>例子：用三个长度分别为3,4,5的buffer存储输入的字符串，前3个字符存储在第一个buffer，4-7字符存储在第二个buffer，长度为4,8-12存储在第三个buffer，长度为5</p>
<pre><code class="java">ServerSocketChannel serverSocketChannel =  ServerSocketChannel.open();
        InetSocketAddress inetSocketAddress = new InetSocketAddress(8899);
        serverSocketChannel.socket().bind(inetSocketAddress);
        int messageLength = 3 + 4 + 5;
        ByteBuffer[] byteBuffer = new ByteBuffer[3];
        byteBuffer[0] = ByteBuffer.allocate(3);
        byteBuffer[1] = ByteBuffer.allocate(4);
        byteBuffer[2] = ByteBuffer.allocate(5);
        SocketChannel socketChannel = serverSocketChannel.accept();
        while (true){
            int byteRead = 0;
            while (byteRead&lt;messageLength){
                long r = socketChannel.read(byteBuffer);
                byteRead += r;
                System.out.println(&quot;byteread:&quot;+byteRead);
                Arrays.stream(byteBuffer).map(o-&gt;&quot;position:&quot;+o.position()+&quot;,limit:&quot;+o.limit()).forEach(System.out::println);
            }

            Arrays.stream(byteBuffer).forEach(Buffer::flip);

            int byteWrite = 0;
            while(byteWrite&lt;messageLength){
                long r = socketChannel.write(byteBuffer);
                byteWrite += r;
                System.out.println(&quot;bytewrite:&quot;+byteWrite);
                Arrays.stream(byteBuffer).map(o-&gt;&quot;position:&quot;+o.position()+&quot;,limit:&quot;+o.limit()).forEach(System.out::println);
            }

            Arrays.stream(byteBuffer).forEach(Buffer::clear);
        }

测试：使用linux nc localhost 8899测试
输入：helloworld回车 
输出：
byteread:11
position:3,limit:3
position:4,limit:4
position:4,limit:5
解释：
回车算一个字符一共11个字符，前三个存储到第一个buffer了，存满了；中间四个存储到第二个buffer，存满了；剩下多余的存储到第三个buffer，没有存满</code></pre>
<h3 id="NIO服务端客户端"><a href="#NIO服务端客户端" class="headerlink" title="NIO服务端客户端"></a>NIO服务端客户端</h3><p>这个程序演示使用NIO创建一个聊天室，服务端和多个客户端连接，客户端可以互发消息</p>
<ul>
<li>server服务端</li>
</ul>
<pre><code class="java">/**
 * 可以直接使用 linux nc命令当做客户端
 * nc localhost 端口
 */
public class Server {
    private static Map&lt;SocketChannel,String&gt; clientMap = new HashMap&lt;&gt;();
    public static void main(String[] args) throws IOException {
        //打开服务器channel
        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
        //设置非阻塞 即将使用selector
        serverSocketChannel.configureBlocking(false);
        //获取服务器的socket
        ServerSocket serverSocket = serverSocketChannel.socket();
        //绑定端口
        serverSocket.bind(new InetSocketAddress(8089));
        //打开一个多路复用器，使用一条线程处理客户端channel
        Selector selector = Selector.open();
        //注册服务器channel到
        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);
        while (true){
            //阻塞获取channel事件
            //一旦调用了 select() 方法，并且返回值表明有一个或更多个通道就绪了
            int num = selector.select();
            /**
             * 获取到后 拿到多路复用器的SelectionKey 核心方法channel获取注册在起上的channel
             * SelectionKey 每次注册一个channel都会创建一个SelectionKey 其中常量定义channel状态
            **/
            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();
            //对其中每一个SelectionKey进行操作
            selectionKeys.forEach(selectionKey-&gt;{
                    try {
                        //如果该服务器SelectionKey被接收
                        if(selectionKey.isAcceptable()){
                            //拿到服务器channel
                            ServerSocketChannel server = (ServerSocketChannel) selectionKey.channel();
                            SocketChannel client = null;
                            //拿到本次连接上服务器的客户端
                            client = server.accept();
                            client.configureBlocking(false);
                            //把客户端注册到多路复用器，监听客户端的可读事件
                            client.register(selector,SelectionKey.OP_READ);
                            //为每个客户端分配id
                            String key = &quot;[&quot;+ UUID.randomUUID()+&quot;]&quot;;
                            clientMap.put(client,key);
                            //如果SelectionKey读就绪，执行读操作
                        }else if(selectionKey.isReadable()){
                            //拿到channel
                            SocketChannel channel = (SocketChannel) selectionKey.channel();
                            //创建读buffer
                            ByteBuffer readBuffer = ByteBuffer.allocate(1024);
                            //读取channel中数据到读buffer
                            int read = channel.read(readBuffer);
                            String reMsg = &quot;&quot;;
                            //如果有数据
                            if(read&gt;0){
                                //翻转进行写操作
                                readBuffer.flip();
                                //制定解码集utf-8，对读buffer解码打印
                                Charset charset = Charset.forName(&quot;utf-8&quot;);
                                reMsg = String.valueOf(charset.decode(readBuffer).array());
                                System.out.println(clientMap.get(channel)+&quot; receive: &quot;+reMsg);
                            }else if(read==-1) channel.close();//如果客户端关闭就关闭客户端channel
                            //群发：发送数据到其他客户端channel
                            for(SocketChannel ch:clientMap.keySet()){
                                if(ch!=channel) {
                                    String key = clientMap.get(ch);
                                    ByteBuffer writeBuffer = ByteBuffer.allocate(1024);
                                    writeBuffer.put((&quot;来自&quot;+key + &quot;:&quot; + reMsg).getBytes());
                                    writeBuffer.flip();
                                    ch.write(writeBuffer);
                                }
                            }
                        }

                    } catch (IOException e) {
                        e.printStackTrace();

                }
            });
            selectionKeys.clear();//每次处理完一个SelectionKey的事件，把该SelectionKey删除
        }
    }
}</code></pre>
<ul>
<li>客户端</li>
</ul>
<pre><code class="java">public class Client {
    public static void main(String[] args) throws IOException {
        //打开客户端channel
        SocketChannel socketChannel = SocketChannel.open();
        //设置为非阻塞模式，可以配合selector使用
        socketChannel.configureBlocking(false);
        //打开selector
        Selector selector = Selector.open();
        //注册客户端channel到多路复用器，监听连接事件
        socketChannel.register(selector, SelectionKey.OP_CONNECT);
        //连接到指定地址
        socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;,8089));
        while (true){
            try{
                    //执行selector方法，阻塞获取channel事件的触发
                    int num = selector.select();
                    //获取注册到多路复用器上的SelectionKey
                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();
                    //通过迭代器遍历SelectionKey
                    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();
                    while (iterator.hasNext()) {
                        SelectionKey selectionKey = iterator.next();
                        //如果SelectionKey触发的事件为连接就绪
                        if(selectionKey.isConnectable()){
                            //拿到SelectionKey的客户端channel
                            SocketChannel client = (SocketChannel) selectionKey.channel();
                            if(client.isConnectionPending()){
                                //完成连接
                                client.finishConnect();
                                //新建一个写buffer
                                ByteBuffer writeBuffer = ByteBuffer.allocate(1024);
                                //写入客户端连接成功消息
                                writeBuffer.put((client.toString()+&quot;:连接成功!&quot;).getBytes());
                                //翻转读写操作 执行写操作
                                writeBuffer.flip();
                                //写入buffer数据刅客户端
                                client.write(writeBuffer);
                                //开辟一个线程写，因为标准输入是阻塞的，当前线程不能阻塞写
                                ExecutorService executorService = Executors.newSingleThreadExecutor();
                                executorService.submit(()-&gt;{
                                    while (true){
                                        writeBuffer.clear();
                                        InputStreamReader reader = new InputStreamReader(System.in);
                                        BufferedReader br = new BufferedReader(reader);
                                        String msg = br.readLine();
                                        //每次读入一行，写入数据到buffer并且写入客户端channel
                                        writeBuffer.put(msg.getBytes());
                                        writeBuffer.flip();
                                        client.write(writeBuffer);
                                    }
                                });
                            }
                            //注册客户端可读事件到多路复用器
                            client.register(selector,SelectionKey.OP_READ);
                            //如果多路复用器上的SelectionKey处于读就绪状态
                        }else if(selectionKey.isReadable()){
                            //拿到SelectionKey触发相应事件对应的客户端channel，执行读操作
                            SocketChannel client = (SocketChannel) selectionKey.channel();
                            //创建一个新的读buffer，
                            ByteBuffer readBuffer = ByteBuffer.allocate(1024);
                            //从准备好读操作的channel中读取数据
                            int count = client.read(readBuffer);
                            if (count&gt;0){
                                //转码并数据使用String保存且打印
                                String reMsg = new String(readBuffer.array(),0,count);
                                System.out.println(reMsg);
                            }else if(count==-1) client.close();//关闭客户端
                        }
                    }
                    selectionKeys.clear();//每次处理完一个SelectionKey的事件，把该SelectionKey删除
                }
            catch (Exception e){
                e.printStackTrace();
            }
        }
    }
}</code></pre>
<ul>
<li>测试</li>
</ul>
<p><strong>1.创建一个服务端和三个客户端</strong></p>
<p><strong>2.客户端1,2,3分别发送数据</strong></p>
<p>服务端拿到连接信息和三个客户端发送信息</p>
<img src="http://dzou.wangminwei.top/static/images/nio/6.png">

<p>客户端1先创建，拿到2,3连接信息和2,3发送信息</p>
<img src="http://dzou.wangminwei.top/static/images/nio/3.png">

<p>客户端2先于3创建，拿到3连接信息和1,3发送信息</p>
<img src="http://dzou.wangminwei.top/static/images/nio/4.png">

<p>客户端3最后创建，只能拿到1,2发送信息</p>
<img src="http://dzou.wangminwei.top/static/images/nio/5.png">

<p><strong>3.此时再使用nc命令创建一个客户端</strong></p>
<p>发送信息，客户端可以收到</p>
<img src="http://dzou.wangminwei.top/static/images/nio/8.png">

<p>客户端2发送信息，该终端客户端也可以收到</p>
<img src="http://dzou.wangminwei.top/static/images/nio/7.png">



<h3 id="NIO案例—跨端口传输数据—MultiServer"><a href="#NIO案例—跨端口传输数据—MultiServer" class="headerlink" title="NIO案例—跨端口传输数据—MultiServer"></a>NIO案例—跨端口传输数据—MultiServer</h3><p><strong>实现目标：服务端监听两个端口，一个8089，一个8090,8089只有唯一的一个主客户端A连接，8090有多个客户端B连接，客户端A接收多个客户端B连接的发送的消息，实现跨端口的消息转发</strong></p>
<img src="http://dzou.wangminwei.top/static/images/nio/9.png">

<ul>
<li><strong>服务端</strong></li>
</ul>
<p>我们先看服务端，服务端首先需要监听两个端口，我们创建两个服务端channel；服务端接收到连接后监听客户端B的发送数据事件(也就是客户端writable服务端readable事件)；拿到客户端B的消息后，把它发送到客户端A</p>
<blockquote>
<p>服务端怎么发送数据到客户端A？</p>
<p>保存一个客户端channel集合，为不同端口客户端分配不同的id的结尾部分，客户端A分配为wxq]，客户端B分配为gzh]，在他们channel创建的时候保存到HashMap中，channel作为key，id作为值保存</p>
</blockquote>
<p><strong>下面说一下服务端流程：</strong></p>
<ol>
<li>创建两个服务端channel，绑定不同端口</li>
<li>创建一个多路复用器selector，把两个服务端注册到selector上，并监听acceptable事件</li>
<li>执行selector.select()方法，拿到SelectionKey集合，对不同事件做不停处理<ol>
<li>如果事件为<code>接收就绪</code>，通过<code>SelectionKey.channel()</code>方法拿到服务端channel，根据端口不同注册不同的监听事件，如果是8090的，说明是客户端B的连接完成，拿到客户端B的channel，监听它的<code>可读事件</code>，并且分配id后缀为gzh]并且保存；如果是8089端口的服务端channel，说明是客户端A的连接完成，客户端客户端A的channel，监听它的<code>可写事件</code>，并且分配id后缀为wxq]，保存到hashmap</li>
<li>如果事件是<code>读就绪</code>，说明客户端B已经完后数据的写操作，可以读取客户端B的数据，执行读取；首先把数据读取并写入到<code>readBuffer</code>，使用<code>new String(readBuffer.array()</code>创建即将发送的msg，遍历客户端channel的key，如果后缀为wxq]，说明是客户端A，则把数据写入writeBuffer中，并把数据写入客户端A的channel中</li>
</ol>
</li>
<li>每次SelectionKey的事件执行完毕，把该SelectionKey删除</li>
</ol>
<p><strong>代码：</strong></p>
<pre><code class="java">public class Server {
    private static int CAPACITY = 1024;
    private static ByteBuffer readBuffer = ByteBuffer.allocate(CAPACITY);
    private static ByteBuffer writeBuffer = ByteBuffer.allocate(CAPACITY);
    private static Map&lt;SocketChannel,String&gt; clientMap = new HashMap&lt;&gt;();

    public static void main(String[] args) throws IOException {
        ServerSocketChannel serverSocketChannelWxq = ServerSocketChannel.open();
        ServerSocketChannel serverSocketChannelGzh = ServerSocketChannel.open();
        serverSocketChannelGzh.configureBlocking(false);
        serverSocketChannelWxq.configureBlocking(false);
        ServerSocket serverSocketWxq = serverSocketChannelWxq.socket();
        ServerSocket serverSocketGzh = serverSocketChannelGzh.socket();
        serverSocketWxq.bind(new InetSocketAddress(8089));
        System.out.println(&quot;监听8089：微信墙服务端口&quot;);
        serverSocketGzh.bind(new InetSocketAddress(8090));
        System.out.println(&quot;监听8090：公众号服务端口&quot;);
        Selector selector = Selector.open();
        serverSocketChannelWxq.register(selector, SelectionKey.OP_ACCEPT);
        serverSocketChannelGzh.register(selector, SelectionKey.OP_ACCEPT);
        while (true){
            int num = selector.select();
            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();
            selectionKeys.forEach(selectionKey-&gt;{
                try {
                    if(selectionKey.isAcceptable()){
                        ServerSocketChannel server = (ServerSocketChannel) selectionKey.channel();
                        SocketChannel client = null;
                        client = server.accept();
                        client.configureBlocking(false);
                        String key = &quot;&quot;;
                        if(server==serverSocketChannelGzh) {//如果是公众号server，注册其客户端的可读事件
                            client.register(selector, SelectionKey.OP_READ);
                            key = &quot;[&quot;+ UUID.randomUUID()+&quot;:gzh]&quot;;
                        }else if(server==serverSocketChannelWxq){//如果是
                            client.register(selector,SelectionKey.OP_WRITE);
                            key = &quot;[&quot;+ UUID.randomUUID()+&quot;:wxq]&quot;;
                        }
                        System.out.println(key+&quot;:连接成功!&quot;);
                        clientMap.put(client,key);
                    }else if(selectionKey.isReadable()){
                        SocketChannel channel = (SocketChannel) selectionKey.channel();
                        readBuffer.clear();
                        int read = 0;
                        while(true){
                            int byteRead = channel.read(readBuffer);
                            if(byteRead&lt;=0){
                                break;
                            }
                            readBuffer.flip();
                            channel.write(readBuffer);
                            read += byteRead;
                            readBuffer.clear();
                        }
                        String reMsg = new String(readBuffer.array(),0,read);
                        System.out.println(clientMap.get(channel)+&quot; send to wxq: &quot;+reMsg);
                        //写入微信墙服务
                        for(SocketChannel ch:clientMap.keySet()){
                            if(ch!=channel) {
                                String key = clientMap.get(ch);
                                if(key.endsWith(&quot;wxq]&quot;)) {
                                    writeBuffer.clear();
                                    writeBuffer.put((&quot;来自&quot; + clientMap.get(channel) + &quot;:&quot; + reMsg).getBytes(StandardCharsets.UTF_8));
                                    writeBuffer.flip();
                                    ch.write(writeBuffer);
                                }
                            }
                        }
                    }

                } catch (IOException e) {
                    e.printStackTrace();
                }
            });
            selectionKeys.clear();//每次处理完一个SelectionKey的事件，把该SelectionKey删除
        }
    }
}</code></pre>
<p><strong>到此，服务端写完了，你就可以使用linux或者win下的<code>nc</code>命令连接到服务端，模拟客户端A和客户端B发送消息</strong></p>
<img src="http://dzou.wangminwei.top/static/images/nio/10.png">

<img src="http://dzou.wangminwei.top/static/images/nio/11.png">

<blockquote>
<p>客户端发送消息后会会写一条是因为我在接收到消息后把消息写入客户端B的buffer中了</p>
</blockquote>
<ul>
<li><strong>客户端B—发送消息</strong></li>
</ul>
<p>客户端B负责发送消息，主要事件就是负责写数据</p>
<p>流程：</p>
<ol>
<li>创建一个客户端channel<code>SocketChannel</code>，打开一个多留复用器selector，绑定<code>可连接事件</code>，连接到服务端监听的8090端口</li>
<li>执行<code>selector.select()</code>方法，处理<code>连接就绪</code>和<code>写就绪两个事件</code><ol>
<li>如果事件为<code>连接就绪</code>，只需要拿到channel，执行<code>finishConnect</code>方法完成连接，并且注册监听事件为<code>可写事件</code></li>
<li>如果事件为<code>写就绪</code>，执行写操作，使用标准输入从控制台读取输入并且写入writebuffer中，通过<code>channel.write()</code>方法写入数据到客户端</li>
</ol>
</li>
<li>清理事件的SelectionKey</li>
</ol>
<p><strong>代码：</strong></p>
<pre><code class="java">public class GzhClient {
    public static void main(String[] args) throws IOException {
        SocketChannel socketChannel = SocketChannel.open();
        socketChannel.configureBlocking(false);
        Selector selector = Selector.open();
        socketChannel.register(selector, SelectionKey.OP_CONNECT);
        socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;,8090));
        while (true){
            try{
                int num = selector.select();
                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();
                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();
                while (iterator.hasNext()) {
                    SelectionKey selectionKey = iterator.next();
                    if(selectionKey.isConnectable()){
                        SocketChannel client = (SocketChannel) selectionKey.channel();
                        if(client.isConnectionPending()){
                            client.finishConnect();
                        }
                        client.register(selector,SelectionKey.OP_WRITE);
                    }else if(selectionKey.isWritable()){
                        SocketChannel client = (SocketChannel) selectionKey.channel();
                        ByteBuffer writeBuffer = ByteBuffer.allocate(1024);
                        writeBuffer.clear();
                        InputStreamReader reader = new InputStreamReader(System.in);
                        BufferedReader br = new BufferedReader(reader);
                        String msg = br.readLine();
                        //每次读入一行，写入数据到buffer并且写入客户端channel
                        writeBuffer.put(msg.getBytes());
                        writeBuffer.flip();
                        client.write(writeBuffer);
                    }
                }
                selectionKeys.clear();//每次处理完一个SelectionKey的事件，把该SelectionKey删除
            }
            catch (Exception e){
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
<ul>
<li><strong>客户端A—接收服务端转发消息</strong></li>
</ul>
<p>客户端A负责发送消息，主要事件就是负责读数据</p>
<p>流程：</p>
<ol>
<li>创建一个客户端channel<code>SocketChannel</code>，打开一个多留复用器selector，绑定<code>可连接事件</code>，连接到服务端监听的8089端口</li>
<li>执行<code>selector.select()</code>方法，处理<code>连接就绪</code>和<code>读就绪两个事件</code><ol>
<li>如果事件为<code>连接就绪</code>，只需要拿到channel，执行<code>finishConnect</code>方法完成连接，并且注册监听事件为<code>可写事件</code></li>
<li>如果事件为<code>读就绪</code>，执行读操作，把channel中数据使用<code>read()</code>方法读取到readBuffer中，通过<code>new String(readBuffer.array()</code>方法接收String类型数据，并且打印到控制台</li>
</ol>
</li>
<li>清理事件的SelectionKey</li>
</ol>
<p><strong>代码：</strong></p>
<pre><code class="java">public class WxQClient {
    public static void main(String[] args) throws IOException {
        SocketChannel socketChannel = SocketChannel.open();
        socketChannel.configureBlocking(false);
        Selector selector = Selector.open();
        socketChannel.register(selector, SelectionKey.OP_CONNECT);
        socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;,8089));
        while (true){
            try{
                int num = selector.select();
                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();
                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();
                while (iterator.hasNext()) {
                    SelectionKey selectionKey = iterator.next();
                    if(selectionKey.isConnectable()){
                        SocketChannel client = (SocketChannel) selectionKey.channel();
                        if(client.isConnectionPending()){
                            client.finishConnect();
                        }
                        client.register(selector,SelectionKey.OP_READ);
                    }else if(selectionKey.isReadable()){
                        SocketChannel client = (SocketChannel) selectionKey.channel();
                        ByteBuffer readBuffer = ByteBuffer.allocate(1024);
                        int count = client.read(readBuffer);
                        if (count&gt;0){
                            String reMsg = new String(readBuffer.array(),0,count);
                            System.out.println(reMsg);
                        }else if(count==-1) client.close();//关闭客户端
                    }
                }
                selectionKeys.clear();//每次处理完一个SelectionKey的事件，把该SelectionKey删除
            }
            catch (Exception e){
                e.printStackTrace();
            }
        }
    }
}</code></pre>
<p><strong>至此，我们服务端和客户端AB都已经完后，现在我们测试一下</strong></p>
<ol>
<li>启动服务端，启动一个WxQClient也就是ClientA，启动两个GzhClient，也就是ClientB</li>
</ol>
<p>服务端显示连接成功</p>
<img src="http://dzou.wangminwei.top/static/images/nio/12.png">

<ol start="2">
<li>客户端B发送消息</li>
</ol>
<p>服务端接收到消息并打印，并转发到客户端A，客户端A打印消息</p>
<img src="http://dzou.wangminwei.top/static/images/nio/13.png">

<img src="http://dzou.wangminwei.top/static/images/nio/14.png">
      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    dzou  |  微信：17856530567
  </li>
  <li class="post-copyright-link">
  <strong>本文链接：</strong>
  <a href="http://www.dzou.top/post/nonblocking-io.html" title="多次尝试的学习—搞懂NIO">http://www.dzou.top/post/nonblocking-io.html</a>
</li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
  </li>
  <li class="post-copyright-license">
    并保留本声明和上方二维码。感谢您的阅读和支持！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/Web/" rel="tag"># Web</a>
          
            <a href="/tags/基础/" rel="tag"># 基础</a>
          
            <a href="/tags/NIO/" rel="tag"># NIO</a>
          
            <a href="/tags/网络通信/" rel="tag"># 网络通信</a>
          
            <a href="/tags/异步/" rel="tag"># 异步</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div id="needsharebutton-postbottom">
            <span class="btn">
              <i class="fa fa-share-alt" aria-hidden="true"></i>
            </span>
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/post/charsets.html" rel="next" title="字符集编码—ASCII/ISO-8859-1/GBK/unicode/UTF-8">
                <i class="fa fa-chevron-left"></i> 字符集编码—ASCII/ISO-8859-1/GBK/unicode/UTF-8
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/post/netty-example-5.html" rel="prev" title="netty学习案例—实现websocket长连接和socket之间通信">
                netty学习案例—实现websocket长连接和socket之间通信 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript" rel="external nofollow noopener noreferrer" target="_blank">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/2.JPG" alt="dzou">
            
              <p class="site-author-name" itemprop="name">dzou</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">80</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">92</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/ding-zou" target="_blank" title="GitHub" rel="external nofollow noopener noreferrer">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="dingxiang.zoufubo@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://me.csdn.net/qq_44760332" target="_blank" title="CSDN" rel="external nofollow noopener noreferrer">
                      
                        <i class="fa fa-fw fa-copyright"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                推荐链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.dzou.top/post/7a5625fe.html" title="Java并发之AQS源码分析" target="_blank">Java并发之AQS源码分析</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.dzou.top/post/366ffd58.html" title="SpringBoot自动配置原理-源码分析" target="_blank">SpringBoot自动配置原理-源码分析</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.dzou.top/post/712f837.html" title="Java Web安全框架Shiro使用" target="_blank">Java Web安全框架Shiro使用</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.dzou.top/post/19e1cc75.html" title="Linux基础命令" target="_blank">Linux基础命令</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.dzou.top/post/8184a8fd.html" title="JDK8新特性——流和Lambda表达式" target="_blank">JDK8新特性——流和Lambda表达式</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://music.163.com/#/user/home?id=564117665" title="网易云音乐" target="_blank" rel="external nofollow noopener noreferrer">网易云音乐</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#NIO—NonBlocking-IO-new-IO"><span class="nav-number">1.</span> <span class="nav-text">NIO—NonBlocking IO(new IO)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Buffer"><span class="nav-number">1.1.</span> <span class="nav-text">Buffer</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Capacity、Position、Limit"><span class="nav-number">1.1.1.</span> <span class="nav-text">Capacity、Position、Limit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#flip、clear、rewind、mark"><span class="nav-number">1.1.2.</span> <span class="nav-text">flip、clear、rewind、mark</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReadOnlyBuffer"><span class="nav-number">1.1.3.</span> <span class="nav-text">ReadOnlyBuffer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DirectBuffer"><span class="nav-number">1.1.4.</span> <span class="nav-text">DirectBuffer</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#比较"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">比较</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MappedByteBuffer"><span class="nav-number">1.1.5.</span> <span class="nav-text">MappedByteBuffer</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Channel—通道"><span class="nav-number">1.2.</span> <span class="nav-text">Channel—通道</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FileChannel"><span class="nav-number">1.2.1.</span> <span class="nav-text">FileChannel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ServerSockerChannel"><span class="nav-number">1.2.2.</span> <span class="nav-text">ServerSockerChannel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SocketChannel"><span class="nav-number">1.2.3.</span> <span class="nav-text">SocketChannel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Channel读写"><span class="nav-number">1.2.4.</span> <span class="nav-text">Channel读写</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Selector—多路复用器-选择器"><span class="nav-number">1.3.</span> <span class="nav-text">Selector—多路复用器(选择器)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建Selector—创建比赛"><span class="nav-number">1.3.1.</span> <span class="nav-text">创建Selector—创建比赛</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注册channel—购买入场卷"><span class="nav-number">1.3.2.</span> <span class="nav-text">注册channel—购买入场卷</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Selector执行选择—拿着入场卷入场"><span class="nav-number">1.3.3.</span> <span class="nav-text">Selector执行选择—拿着入场卷入场</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Scatter、Gather"><span class="nav-number">1.4.</span> <span class="nav-text">Scatter、Gather</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Scatter"><span class="nav-number">1.4.1.</span> <span class="nav-text">Scatter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Gather"><span class="nav-number">1.4.2.</span> <span class="nav-text">Gather</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NIO服务端客户端"><span class="nav-number">1.5.</span> <span class="nav-text">NIO服务端客户端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NIO案例—跨端口传输数据—MultiServer"><span class="nav-number">1.6.</span> <span class="nav-text">NIO案例—跨端口传输数据—MultiServer</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dzou</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">117.3k</span>
  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问用户：
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问次数：
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    

    
      <div id="needsharebutton-float">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://dzou.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://www.dzou.top/post/nonblocking-io.html';
          this.page.identifier = 'post/nonblocking-io.html';
          this.page.title = '多次尝试的学习—搞懂NIO';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://dzou.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.4"></script>



  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "box";
      
          pbOptions.boxForm = "horizontal";
      
          pbOptions.position = "topCenter";
      
          pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
      flOptions = {};
      
          flOptions.iconStyle = "box";
      
          flOptions.boxForm = "horizontal";
      
          flOptions.position = "topRight";
      
          flOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-float', flOptions);
    
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

  

  

  

  


</body>
</html>
<script type="text/javascript" src="/js/src/dynamic_bg.js"></script>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
<script type="text/javascript" src="/js/google-code-prettify/prettify.js"></script>
<script type="text/javascript">
$(window).load(function(){
   $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');
   prettyPrint();
 })    
</script>

