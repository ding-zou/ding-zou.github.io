<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">





  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "d1f94239"
    });
  daovoice('update');
  </script>














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/2.JPG?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/2.JPG?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Java,Java基础,并发编程,锁,同步,线程,多线程,死锁,线程安全性,Synchronized,volatile,重入锁,自旋锁,原子类,CAS,饥饿,Lock,ReentrantLock,Callable,Future,线程池,执行器,ThreadExecutorPool,Condition,Join,ExecutorService,Semaphore,CountDownLatch,CyclicBarrier,wait,notify,await,signal,ThreadLocal,ForkJoin,MapReduce">





  <link rel="alternate" href="/atom.xml" title="Dzou's Blog" type="application/atom+xml">






<meta name="description" content="并发编程是Java程序员最重要的技能之一，也是最难掌握的一种技能。它要求编程者对计算机最底层的运作原理有深刻的理解，同时要求编程者逻辑清晰、思维缜密，这样才能写出高效、安全、可靠的多线程并发程序。">
<meta name="keywords" content="Java,Java基础,并发编程,锁,同步,线程,多线程,死锁,线程安全性,Synchronized,volatile,重入锁,自旋锁,原子类,CAS,饥饿,Lock,ReentrantLock,Callable,Future,线程池,执行器,ThreadExecutorPool,Condition,Join,ExecutorService,Semaphore,CountDownLatch,CyclicBarrier,wait,notify,await,signal,ThreadLocal,ForkJoin,MapReduce">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发编程学习笔记-更新中">
<meta property="og:url" content="https://www.dzou.top/post/37228cde.html">
<meta property="og:site_name" content="Dzou&#39;s Blog">
<meta property="og:description" content="并发编程是Java程序员最重要的技能之一，也是最难掌握的一种技能。它要求编程者对计算机最底层的运作原理有深刻的理解，同时要求编程者逻辑清晰、思维缜密，这样才能写出高效、安全、可靠的多线程并发程序。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://pv4qgqg7s.bkt.clouddn.com/static/images/concurrent/1.png">
<meta property="og:image" content="http://pv4qgqg7s.bkt.clouddn.com/static/images/concurrent/2.png">
<meta property="og:image" content="http://pv4qgqg7s.bkt.clouddn.com/static/images/concurrent/4.png">
<meta property="og:image" content="http://pv4qgqg7s.bkt.clouddn.com/static/images/concurrent/3.png">
<meta property="og:updated_time" content="2019-08-13T16:12:09.974Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java并发编程学习笔记-更新中">
<meta name="twitter:description" content="并发编程是Java程序员最重要的技能之一，也是最难掌握的一种技能。它要求编程者对计算机最底层的运作原理有深刻的理解，同时要求编程者逻辑清晰、思维缜密，这样才能写出高效、安全、可靠的多线程并发程序。">
<meta name="twitter:image" content="http://pv4qgqg7s.bkt.clouddn.com/static/images/concurrent/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'Q66404JRFM',
      apiKey: '27dd0e53d330bf96c9826662fc30055a',
      indexName: 'dzou',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://www.dzou.top/post/37228cde.html">





<link href="/js/google-code-prettify/tomorrow-night-eighties.min.css" type="text/css" rel="stylesheet">



  <title>Java并发编程学习笔记-更新中 | Dzou's Blog</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  
  
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="bg_content">
    <canvas id="canvas"></canvas>
  </div>

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Dzou's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">No pains,no gains.</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.dzou.top/post/37228cde.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/2.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dzou's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Java并发编程学习笔记-更新中</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-23T16:29:32+08:00">
                2019-07-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java并发编程/" itemprop="url" rel="index">
                    <span itemprop="name">Java并发编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/post/37228cde.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="post/37228cde.html" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>&nbsp浏览次数：
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  12.8k字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  54分
                </span>
              
            </div>
          

          
              <div class="post-description">
                  并发编程是Java程序员最重要的技能之一，也是最难掌握的一种技能。它要求编程者对计算机最底层的运作原理有深刻的理解，同时要求编程者逻辑清晰、思维缜密，这样才能写出高效、安全、可靠的多线程并发程序。
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="一-创建线程方式"><a href="#一-创建线程方式" class="headerlink" title="一.创建线程方式"></a>一.创建线程方式</h2><ol>
<li>Thread</li>
<li>Runnable 面向接口编程，函数式接口（其实就是一个任务，最终由Thread构造函数传入）</li>
<li>Callable 带返回值线程</li>
<li>定时器 Timer</li>
<li>Lambda表达式</li>
<li>线程池 ThreadExecutorPool</li>
<li>内部类 </li>
<li>Spring 中 注解＠Aysnc</li>
</ol>
<blockquote>
<p>CPU分给每个线程一个时间片，很短，所以看起来是一起执行，切换过程就是==上下文切换==，会消耗一定的资源</p>
</blockquote>
<h2 id="二-线程问题"><a href="#二-线程问题" class="headerlink" title="二.线程问题"></a>二.线程问题</h2><h3 id="1-活跃性问题"><a href="#1-活跃性问题" class="headerlink" title="1.活跃性问题"></a>1.活跃性问题</h3><ul>
<li><p>死锁 ：互相等待 两个线程互相持有对方需要的资源并都不释放</p>
</li>
<li><p>饥饿：资源不足，线程优先级使得优先级低的得不到资源执行，高优先级吞噬低优先级时间片或者线程堵塞在同一个同步代码块</p>
<blockquote>
<p>避免饥饿：设置合理优先级；使用锁代替synchronized</p>
</blockquote>
</li>
<li><p>活锁：是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源。</p>
</li>
</ul>
<h3 id="2-线程安全性"><a href="#2-线程安全性" class="headerlink" title="2.线程安全性"></a>2.线程安全性</h3><ul>
<li>数据竞争：多线程下多个线程共享变量，对资源进行了非原子型操作</li>
</ul>
<p>解决途径：</p>
<ol>
<li>synchronized（偏向锁、轻量级锁、重量级锁）</li>
<li>volatile</li>
<li>JDK原子类</li>
<li>Lock（独占锁、共享锁）</li>
</ol>
<h2 id="三-Synchronized"><a href="#三-Synchronized" class="headerlink" title="三.Synchronized"></a>三.Synchronized</h2><blockquote>
<p>锁是互斥的：你能执行我就不能执行</p>
</blockquote>
<ul>
<li>synchronized放在方法上：该方法为同步方法（静态、普通） ==锁的对象时当前类实例==</li>
<li>放在方法内部修饰代码块：该代码块为同步代码块</li>
</ul>
<p>JDK6以后对<code>Synchronized</code>进行了优化：</p>
<ol>
<li>偏向锁： 当一个线程访问同步块时，获取锁时会在对象头和栈帧中的所记录中存储锁偏向的线程ID，以后该线程进入退出同步块时不需要进行CAS操作来加锁解锁，只需对象头中里是否存储该线程ID进行判断，如果没有再使用CAS竞争锁。它会等到竞争出现才释放。</li>
<li>轻量级锁： 当一个线程访问同步块时，JVM先在当前线程栈帧中创建存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，然后线程使用CAS将对象头中的值替换为指向锁记录的指针，成功则获取到锁，否则有线程竞争使用自选获取。解锁时用CAS将指针替换为对象头的值，成功则解锁，否则有线程竞争，将升级为重量级锁，释放并唤醒等待线程。</li>
<li>重量级锁：如果轻量级锁存在其他线程竞争锁CAS失败后自旋后去锁失败则升级为重量级锁。</li>
</ol>
<h2 id="四-锁的类型"><a href="#四-锁的类型" class="headerlink" title="四.锁的类型"></a>四.锁的类型</h2><h3 id="1-重入锁"><a href="#1-重入锁" class="headerlink" title="1.重入锁"></a>1.重入锁</h3><blockquote>
<p>重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁</p>
</blockquote>
<ul>
<li>synchronized</li>
<li>ReentrantLock</li>
</ul>
<p>例：当a、b方法都被synchronized修饰时，在a方法中调用b方法是可以在一个线程进入的</p>
<pre><code class="java">public synchronized void a(){
        System.out.println(Thread.currentThread().getName()+&quot;:&quot;+&quot;a&quot;);
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        b();
    }

    public synchronized void b(){
        System.out.println(Thread.currentThread().getName()+&quot;:&quot;+&quot;b&quot;);
    }

    public static void main(String[] args) {
        Demo3 d = new Demo3();
        ExecutorService threadPool = Executors.newFixedThreadPool(30);
        for(int i=0;i&lt;30;i++){
            threadPool.execute(d::a);
        }
    }</code></pre>
<h3 id="2-自旋锁"><a href="#2-自旋锁" class="headerlink" title="2.自旋锁"></a>2.自旋锁</h3><blockquote>
<p>当一个线程要获取锁时，该锁已经被其他线程获取了，那么它会一直等待该线程释放锁，不但判断所能否被成功获取，直到成功</p>
</blockquote>
<pre><code class="java">while(Thread.activeCount()!=){
            //自旋
        }
        System.out.println(&quot;线程执行完毕！&quot;);</code></pre>
<p>没有执行任何有效的任务，会造成 busy-waiting</p>
<h3 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3.死锁"></a>3.死锁</h3><blockquote>
<p>互相等待 两个线程互相持有对方需要的资源并都不释放</p>
</blockquote>
<pre><code class="java">private final Object o1 = new Object();
    private final Object o2 = new Object();
    public void a(){
        synchronized (o1){
            synchronized (o2){
                System.out.println(Thread.currentThread().getName()+&quot;:&quot;+&quot;a&quot;);
            }
        }
    }
    public void b(){
        synchronized (o2){
            synchronized (o1){
                System.out.println(Thread.currentThread().getName()+&quot;:&quot;+&quot;b&quot;);
            }
        }
    }

    public static void main(String[] args) {
        Demo d = new Demo();
        for(int i=0;i&lt;10;i++){
            new Thread(()-&gt;{
                d.a();
                d.b();
            }).start();
        }
    }</code></pre>
<h2 id="五-volatile"><a href="#五-volatile" class="headerlink" title="五.volatile"></a>五.volatile</h2><blockquote>
<p>volatile是一种轻量级锁，被volatile修饰的变量在线程中是可见的，一个线程修改了变量的值，两一个变量可以读取</p>
</blockquote>
<p>生成汇编代码时会在volatile修饰的共享变量进行写操作的时候会多出<strong>Lock前缀的指令</strong></p>
<ul>
<li>把当前处理器缓存的内容写回到内存</li>
<li>这个写回内存的操作会使得CPU中缓存该内存地址的数据无效（保证数据一致性）</li>
</ul>
<h4 id="volatile-与-synchronized比较"><a href="#volatile-与-synchronized比较" class="headerlink" title="volatile 与 synchronized比较"></a>volatile 与 synchronized比较</h4><ul>
<li>volatile更加轻量，保证数据可见性，不保证原子性</li>
<li>synchronized重量级锁，保证数据原子性操作，可替代volatile</li>
</ul>
<h2 id="六-JDK-原子类"><a href="#六-JDK-原子类" class="headerlink" title="六.JDK 原子类"></a>六.JDK 原子类</h2><h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由JVM从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。实际上是借助硬件的相关指令来实现的，不会阻塞线程(或者说只是在硬件级别上阻塞了)。</p>
<ul>
<li>AtomicInteger、AtomicLong、AtomicBoolean</li>
<li>AtomicIntegerArray，AtomicLongArray</li>
<li>AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater</li>
<li>AtomicMarkableReference，AtomicStampedReference，AtomicReferenceArray</li>
</ul>
<blockquote>
<p>我们举AtomicInteger为例，当它执行==getAndIncrement()==自增时，它调用源码如下</p>
</blockquote>
<pre><code class="java">do {   var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));
        return var5;</code></pre>
<p>自增是一个非原子操作，包括取值，自增，和赋值三个步骤。在进行写数据时，会在内存中保留一份原来的旧值，写的时候判断当前要写的值和旧值是否相等，不相等就继续等待，直到相等才执行写操作。</p>
<blockquote>
<p>当调用==getAndAddInt==时，调用源码如下</p>
</blockquote>
<pre><code class="java">do {
            var5 = this.getIntVolatile(var1, var2);
        } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));
        return var5;</code></pre>
<p>拿到内存最新值，使用CAS尝试将内存位置的值修改为目标值var5 + var4，如果修改失败，则获取该内存位置的新值v，然后继续尝试，直至修改成功。</p>
<p>==compareAndSet==方法调用了==compareAndSwap==</p>
<pre><code class="java">public final boolean compareAndSet(int expect, int update) {
        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
    }</code></pre>
<p>核心：原子类的方法进行操作都是使用==unsafe==调用了==compareAndSwap== CAS 这个本地方法实现</p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p><strong>CompareAndSwap</strong> 比较并交换 根本是一个本地方法，有三个参数：内存地址、旧的值、即将更新的值</p>
<p>如果旧的值与将要更新的值相等，则把内存地址的值改为更新的值</p>
<p>利用CPU执行指令实现CAS</p>
<ul>
<li>总线加锁</li>
<li>缓存加锁</li>
</ul>
<p>CAS存在问题：</p>
<ol>
<li>循环时间长开销很大。</li>
<li>只能保证一个共享变量的原子操作。</li>
<li>ABA问题（AtomicStampedReference可以通过版本控制解决==但是==使用互斥同步更高效）</li>
</ol>
<h2 id="七-Lock"><a href="#七-Lock" class="headerlink" title="七.Lock"></a>七.Lock</h2><h3 id="Lock接口方法"><a href="#Lock接口方法" class="headerlink" title="Lock接口方法"></a>Lock接口方法</h3><ul>
<li><p>void lock()  </p>
<p>获取锁</p>
</li>
<li><p>void unlock()</p>
<p>释放锁</p>
</li>
<li><p>Boolean tryLock()</p>
<p>尝试去获取锁，立刻返回获取结果</p>
</li>
<li><p>boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</p>
<p>与tryLock不同点是在获取不到锁后会等待一段时间，还获取不到的话就返回false</p>
</li>
<li><p>void lockInterruptibly() throws InterruptedException;</p>
</li>
</ul>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法，是一个可重入锁</p>
<pre><code class="java">            lock.lock();
            try{
               //处理任务
            }finally {
                //finally防止死锁
                lock.unlock();
            }</code></pre>
<h3 id="lock与synchronized比较"><a href="#lock与synchronized比较" class="headerlink" title="lock与synchronized比较"></a>lock与synchronized比较</h3><p>lock需要自行获取和释放，synchronized不需要</p>
<p>lock可以提高读操作的效率，也可以知道是否获取到锁</p>
<h3 id="自定义锁"><a href="#自定义锁" class="headerlink" title="自定义锁"></a>自定义锁</h3><blockquote>
<p>实现Lock接口，实现其中方法</p>
</blockquote>
<ul>
<li>不可重入自定义锁</li>
</ul>
<pre><code class="java">private boolean isLocked = false;

    public synchronized void lock() {
        //如果锁被获取到则等待释放
        while (isLocked){
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        //等到unlock释放锁后 获取锁
        isLocked = true;
    }
    ......................
public synchronized void unlock() {
        //设置获取锁的标志为未获取
        isLocked = false;
        //通知其他线程获取锁
        notify();
    }</code></pre>
<ul>
<li>可重入自定义锁</li>
</ul>
<pre><code class="java">private Thread lockThread = null;
    private int lockCount = 0;
    private boolean isLocked = false;

    @Override
    public synchronized void lock() {
        //第二个条件判断被锁的线程与当前贤臣过是否为同一个`，同一个的话可重入
        while(isLocked&amp;&amp;Thread.currentThread()!=lockThread){
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        isLocked = true;
        lockCount++;
        lockThread = Thread.currentThread();
    }
    ..........................
public synchronized void unlock() {
        if(Thread.currentThread()==lockThread){
            lockCount--;
            if(lockCount==0){
                isLocked = false;
                notify();
            }
        }
    }</code></pre>
<h2 id="八-AbstractQueuedSynchronizer-AQS"><a href="#八-AbstractQueuedSynchronizer-AQS" class="headerlink" title="八.AbstractQueuedSynchronizer(AQS)"></a>八.AbstractQueuedSynchronizer(AQS)</h2><p>详细看我另一篇博客：<a href="https://www.dzou.top/post/7a5625fe.html">https://www.dzou.top/post/7a5625fe.html</a></p>
<h2 id="九-读写锁"><a href="#九-读写锁" class="headerlink" title="九.读写锁"></a>九.读写锁</h2><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>读写锁中读操作是共享的，并不互斥，读操作可以一起进行；写操作是互斥的，同时只能一个线程获取写锁；</p>
<p>使用如下：</p>
<pre><code class="java">//添加参数指定公平或者非公平
private ReadWriteLock lock = new ReentrantReadWriteLock();
    private Lock readLock = lock.readLock();
    private Lock writeLock = lock.writeLock();</code></pre>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p><strong><em>实现与<code>ReentrantLock</code>类似写锁使用继承AQS类的同步器<code>Sync</code>的<code>tryRelease</code>和<code>tryAcquire</code>，重入次数由int值控制，最大16位二进制-1；读锁是共享锁，使用<code>Sync</code>的<code>tryReleaseShare</code>和<code>tryAcquireShare</code>,读锁重入的次数使用<code>HoldCounter</code>内部类（由<code>ThreadLocal</code>存储）</em></strong></p>
<h3 id="状态维护"><a href="#状态维护" class="headerlink" title="状态维护"></a>状态维护</h3><p>状态由32位二进制整数维护，前16位负责读，后16位负责写，通过位运算确定状态，假设当前状态为<code>S</code>，写状态等于<code>S&amp;0x0000FFFF</code>（将高16位抹去），读状态等于<code>S&gt;&gt;&gt;16</code>无符号右移16位。写状态+1时，<code>S+1</code>；读状态+1时，<code>S+(1&lt;&lt;16)</code>，也就是下面的<code>S+SHARED_UNIT</code></p>
<ol>
<li>读锁的获取：当没有线程处于获取到写锁或者处于请求获取写锁的状态时，可以获取读锁</li>
<li>写锁的获取：首先写锁请求数+1，判断如果没有线程持有写锁并且没有线程持有读锁则可以获取</li>
<li>死锁情况：线程1获取到读锁，线程2请求获取写锁，此时线程1再请求获取读锁就会发生死锁</li>
</ol>
<pre><code class="java">static final int SHARED_SHIFT   = 16;
static final int SHARED_UNIT    = (1 &lt;&lt; SHARED_SHIFT);
static final int MAX_COUNT      = (1 &lt;&lt; SHARED_SHIFT) - 1;
static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;</code></pre>
<h3 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h3><ol>
<li>锁升级：读锁升级为写锁</li>
<li>锁降级：写锁降级为读锁</li>
</ol>
<p>降级过程：如果当前线程获取到写锁，再获取到读锁，随后释放写锁的过程。</p>
<p><code>ReentrantReadWriteLock</code>不支持锁升级，支持把写锁降级到读锁</p>
<pre><code class="java">public void readWrite(){
        //因为要读取isUpdate，所以获取读锁
        readLock.lock();
    //isUpdate volatile修饰，保持可见性
        if(!isUpdate) {
            readLock.unlock();
            //获取写锁写操作
            writeLock.lock();
            try {
                //重新检查isUpdate的值，可能之前有其他线程获取写锁更改了其的值
                if (!isUpdate) {
                    map.put(&quot;key&quot;, &quot;value&quot;);
                }
                //获取读锁
                readLock.lock();
            }finally {
                //释放写锁
                writeLock.unlock();
            }
        }
        //使用读锁读取数据
        try{
            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+map.get(&quot;key&quot;));
        }finally {
            readLock.unlock();
        }
    }</code></pre>
<p>第二次获取读锁是否必要：</p>
<p>必要的。因为你先释放写锁再获取读锁的话，中间可能有其他线程获取写锁，导致你无法获取到读锁，无法感知数据的更新。</p>
<p>不支持锁升级原因：读锁可以被多个线程获取，其中任意线程获取到写锁更新数据后，都会导致其他获取读锁的线程无法感知数据的更新。</p>
<h2 id="十-线程通信"><a href="#十-线程通信" class="headerlink" title="十.线程通信"></a>十.线程通信</h2><h3 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait notify"></a>wait notify</h3><p>传统可使用下面代码等待，但是资源消耗太大：</p>
<pre><code class="java">protected MySignal sharedSignal = ...

while(!sharedSignal.hasDataToProcess()){
  //do nothing... busy waiting
}</code></pre>
<p><code>wait</code>：会释放线程资源，停止运行状态（释放锁）</p>
<p><code>notify</code>：通知某一个处于等待状态的线程（随机）</p>
<pre><code class="java">/**
 * 模拟10个厕所坑位，20个人上，出来一个可以进去一个
 */
public class Toilet {
    private volatile int toilet = 10;
    public void getOneToilet() throws InterruptedException {
        synchronized (this) {
            if (toilet &gt; 0) {
                toilet = toilet - 1;
                System.out.println(Thread.currentThread().getName() + &quot;:get one toilet.&quot;);
            } else {
                wait();
                getOneToilet();
            }
        }
    }
    public void releaseToilet(){
        synchronized (this) {
            toilet = toilet + 1;
            System.out.println(Thread.currentThread().getName()+&quot;:release one toilet&quot;);
            notify();
        }
    }
    public static void main(String[] args) {
        Toilet toilet = new Toilet();
        for(int i=0;i&lt;20;i++){
            new Thread(()-&gt;{
                try {
                    toilet.getOneToilet();
                    Thread.sleep(new Random().nextInt(7000));
                    toilet.releaseToilet();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}</code></pre>
<h3 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h3><p>面包店生产面包，放在商店里，消费者来店里购买面包；没有面包时，店家告诉你生产出来告诉你，告诉厂家生产面包，到货了，你再过来购买。</p>
<h3 id="Condition——线程通信更高效的方式"><a href="#Condition——线程通信更高效的方式" class="headerlink" title="Condition——线程通信更高效的方式"></a>Condition——线程通信更高效的方式</h3><p><code>AQS内部类ConditionObject</code>实现<code>Condition</code>接口</p>
<p>监视器方法包括wait()/notify()/notifyAll(),需要配合synchronized使用.而Condition是配合lock使用的。</p>
<p>主要方法：</p>
<pre><code class="java">void await();
void signal();</code></pre>
<blockquote>
<p>用<code>await()</code>替换<code>wait()</code>，用<code>signal()</code>替换<code>notify()</code>，用<code>signalAll()</code>替换<code>notifyAll()</code>，传统线程的通信方式，Condition都可以实现，这里注意，Condition是被绑定到Lock上的，要创建一个Lock的Condition必须用newCondition()方法。</p>
</blockquote>
<p>使用：</p>
<pre><code class="java">private Lock lock = new ReentrantLock();
private Condition addCondition = lock.newCondition();
private Condition pollCondition = lock.newCondition();</code></pre>
<h4 id="Condition实现的有界队列"><a href="#Condition实现的有界队列" class="headerlink" title="Condition实现的有界队列"></a>Condition实现的有界队列</h4><pre><code class="java">public class BoundQueue {
    private Lock lock = new ReentrantLock();
    private Condition addCondition = lock.newCondition();
    private Condition pollCondition = lock.newCondition();
    private Object[] boundQueue = new Object[20];
    private int count;//队列元素数量
    private int addIndex;//入队索引
    private int pollIndex;//出队索引
    public void add(Object x){
        lock.lock();
        try {
            while (count &gt;= boundQueue.length) {
                addCondition.await();//等待
            }
            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+x+&quot;入队列，当前有：&quot;+ ++count+&quot;个元素&quot;);
            boundQueue[addIndex] = x;//入队
            if(++addIndex==boundQueue.length){
                addIndex = 0;//入队到尽头时，从队列开始入队
            }
            pollCondition.signal();//唤醒
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
    public void poll(){
        lock.lock();
        try {
            while (count &lt;= 0) {
                pollCondition.await();
            }
            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+boundQueue[pollIndex]+&quot;出队列，当前有：&quot;+ --count+&quot;个元素&quot;);
            boundQueue[pollIndex] = null;//出队
            if(++pollIndex==boundQueue.length){
                pollIndex = 0;//如果出队的索引到队列尽头，从头开始出队
            }
            addCondition.signal();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }</code></pre>
<h4 id="Condition源码分析"><a href="#Condition源码分析" class="headerlink" title="Condition源码分析"></a>Condition源码分析</h4><p>Condition接口实现类就是AQS同步器的<code>ConditionObject</code>类，每一个ConditionObject维护一个等待队列（单向队列）</p>
<p>该类维护着一个与AQS中<code>ReentrantLock</code>的同步队列类似，叫等待队列，所有调用condition.await方法的线程会加入到等待队列中，并且线程状态转换为等待状态。</p>
<ul>
<li>等待队列：存储者待唤醒的线程的引用</li>
<li>同步队列：存储同步竞争资源的线程的引用</li>
</ul>
<h5 id="await"><a href="#await" class="headerlink" title="await"></a>await</h5><p>把线程加入等待队列</p>
<pre><code class="java">public final void await() throws InterruptedException {
            if (Thread.interrupted())
                throw new InterruptedException();
    //主要 把当前线程引用用Node保存，添加到等待队列
            Node node = addConditionWaiter();
            int savedState = fullyRelease(node);
            int interruptMode = 0;
    //while循环把该线程的节点添加到同步队列 阻塞
            while (!isOnSyncQueue(node)) {
                LockSupport.park(this);
                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                    break;
            }
            if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
                interruptMode = REINTERRUPT;
            if (node.nextWaiter != null) // clean up if cancelled
                //清空等待队列中处于CANCEL状态的节点
                unlinkCancelledWaiters();
            if (interruptMode != 0)
                reportInterruptAfterWait(interruptMode);
        }</code></pre>
<h5 id="addConditionWaiter"><a href="#addConditionWaiter" class="headerlink" title="addConditionWaiter"></a>addConditionWaiter</h5><p>把当前线程引用用Node保存，添加到等待队列</p>
<pre><code class="java">private Node addConditionWaiter() {
            Node t = lastWaiter;
            // If lastWaiter is cancelled, clean out.
            if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) {
                unlinkCancelledWaiters();
                t = lastWaiter;
            }
            Node node = new Node(Thread.currentThread(), Node.CONDITION);
    //如果等待队列中最后一个节点为空，则该节点为第一个节点
            if (t == null)
                firstWaiter = node;
            else
                //否则为最后一个节点的后一个节点
                t.nextWaiter = node;
    //把最后一个节点指向该节点
            lastWaiter = node;
            return node;
        }</code></pre>
<h5 id="unlinkCancelledWaiters"><a href="#unlinkCancelledWaiters" class="headerlink" title="unlinkCancelledWaiters"></a>unlinkCancelledWaiters</h5><p>清空等待队列中CANCEL状态的节点</p>
<pre><code class="java">private void unlinkCancelledWaiters() {
            Node t = firstWaiter;
            Node trail = null;
            while (t != null) {
                Node next = t.nextWaiter;
                //如果状态不为CONDITION（Condition等待队列），把它清除
                if (t.waitStatus != Node.CONDITION) {
                    t.nextWaiter = null;
                    if (trail == null)
                        firstWaiter = next;
                    else
                        trail.nextWaiter = next;
                    if (next == null)
                        lastWaiter = trail;
                }
                else
                    trail = t;
                t = next;
            }
        }</code></pre>
<h5 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h5><p>唤醒等待队列中第一个队列到同步队列</p>
<pre><code class="java">public final void signal() {
    //如果不是独占模式抛出异常
            if (!isHeldExclusively())
                throw new IllegalMonitorStateException();
    //唤醒第一个节点对应线程
            Node first = firstWaiter;
            if (first != null)
                doSignal(first);
        }
</code></pre>
<h5 id="doSignal"><a href="#doSignal" class="headerlink" title="doSignal"></a>doSignal</h5><pre><code class="java">private void doSignal(Node first) {
    //唤醒第一个节点，失败唤醒下一个，成功后停止循环
            do {
                if ( (firstWaiter = first.nextWaiter) == null)
                    lastWaiter = null;
                first.nextWaiter = null;
            } while (!transferForSignal(first) &amp;&amp;
                     (first = firstWaiter) != null);
        }</code></pre>
<h5 id="transferForSignal"><a href="#transferForSignal" class="headerlink" title="transferForSignal"></a>transferForSignal</h5><p>把线程改变成唤醒状态</p>
<pre><code class="java">final boolean transferForSignal(Node node) {
        /*
         * If cannot change waitStatus, the node has been cancelled.
         */
        if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
            return false;
//把当前节点添加到同步队列中 竞争资源
        Node p = enq(node);
        int ws = p.waitStatus;
    //如果该线程状态为CANCEL或者设置状态为SIGNAL（唤醒状态）失败的话，使用UNSAFE的unpark方法唤醒该线程，但是这样的话节点状态可能短暂是错误的，但是影响并不大（在同步队列中会使用CAS设定状态）
        if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
            LockSupport.unpark(node.thread);
        return true;
    }</code></pre>
<h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><h4 id="使用Condition-ReentrantLock实现"><a href="#使用Condition-ReentrantLock实现" class="headerlink" title="使用Condition+ReentrantLock实现"></a>使用Condition+ReentrantLock实现</h4><pre><code class="java">public class MyDataSource {
    private List&lt;Connection&gt; pool = new LinkedList&lt;&gt;();
    private static final int INIT_CONNECTION = 10;
    private static String URL = &quot;jdbc:mysql://localhost:3306/springboot&quot;;
    private static String USER = &quot;xxxx&quot;;
    private static String PASSWORD = &quot;xxxx&quot;;
    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();
    static {
        try {
            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
    public MyDataSource(){
        for(int i=0;i&lt;INIT_CONNECTION;i++) {
            try {
                pool.add(DriverManager.getConnection(URL,USER,PASSWORD));
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
    public Connection getConnection(){
        lock.lock();
        try {
            while (pool.isEmpty()){
                condition.await();
            }
            System.out.println(Thread.currentThread().getName()+&quot;:获取到连接，目前连接池还有&quot;+ (pool.size() - 1) +&quot;个连接&quot;);
            return pool.remove(0);
        }catch (Exception e){
            e.printStackTrace();
            return null;
        }finally {
            lock.unlock();
        }
    }
    public void release(Connection con) throws SQLException {
        lock.lock();
        try {
            if (con != null) {
                System.out.println(Thread.currentThread().getName()+&quot;:释放连接，目前连接池还有&quot;+(pool.size() + 1)+&quot;个连接&quot;);
                pool.add(con);
                condition.signal();
            }
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
    public static void main(String[] args) {
        MyDataSource dataSource = new MyDataSource();
        for(int i=0;i&lt;5;i++){
            new Thread(()-&gt;{
                try {
                    Connection con = dataSource.getConnection();
                    Thread.sleep(5000);
                    dataSource.release(con);
                }catch (Exception e){
                    e.printStackTrace();
                }
            }).start();
        }
    }
}</code></pre>
<h3 id="线程-Join"><a href="#线程-Join" class="headerlink" title="线程 Join"></a>线程 Join</h3><p>让“主线程”等待“子线程”结束之后才能继续运行。</p>
<p>原理：</p>
<pre><code class="java">while(join线程存活){
    主线程wait
}</code></pre>
<p>concurrent.join包下</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>ThreadLocal是一个关于创建线程局部变量的类。</p>
<p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。而使用ThreadLocal创建的变量只能被当前线程访问，其他线程则无法访问和修改。</p>
<p>各个线程使用<code>set</code>、<code>get</code>和<code>remove</code>对局部变量进行操作，实现了数据的隔离</p>
<blockquote>
<p>总而言之，往ThreadLocal中存的变量属于当前线程的，其他线程无法获取</p>
</blockquote>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><ul>
<li>支持泛型</li>
</ul>
<pre><code class="java">ThreadLocal&lt;String&gt; mStringThreadLocal = new ThreadLocal&lt;&gt;();

mStringThreadLocal.set(&quot;dzou.top&quot;);

mStringThreadLocal.get();</code></pre>
<ul>
<li>为ThreadLocal设置初始值：重写<code>initialValue</code>方法</li>
</ul>
<pre><code class="java">ThreadLocal&lt;Integer&gt; mThreadLocal = new ThreadLocal&lt;String&gt;() {
    @Override
    protected Integer initialValue() {
      return 1;
    }
};</code></pre>
<ul>
<li>存储在栈内存中</li>
</ul>
<p>每个线程都有一个栈内存，属于线程的私有空间。而堆内存对所有线程可见。</p>
<h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h4><ul>
<li>看一下<code>get</code>方法</li>
</ul>
<pre><code class="java">public T get() {
    //获取当前线程对象
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            //通过当前线程对象获取值
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                T result = (T)e.value;
                return result;
            }
        }
        return setInitialValue();
    }</code></pre>
<p>这里使用了<code>ThreadLocalMap</code>这个Map存储，内部使用了<code>Entry</code>这个类存储</p>
<blockquote>
<p>Entry：Entry&lt;K,V&gt;它表示Map中的一个实体（一个key-value对）</p>
</blockquote>
<p>其中Map的key值就是<code>当前线程对象</code>，value就是存储的值，所以保证了只有当前线程才能获取到值</p>
<ul>
<li>看一下<code>set</code>方法</li>
</ul>
<pre><code class="java">public void set(T value) {
    //获取线程对象
        Thread t = Thread.currentThread();
    //根据线程对象获取Map
        ThreadLocalMap map = getMap(t);
        if (map != null)
            //Map不为空设置value
            map.set(this, value);
        else
            //为空创建Map并设置value
            createMap(t, value);
    }</code></pre>
<ul>
<li><code>remove</code>方法</li>
</ul>
<pre><code class="java">public void remove() {
         ThreadLocalMap m = getMap(Thread.currentThread());
         if (m != null)
             //不为空，根据当前线程对象作为Key删除该Entry
             m.remove(this);
     }</code></pre>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>ThreadLocal中维护着一个ThreadLocalMap对象</li>
<li>ThreadLocalMap时ThreadLocal的内部类，内部使用Entry进行存储</li>
<li>调用key时，是根据线程对象获取value</li>
</ol>
<h4 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h4><p>因为<code>ThreadLocal</code>中局部变量是根据当前线程创建的，所以<code>ThreadLocal</code>和线程有相同的存活时间，当线程没有结束，导致对应Map中<code>Entry</code>依然存在，所以为了防止内存泄漏要自己收到在不需要时把Entry给<code>remove</code>掉</p>
<h4 id="ThreadLocal应用"><a href="#ThreadLocal应用" class="headerlink" title="ThreadLocal应用"></a>ThreadLocal应用</h4><ul>
<li>实现单个线程单例以及单个线程上下文信息存储，比如交易id等</li>
<li>实现线程安全，非线程安全的对象使用ThreadLocal之后就会变得线程安全，因为每个线程都会有一个对应的实例</li>
<li>承载一些线程相关的数据，避免在方法中来回传递参数</li>
</ul>
<h4 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h4><p>继承自ThreadLocal</p>
<p>ThreadLocal设计之初就是为了绑定当前线程，如果希望当前线程的ThreadLocal能够被子线程使用，实现方式就会相当困难，解决此问题</p>
<pre><code class="java">protected T childValue(T parentValue) {
    //获取父线程值
        return parentValue;
    }</code></pre>
<p><code>InheritableThreadLocal</code>主要用于<code>子线程创建</code>时，需要自动继承父线程的ThreadLocal变量，方便必要信息的进一步传递。</p>
<ul>
<li>shiro：Shiro中使用ThreadLocal存储用户主体Subject对象，通过<code>getSubject</code>获取，<code>InheritableThreadLocal</code> 可以让用户自行 new Thread 出来的线程可以获取到 Subject，否则用户还要额外想办法怎么获取到这个 Subject</li>
</ul>
<h2 id="十一-并发工具类"><a href="#十一-并发工具类" class="headerlink" title="十一.并发工具类"></a>十一.并发工具类</h2><h3 id="CountDownLatch——共享锁"><a href="#CountDownLatch——共享锁" class="headerlink" title="CountDownLatch——共享锁"></a>CountDownLatch——共享锁</h3><p><strong><em>该类提供一种等待一个或者多个并发任务完成的机制。内部有一个计数器，主线程要继续执行需要完成指定数量的并发任务。</em></strong></p>
<p>业务场景：有一个业务分成多个部分，需要完成指定的部分后才能完成剩下的指定部分。</p>
<p>实现：可以用<code>Join</code>、<code>wait/notify</code>、<code>Condition</code>实现</p>
<p>但是Java中AQS同步器又为我们实现了该工具类（AQS真的是并发之宝），类似倒计时的工具类</p>
<p>使用：</p>
<pre><code class="java">CountDownLatch latch = new CountDownLatch(5);//初始化指定需要完成5个并发任务
latch.await();//完成5个之前等待，等待完成5个唤醒
latch.countDown();//计数任务-1</code></pre>
<ul>
<li><code>await()</code>：调用该方法的线程等待count值减到0时才能被唤醒继续执行，否则等待</li>
<li><code>countDown()</code>：使计数任务值-1</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>全班20名同学完成作业后才可以放学</p>
<pre><code class="java">private static final int STUDENTS_NUMBER = 20;
    private static CountDownLatch finishHW = new CountDownLatch(STUDENTS_NUMBER);
    public static void main(String[] args) throws InterruptedException {
        ExecutorService executorService = Executors.newCachedThreadPool();
        for(int i=0;i&lt;STUDENTS_NUMBER;i++){
            executorService.execute(()-&gt;{
                System.out.println(Thread.currentThread().getName()+&quot;:完成了作业&quot;);
                sleep(500);
                finishHW.countDown();
            });
        }
        finishHW.await();
        sleep(1000);
        System.out.println(&quot;全部人完成了任务，可以放学了&quot;);
    }
    private static void sleep(int milliSecond){
        try {
            TimeUnit.MILLISECONDS.sleep(milliSecond);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }</code></pre>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>CountDownLatch也是基于AQS实现的，使用一个int型(原子)volatile(可见)变量维护状态</p>
<ul>
<li>await</li>
</ul>
<p>调用<code>sync.acquireSharedInterruptibly(1);</code></p>
<pre><code class="java">public final void acquireSharedInterruptibly(int arg)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
        if (tryAcquireShared(arg) &lt; 0)
            doAcquireSharedInterruptibly(arg);
    }</code></pre>
<pre><code class="java">protected int tryAcquireShared(int acquires) {
    //如果状态不为0也就是count！=0，则执行等待doAcquireSharedInterruptibly
            return (getState() == 0) ? 1 : -1;
        }</code></pre>
<pre><code class="java">private void doAcquireSharedInterruptibly(int arg)
        throws InterruptedException {
    //以共享模式将节点添加到队列中
        final Node node = addWaiter(Node.SHARED);
        boolean failed = true;
        try {
            //循环执行，等待其他线程执行到足够的任务数，count=0时，唤醒该等待线程
            for (;;) {
                //获取前一个节点
                final Node p = node.predecessor();
                if (p == head) {
                    //r&gt;=0代表等待完成，count=0
                    int r = tryAcquireShared(arg);
                    if (r &gt;= 0) {
                        //设置当前节点为头结点并唤醒等待的线程
                        setHeadAndPropagate(node, r);
                        p.next = null; // help GC
                        failed = false;
                        return;
                    }
                }
                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                    parkAndCheckInterrupt())
                    throw new InterruptedException();
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
</code></pre>
<ul>
<li><p>countDown</p>
<p>调用<code>sync.releaseShared(1);</code></p>
</li>
</ul>
<pre><code class="java">public final boolean releaseShared(int arg) {
        if (tryReleaseShared(arg)) {
            doReleaseShared();
            return true;
        }
        return false;
    }</code></pre>
<pre><code class="java">protected boolean tryReleaseShared(int releases) {
    //循环设置状态count=count-1，任务数减一，成功返回count是否为0，即是否还有任务
            for (;;) {
                int c = getState();
                if (c == 0)
                    return false;//没有任务了直接返回false，无需线程需要唤醒
                int nextc = c-1;
                if (compareAndSetState(c, nextc))//CAS设置状态
                    return nextc == 0;
            }
        }</code></pre>
<p>doReleaseShared()方法主要作用是唤醒调用了await()方法的线程</p>
<pre><code class="java">private void doReleaseShared() {
    //循环唤醒所有await的线程，共享模式而非独占模式
        for (;;) {
            Node h = head;
            //头节点不为空并且节点数&gt;1
            if (h != null &amp;&amp; h != tail) {
                int ws = h.waitStatus;
                if (ws == Node.SIGNAL) {// SIGNAL状态表示当前节点正在等待被唤醒
                    //清除等待状态
                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                        continue;            // loop to recheck cases
                    //唤醒线程
                    unparkSuccessor(h);
                }
                else if (ws == 0 &amp;&amp;
                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                    continue;                // loop on failed CAS
            }
            if (h == head)                   // loop if head changed
                break;
        }
    }</code></pre>
<p>总结：</p>
<p><code>CountDownLatch</code>是一个共享锁，锁住了共享资源，调用<code>CountDownLatch</code>释放一个资源，当所有资源被释放时，唤醒所有等待的线程。</p>
<h3 id="CyclicBarrier——屏障"><a href="#CyclicBarrier——屏障" class="headerlink" title="CyclicBarrier——屏障"></a>CyclicBarrier——屏障</h3><p><code>barrier</code>是屏障，它的作用就是在让多个线程在完成了屏障前的工作后，在屏障那等待，知道其他线程也完成了屏障前的工作才可以一起执行屏障后的工作。</p>
<p><code>cyclic</code>代表循环，可以复用</p>
<p>构造方法：</p>
<ul>
<li><p><code>public CyclicBarrier(int parties, Runnable barrierAction)</code></p>
<p>创建一个新的CyclicBarrier，给定数量的参与者，给定屏障线程，当等待线程达到参与者数量时，屏障线程工作，等待线程继续执行。</p>
</li>
<li><p><code>public CyclicBarrier(int parties)</code></p>
<p>创建一个新的CyclicBarrier，给定数量的参与者，当等待线程达到参与者数量时，等待线程继续执行。</p>
</li>
</ul>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>一个长跑比赛需要运动员进场到<code>起跑线</code>准备好裁判才会吹响比赛，多个线程来到起跑线就进行等待，直到所有的参赛选手都到起跑线准备好比赛才可以开始。</p>
<pre><code class="java">public class CyclicBarrierTask implements Runnable{
    private CyclicBarrier cyclicBarrier;
    private static final int COMPETITOR_NUMBER = 10;
    public CyclicBarrierTask(Thread barrierThread){
        cyclicBarrier = new CyclicBarrier(COMPETITOR_NUMBER, barrierThread);
    }
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+&quot;:走入赛场&quot;);
        try {
            Thread.sleep(2000);
            System.out.println(Thread.currentThread().getName()+&quot;:准备好开始比赛&quot;);
            cyclicBarrier.await();
            System.out.println(Thread.currentThread().getName()+&quot;:出发&quot;);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static void main(String[] args) throws InterruptedException {
        CyclicBarrierTask cyclicBarrierTask = new CyclicBarrierTask(new Thread(()-&gt;{
            System.out.println(&quot;裁判吹响口哨，开始比赛！！！&quot;);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }));
        for(int i=0;i&lt;COMPETITOR_NUMBER;i++){
            new Thread(cyclicBarrierTask).start();
        }
        Thread.sleep(10000);
        System.out.println(&quot;比赛结束，运动员回家，裁判回家。&quot;);
    }
}</code></pre>
<ul>
<li><p><code>reset</code>方法</p>
<p>当有线程来到屏障前等待，调用reset方法会抛出<code>BrokenBarrierException</code>异常</p>
</li>
<li><p><code>isBroken</code>方法</p>
<p>线程是否被中断</p>
</li>
<li><p><code>getNumberWaiting</code>方法</p>
<p>获取正在等待线程数量</p>
</li>
</ul>
<h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><p><code>CyclicBarrier</code>内部没有使用AQS实现，而是使用<code>ReentrantLock</code>和<code>Condition</code>实现</p>
<p>内部维护了一个计数器，用<code>count</code>值存储，每次-1</p>
<p>构造方法：</p>
<pre><code class="java">public CyclicBarrier(int parties, Runnable barrierAction) {
        if (parties &lt;= 0) throw new IllegalArgumentException();
        this.parties = parties;
        this.count = parties;
        this.barrierCommand = barrierAction;
    }</code></pre>
<p>构造方法中使用了一个<code>count</code>变量和一个<code>parties</code>变量，不只是用parties的为了复用，在一次count=0后，创建新的<code>Generation</code>，把count的值赋值为parties的值达到复用。</p>
<p>内部维护了一个<code>Generation</code>的类，用来维护<code>CyclicBarrier</code>的循环使用(复用)，每完成一次计数，通过<code>nextGeneration</code>方法，唤醒线程并创建一个新的Generation赋值给该屏障的<code>generation</code>变量(换代)</p>
<ul>
<li>里面只有一个变量<code>broken</code>：存储该屏障是否被破坏，被破坏则不能再使用</li>
</ul>
<pre><code class="java">private static class Generation {
        boolean broken = false;
    }</code></pre>
<ul>
<li>nextGeneration</li>
</ul>
<pre><code class="java">private void nextGeneration() {
        // 使用Condition唤醒所有等待线程
        trip.signalAll();
        // 换代并更新count值达到复用
        count = parties;
        generation = new Generation();
    }</code></pre>
<ul>
<li>最主要的await方法调用了下面的<code>dowait</code>方法<ol>
<li>count-1，为0则更新并唤醒</li>
<li>不为0，await，等待被唤醒并更新</li>
</ol>
</li>
</ul>
<pre><code class="java">private int dowait(boolean timed, long nanos)
        throws InterruptedException, BrokenBarrierException,
               TimeoutException {
        final ReentrantLock lock = this.lock;
        //count是共享变量，需要使用Lock
        lock.lock();
        try {
            final Generation g = generation;//当前Generation赋值给g
            if (g.broken)//如果当前代屏障已经被破坏则抛出异常，无法再使用
                throw new BrokenBarrierException();
            if (Thread.interrupted()) {//如果线程被中断，就破坏屏障，broken=true,并抛出异常
                breakBarrier();
                throw new InterruptedException();
            }
            //count递减，等待线程增加1个
            int index = --count;
            if (index == 0) {  // 如果等待线程数达到头，需要唤醒线程并执行屏障线程并换代
                boolean ranAction = false;
                try {
                    final Runnable command = barrierCommand;
                    if (command != null)
                        command.run();//执行屏障线程
                    ranAction = true;
                    nextGeneration();//换代操作
                    return 0;//返回0为结束了
                } finally {
                    if (!ranAction)//如果屏障线程执行出错,破坏该屏障，无法再次使用
                        breakBarrier();
                }
            }

            // 无限循环等待换代成功(全部线程通过屏障),或者抛出异常
            for (;;) {
                try {
                    if (!timed)//如果没有超时要求,直接调用Condition的await
                        trip.await();
                    else if (nanos &gt; 0L)//否则等待相应超时时间
                        nanos = trip.awaitNanos(nanos);
                } catch (InterruptedException ie) {//发生小概率事件(被中断)
                    if (g == generation &amp;&amp; ! g.broken) {//破坏该屏障
                        breakBarrier();
                        throw ie;
                    } else {
                        Thread.currentThread().interrupt();
                    }
                }
                if (g.broken)//如果屏障被破坏了，抛出异常
                    throw new BrokenBarrierException();
                if (g != generation)//如果正常情况下等待后会换代成功，返回该线程所在屏障的下标
                    return index;
                if (timed &amp;&amp; nanos &lt;= 0L) {//超时，抛出异常并破坏屏障
                    breakBarrier();
                    throw new TimeoutException();
                }
            }
        } finally {
            lock.unlock();
        }
    }</code></pre>
<p><strong><em>因为处于Lock中，唤醒操作是将线程从<code>condtion队列</code>(等待/条件队列)中全部放入AQS的同步队列中</em></strong></p>
<h4 id="CyclicBarrier和CountDownLatch"><a href="#CyclicBarrier和CountDownLatch" class="headerlink" title="CyclicBarrier和CountDownLatch"></a>CyclicBarrier和CountDownLatch</h4><ul>
<li>复用性：CyclicBarrier支持(更强大)，CountDownLatch不支持</li>
<li>内部实现：CyclicBarrier使用Lock+Condition，CountDownLatch使用AQS的共享模式</li>
<li>内部都使用一个计数器</li>
</ul>
<p>CountDownLatch需要使用<code>CountDownLatch</code>触发计数器事件，<code>CyclicBarrier</code>自动在await处计数。</p>
<p>场景分析：</p>
<ul>
<li>CountDownLatch更注重在需要等待多个任务完成后执行</li>
<li>CyclicBarrier更注重等待大家汇聚在每个屏障处再执行后面的任务</li>
</ul>
<h3 id="Semaphore——信号量"><a href="#Semaphore——信号量" class="headerlink" title="Semaphore——信号量"></a>Semaphore——信号量</h3><p><strong><em>信号量机制用于控制对一个或多个资源的访问。</em></strong></p>
<ul>
<li><p><code>acquire()</code></p>
<p>调用该方法时，如果内部资源数&gt;0，则资源数<code>减一</code>并获取对该资源的访问；如果资源数=0，则线程会被祖塞，获取不到资源，直到某个线程调用<code>release</code>方法，才有可能被唤醒竞争资源。</p>
</li>
<li><p><code>release()</code></p>
<p>调用该方法时，说明该线程访问的资源已经获取并使用完毕，需要归还给控制中心让其他线程竞争，资源数执行<code>加一</code>操作，会唤醒一个处于等待的线程，这个线程获取到该资源并结束它的<code>acquire</code>方法，其他线程将会一直等待，直到又有资源释放。</p>
</li>
</ul>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul>
<li><p>只传入一个资源访问控制数</p>
<p>用于控制同时几个线程可以访问该资源，默认为非公平模式</p>
</li>
</ul>
<pre><code class="java">public Semaphore(int permits) {
        sync = new NonfairSync(permits);
    }</code></pre>
<ul>
<li>传入访问控制数和一个boolean型变量(用于设置公平或者非公平模式)</li>
</ul>
<pre><code class="java">public Semaphore(int permits, boolean fair) {
        sync = fair ? new FairSync(permits) : new NonfairSync(permits);
    }</code></pre>
<h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p>上厕所的资源控制，5个坑，15个人上</p>
<pre><code class="java">public class Toilet implements Runnable{
    private Semaphore semaphore;
    private static final int TOILET_SIZE = 5;
    public Toilet(Semaphore semaphore){
        this.semaphore = semaphore;
    }
    @Override
    public void run() {
        try {
            System.out.println(Thread.currentThread().getName()+&quot;:我来上厕所了&quot;);
            Thread.sleep(1000);
            if (semaphore.availablePermits()&lt;=0){
                System.out.println(Thread.currentThread().getName()+&quot;:怎么没位置了&quot;);
            }
            semaphore.acquire();
            System.out.println(Thread.currentThread().getName()+&quot;:我抢到厕所了。&quot;);
            Thread.sleep(3000);
            System.out.println(Thread.currentThread().getName()+&quot;:我上完了，你们可以进去一个了。&quot;);
            semaphore.release();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(TOILET_SIZE);
        for(int i=0;i&lt;15;i++){
            new Thread(new Toilet(semaphore)).start();
        }
    }
}</code></pre>
<h4 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h4><p>内部是由AQS的同步器(公平和非公平)实现的，获取使用的是共享模式(Share)</p>
<p><code>Semaphore</code>中使用一个<code>permits</code>变量存储能访问资源数，为1时，就是一个互斥锁，也由AQS的<code>state</code>来维护</p>
<ul>
<li><p>acquire方法调用 acquireSharedInterruptibly(1)</p>
<pre><code class="java">public final void acquireSharedInterruptibly(int arg)
            throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
    //尝试获取一个访问资源
        if (tryAcquireShared(arg) &lt; 0)
            //&lt;0代表没有资源，获取失败，则执行等待并重新获取
            doAcquireSharedInterruptibly(arg);
}</code></pre>
</li>
</ul>
<h5 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h5><ul>
<li><p>doAcquireSharedInterruptibly</p>
<p>AQS中的方法，循环获取该资源访问</p>
</li>
</ul>
<pre><code class="java">private void doAcquireSharedInterruptibly(int arg)
        throws InterruptedException {
        final Node node = addWaiter(Node.SHARED);//添加节点到同步队列(共享模式)
        boolean failed = true;
        try {
            for (;;) {//循环获取
                final Node p = node.predecessor();//获取前一个节点
                if (p == head) {
                    int r = tryAcquireShared(arg);//尝试再次获取资源
                    if (r &gt;= 0) {//获取资源成功
                        setHeadAndPropagate(node, r);//设置为头结点并设置状态
                        p.next = null; // help GC
                        failed = false;
                        return;
                    }
                }
                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;
                    parkAndCheckInterrupt())
                    throw new InterruptedException();
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }</code></pre>
<ul>
<li>非公平tryAcquireShared</li>
</ul>
<pre><code class="java">final int nonfairTryAcquireShared(int acquires) {
            for (;;) {//循环知道获取失败或者成功
                int available = getState();//获取AQS存储的state，即可获取的资源数
                int remaining = available - acquires;//-1
                if (remaining &lt; 0 ||//&lt;0则没有可获取的
                    compareAndSetState(available, remaining))//获取成功并设置状态
                    return remaining;
            }
        }</code></pre>
<ul>
<li><p>公平tryAcquireShared</p>
<p>与非公平唯一区别就是 hasQueuedPredecessors 方法</p>
<p>判断”当前线程”是不是在CLH队列的队首，来实现公平性。</p>
</li>
</ul>
<pre><code class="java">protected int tryAcquireShared(int acquires) {
            for (;;) {
                if (hasQueuedPredecessors())
                    return -1;
                int available = getState();
                int remaining = available - acquires;
                if (remaining &lt; 0 ||
                    compareAndSetState(available, remaining))
                    return remaining;
            }
        }</code></pre>
<h5 id="release"><a href="#release" class="headerlink" title="release"></a>release</h5><p> 与CountDownLatch 的<code>countDown</code>一样的实现</p>
<img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/concurrent/1.png">



<h3 id="Exchanger——交换者"><a href="#Exchanger——交换者" class="headerlink" title="Exchanger——交换者"></a>Exchanger——交换者</h3><p>用于两个线程间的数据交换，如果有第三个线程，对不起，我做不到。</p>
<p><code>Exchanger</code>提供一个同步点，在这个同步点处，两个线程进行数据交换。</p>
<p>主要方法</p>
<ul>
<li><p><code>exchange(V v)</code> 返回值V</p>
<p>线程会在这检查是否有线程等待交换，没有就继续等待，有就进行数据交换。</p>
</li>
</ul>
<h4 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h4><p>还可以用于遗传算法，遗传需要两个对象，分别提供相应的基因，在进行交换根据一定规则进行遗传。</p>
<p>例子：用于效验结果比对，模拟两个线程分别计算</p>
<pre><code class="java">public class TaskA implements Runnable{
    private Exchanger&lt;Integer&gt; exchanger;
    public TaskA(Exchanger&lt;Integer&gt; exchanger){
        this.exchanger = exchanger;
    }
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+&quot;:正在进行计算&quot;);
        try {
            Thread.sleep(2000);
            Integer x = 1026;
            System.out.println(Thread.currentThread().getName()+&quot;:计算结束，等待效验&quot;);
            exchanger.exchange(x);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public class TaskB implements Runnable{
    private Exchanger&lt;Integer&gt; exchanger;
    public TaskB(Exchanger&lt;Integer&gt; exchanger){
        this.exchanger = exchanger;
    }
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+&quot;:正在进行计算&quot;);
        try {
            Thread.sleep(2000);
            Integer res = 1026;
            System.out.println(Thread.currentThread().getName()+&quot;:计算结束，等待效验&quot;);
            Integer x = exchanger.exchange(res);
            Thread.sleep(1000);
            System.out.println(&quot;效验结果是：&quot;+x.equals(res));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}


public class ExchangerTask {
    public static void main(String[] args) {
        Exchanger&lt;Integer&gt; exchanger = new Exchanger&lt;&gt;();
        new Thread(new TaskA(exchanger)).start();
        new Thread(new TaskB(exchanger)).start();
    }
}</code></pre>
<h4 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h4><p>内部使用了<code>Node</code>存储每个线程的信息，包括数据，把它放在<code>Participant</code>中，这是一个继承自<code>ThreadLocal</code>并重写了其初始化方法的类，用于把Node保存到Participant中。实现类似SynchronousQueue，后面再继续学习。</p>
<h2 id="十二-Future"><a href="#十二-Future" class="headerlink" title="十二.Future"></a>十二.Future</h2><p><strong><em>异步：提供一种高效的线程执行方式，你可以在执行一个耗时长的任务时去做其他的事，而无需停在那等待。</em></strong></p>
<h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3><p>我们在看<code>Future</code>前先看一下<code>Callable</code>，我们都知道<code>Runnable</code>的线程是一种没有返回值的线程。</p>
<p>当我们线程需要返回某个结果时，我们就需要使用<code>Callable&lt;V&gt;</code>，它是一种有返回值的线程。</p>
<p>与Runnable函数式接口对应的，Callable的方法是：</p>
<pre><code class="java">V call() throws Exception;</code></pre>
<blockquote>
<p>用<code>泛型</code>支持返回值</p>
</blockquote>
<ol>
<li>线程返回值通过什么获取？</li>
</ol>
<p>答：<code>Future</code></p>
<ol start="2">
<li>Callable和Runnable区别</li>
</ol>
<p>答：Callable允许抛出异常(在被取消时抛出)；Callable的call方法由FutureTask中<code>run</code>方法调用</p>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>使用<code>Callable</code>的线程会把返回值存在一个<code>Future</code>中，Future就支持泛型了</p>
<p>主要方法如下：</p>
<pre><code class="java">    boolean cancel(boolean mayInterruptIfRunning);//取消线程执行
    boolean isCancelled();//判断是否取消
    boolean isDone();//判断是否完成任务
    V get() throws InterruptedException, ExecutionException;//获取线程返回值</code></pre>
<ul>
<li>我们将通过<code>Future.get</code>获取返回值，如果未完成任务，会在get方法处<code>阻塞</code>，等待任务结束获取到返回值。</li>
</ul>
<h3 id="Future和Callable使用"><a href="#Future和Callable使用" class="headerlink" title="Future和Callable使用"></a>Future和Callable使用</h3><p>Runnable：我们一般可以使用<code>ExecutorService</code>接口中的<code>execute</code>方法执行没有返回值的线程</p>
<p>Callable：现在有了有返回值的线程，我们可以使用<code>ExecutorService</code>中的<code>submit</code>方法提交线程任务并获取一个<code>Future</code>对象，通过该对象<code>get</code>方法获取返回值</p>
<pre><code class="java">public class TestFuture {
//Callable任务
    public static class FutureTaskTest implements Callable&lt;Long&gt; {
        @Override
        public Long call() throws Exception {
            long start = System.currentTimeMillis();
            Thread.sleep(new Random().nextInt(3000));
            long end = System.currentTimeMillis();
            //返回值就是执行时间
            return end-start;
        }
    }
    public static void main(String[] args) {
        ExecutorService es = Executors.newFixedThreadPool(10);
        List&lt;Future&lt;Long&gt;&gt; result = new ArrayList&lt;&gt;();
        //执行10个线程任务，通过submit把Future对象存在ArrayList中
        for (int i=0;i&lt;10;i++) {
            result.add(es.submit(new FutureTaskTest()));
        }
        //使用lambda输出返回值
        result.forEach((o)-&gt;{
            try {
                System.out.println(o.get());
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        });
        es.shutdown();
    }
}</code></pre>
<ul>
<li>ExecutorService中的submit方法</li>
</ul>
<pre><code class="java">Future&lt;T&gt; submit(Callable&lt;T&gt; task);//获取返回值的Callable线程
Future&lt;T&gt; submit(Runnable task, T result);//传入无返回值的线程和结果的引用，最后返回值存在result中，这是有返回值的submit
Future&lt;?&gt; submit(Runnable task);//无返回值</code></pre>
<p>看一下submit实现：</p>
<p>在<code>AbstractExecutorService</code>类中实现</p>
<pre><code class="java">public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);
        execute(ftask);
        return ftask;
    }

public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) {
        if (task == null) throw new NullPointerException();
        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);
        execute(ftask);//执行了RunnableFuture的run方法，也就是FutureTask的run方法
        return ftask;
    }</code></pre>
<blockquote>
<p>可以看到他把线程任务封装成一个<code>RunnableFuture</code>接口的实现类<code>FutureTask</code>对象执行</p>
</blockquote>
<pre><code class="java">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; {
    void run();
}</code></pre>
<blockquote>
<p>可以看到，RunnableFuture继承自Runnable和Future，它的<code>run</code>方法在<code>FutureTask</code>中实现</p>
</blockquote>
<pre><code class="java">protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) {
        return new FutureTask&lt;T&gt;(callable);
    }

protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) {
        return new FutureTask&lt;T&gt;(runnable, value);
    }</code></pre>
<blockquote>
<p>这个方法返回了一个<code>FutureTask</code>对象，稍后讲到</p>
</blockquote>
<h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>封装了<code>Future</code>线程的执行和<code>Runnable</code>线程的执行，并返回返回值result，使用适配器模式将Runnable线程转换为Callable线程执行</p>
<img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/concurrent/2.png">

<p>构造方法：</p>
<ul>
<li>传入Runnable和result</li>
</ul>
<pre><code class="java">public FutureTask(Runnable runnable, V result) {
        this.callable = Executors.callable(runnable, result);
        this.state = NEW;       // ensure visibility of callable
    }</code></pre>
<blockquote>
<p>调用Executors中的callable方法，将Runnable线程转换为Callable线程作为FutureTask的callable参数</p>
</blockquote>
<ul>
<li>传入Callable</li>
</ul>
<pre><code class="java">public FutureTask(Callable&lt;V&gt; callable) {
        if (callable == null)
            throw new NullPointerException();
        this.callable = callable;
        this.state = NEW;       // ensure visibility of callable
    }</code></pre>
<p>callable方法</p>
<pre><code class="java">public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) {
        if (task == null)
            throw new NullPointerException();
        return new RunnableAdapter&lt;T&gt;(task, result);
    }</code></pre>
<blockquote>
<p>这个方法就是把Runnable线程转换为Callable线程执行，使用适配器模式</p>
</blockquote>
<ul>
<li>RunnableAdapter</li>
</ul>
<pre><code class="java">static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; {
        final Runnable task;
        final T result;
        RunnableAdapter(Runnable task, T result) {
            this.task = task;
            this.result = result;
        }
        public T call() {
            task.run();
            return result;
        }
    }</code></pre>
<blockquote>
<p>这就是一种<code>适配器模式</code>的应用，实现目标接口Callable，在call方法中调用Runnable的run方法，并返回计算结果result</p>
</blockquote>
<p>可以参考我的另一篇博文，Java设计模式——适配器模式</p>
<h3 id="FutureTask和Callable使用"><a href="#FutureTask和Callable使用" class="headerlink" title="FutureTask和Callable使用"></a>FutureTask和Callable使用</h3><ul>
<li>不使用线程池的submit方法，创建一个FutureTask对象接收返回值</li>
</ul>
<pre><code class="java">public class TestCallable {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        Callable&lt;Porridge&gt; call = () -&gt; {
            System.out.println(&quot;正在煮粥&quot;);
            Thread.sleep(5000);
            return new Porridge();
        };
        FutureTask&lt;Porridge&gt; task = new FutureTask&lt;&gt;(call);
        new Thread(task).start();
        Thread.sleep(500);
        System.out.println(&quot;我去睡个觉&quot;);
        Porridge i = task.get();
        System.out.println(&quot;我拿到了煮粥结果：&quot;+i);
    }

    static class Porridge{
        public Porridge(){}
    }
}</code></pre>
<ul>
<li>Future和FutureTask区别</li>
</ul>
<p>答：Future只支持Callable线程执行，FutureTask还支持Runnable线程，并且有返回值</p>
<h3 id="FutureTask源码"><a href="#FutureTask源码" class="headerlink" title="FutureTask源码"></a>FutureTask源码</h3><ul>
<li>变量</li>
</ul>
<pre><code class="java">/*当前任务的执行状态*/
private volatile int state;
/*当前要执行的任务，执行完后将被设置为null*/
private Callable&lt;V&gt; callable;
/*当前任务的执行结果，当发生异常或被取消时为对应异常，非volatile，由state状态保证线程安全*/
private Object outcome; 
/*执行当callable任务的线程引用，为当前线程通过CAS方式原子设置*/
private volatile Thread runner;
/*Treiber椎，用于保存由于调用Future.get方法而阻塞的线程*/
private volatile WaitNode waiters;</code></pre>
<ul>
<li>状态</li>
</ul>
<pre><code class="java">//任务的初始化状态
private static final int NEW          = 0;
//正在执行状态
private static final int COMPLETING   = 1;
//任务正常执行完成的状态
private static final int NORMAL       = 2;
//任务执行抛出异常的状态
private static final int EXCEPTIONAL  = 3;
//调用Future.cancell取消任务的状态
private static final int CANCELLED    = 4;
//执行任务的线程被中断的中间状态
private static final int INTERRUPTING = 5;
//执行任务的线程被中断的最终状态
private static final int INTERRUPTED  = 6;</code></pre>
<p>上面已经提到，线程池调用submit的时候或者单独使用时都是由<code>AbstractExecutorService</code>类调用<code>FutureTask</code>的<code>run</code>方法</p>
<h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><ul>
<li>run</li>
</ul>
<pre><code class="java">public void run() {
    //初始化状态并设置为当前线程
        if (state != NEW ||
            !UNSAFE.compareAndSwapObject(this, runnerOffset,
                                         null, Thread.currentThread()))
            return;//失败返回
        try {
            Callable&lt;V&gt; c = callable;//c=Callable线程
            if (c != null &amp;&amp; state == NEW) {//如果非空并且为初始化状态执行任务
                V result;
                boolean ran;
                try {
                    result = c.call();//执行call获取返回结果
                    ran = true;//成功设置ran为true
                } catch (Throwable ex) {
                    result = null;//失败设置ran为false，result为空
                    ran = false;
                    setException(ex);//并设置异常状态
                }
                if (ran)//执行成功则设置result
                    set(result);
            }
        } finally {
            runner = null;
            int s = state;
            if (s &gt;= INTERRUPTING)
                handlePossibleCancellationInterrupt(s);
        }</code></pre>
<ul>
<li><p>setException</p>
<p>设置异常执行结果</p>
</li>
</ul>
<pre><code class="java">protected void setException(Throwable t) {
        if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {//把状态设置为正在执行
            outcome = t;//把异常作为执行任务结果
            UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); //再把状态设置为异常
            finishCompletion();//任务执行失败，唤醒其他线程
        }
    }</code></pre>
<ul>
<li><p>finishCompletion</p>
<p>唤醒其他线程</p>
</li>
</ul>
<pre><code class="java">private void finishCompletion() {
        for (WaitNode q; (q = waiters) != null;) {//等待线程不为空的话循环唤醒所有
            if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {//如果CAS设置等待线程为空成功
                for (;;) {//就循环唤醒线程
                    Thread t = q.thread;//t为当前等待线程
                    if (t != null) {//不为空
                        q.thread = null;//线程引用置为空
                        LockSupport.unpark(t);//唤醒该线程
                    }
                    WaitNode next = q.next;//下个等待线程
                    if (next == null)//为空结束
                        break;
                    q.next = null; // unlink to help gc
                    q = next;//q为下一个，继续执行唤醒
                }
                break;
            }
        }
        done();//结束唤醒
        callable = null;        // to reduce footprint
    }</code></pre>
<ul>
<li><p>set</p>
<p>设置正常执行结果</p>
</li>
</ul>
<pre><code class="java">protected void set(V v) {
        if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {//把状态设置为正在执行
            outcome = v;//接受返回值作为任务执行结果
            UNSAFE.putOrderedInt(this, stateOffset, NORMAL); //把状态设置为正常结束
            finishCompletion();//任务正常结束，唤醒其他线程
        }
    }</code></pre>
<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>获取返回值</p>
<ul>
<li>get</li>
</ul>
<pre><code class="java">public V get() throws InterruptedException, ExecutionException {
        int s = state;
        if (s &lt;= COMPLETING)//如果状态&lt;=在执行状态
            s = awaitDone(false, 0L);//执行等待
        return report(s);//返回获取的结果(返回值或者异常)
    }</code></pre>
<ul>
<li><p>awaitDone</p>
<p>执行等待操作</p>
</li>
</ul>
<pre><code class="java">private int awaitDone(boolean timed, long nanos)//是否设置超时时间
        throws InterruptedException {
        final long deadline = timed ? System.nanoTime() + nanos : 0L;
        WaitNode q = null;
        boolean queued = false;
        for (;;) {//循环等待状态改变
            if (Thread.interrupted()) {//如果被中断，删除等待线程，抛出异常
                removeWaiter(q);
                throw new InterruptedException();
            }
            int s = state;//获取状态
            if (s &gt; COMPLETING) {//状态&gt;正在执行状态，即完成状态(正常、异常)
                if (q != null)//等待线程不为null的话把它置为null，返回状态
                    q.thread = null;
                return s;
            }
            else if (s == COMPLETING) //如果正在执行，当前线程让出一会的CPU时间
                Thread.yield();
            else if (q == null)//如果等待线程为空，创建一个新的等待节点(第一次循环时)
                q = new WaitNode();
            else if (!queued)//为当前等待节点设置线程为当前线程
                queued = UNSAFE.compareAndSwapObject(this, waitersOffset,
                                                     q.next = waiters, q);
            else if (timed) {//如果设置了超时时间，等待
                nanos = deadline - System.nanoTime();
                if (nanos &lt;= 0L) {//超时时间过了没有执行完成则终止该任务并删除当前等待线程并返回状态
                    removeWaiter(q);
                    return state;
                }
                LockSupport.parkNanos(this, nanos);//执行超时等待时间
            }
            else
                LockSupport.park(this);//执行等待
        }
    }</code></pre>
<ul>
<li><p>report</p>
<p>根据状态判断获取的返回值</p>
</li>
</ul>
<pre><code class="java">private V report(int s) throws ExecutionException {
        Object x = outcome;
        if (s == NORMAL)//如果正常执行完毕
            return (V)x;//返回执行的结果(正常返回值)
        if (s &gt;= CANCELLED)//如果被取消或者被中断 抛出异常
            throw new CancellationException();
        throw new ExecutionException((Throwable)x);//否则为异常状态，则抛出outcome结果存储的异常
    }</code></pre>
<h2 id="十三-Fork-Join框架"><a href="#十三-Fork-Join框架" class="headerlink" title="十三.Fork/Join框架"></a>十三.Fork/Join框架</h2><ul>
<li>Fork：“分”</li>
<li>Join：“加”</li>
</ul>
<p>意思就是<strong>把任务分成多个任务，每个任务执行完后合起来获得最终结果</strong>，也叫<code>分而治之</code>法</p>
<blockquote>
<p>为什么并发中要出现这种方法呢？</p>
<p>答：我们都知道多线程是为了提高效率而同时执行多个任务的操作，但是这个时候出现了<code>多核CPU</code>，如果我们只利用一个核，那么CPU资源就浪费太多了，处于这一点考虑，我们为了<code>充分利用CPU</code>资源，提出了分而治之法，在JUC中就是<code>Fork/Join框架</code></p>
</blockquote>
<ul>
<li>Fork/Join也属于一种执行器，也就是它的<code>ForkJoinPool</code></li>
</ul>
<img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/concurrent/4.png">

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>分而治之把一个大任务分成多组若干个小任务，每组任务开辟一个线程执行，每组线程都有一个队列负责该组任务的执行和等待</p>
<ul>
<li>工作窃取算法：每组任务执行速度不同，有的快有的慢，快的执行完后等待慢的执行完的话就浪费资源了，所以快的执行完后会帮还未执行完成的线程从<code>队列</code>中拿出任务去执行，但是这样会很混乱，所以规定了<strong>自己线程的任务是从队列头获取，其他线程来拿的任务从队列尾获取</strong></li>
</ul>
<img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/concurrent/3.png">



<h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><ul>
<li>具体使用Fork Join还需根据实际情况分析，较小或较大的数据量都会导致执行效率比串行执行慢</li>
<li>如果是<code>IO</code>操作较多的任务，尽量不使用，因为IO占CPU较少，<code>计算</code>占CPU多，适用于多计算的任务</li>
<li>不能在任务内部抛出效验异常，必须处理</li>
<li>细分出来的基本任务不能过大或过小，保持在100-10000个基本计算之间</li>
</ul>
<h3 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h3><p>Fork/Join包括下面的几个基本类</p>
<ul>
<li>ForkJoinPool：实现了ExecutorService和Executor接口，Java提供一个默认的ForkJoinPool对象(公用池)</li>
</ul>
<pre><code class="java">ForkJoinPool.commonPool();</code></pre>
<ul>
<li>ForkJoinTask：实现了Future接口，作为ForkJoin任务的抽象类，<code>submit返回该类对象</code>接收结果(Future也行)，类似FutureTask</li>
</ul>
<pre><code class="java">public abstract class ForkJoinTask&lt;V&gt; implements Future&lt;V&gt;</code></pre>
<ul>
<li>RecursiveTask：常用，扩展ForkJoinTask，也是一个抽象类，通过<code>继承</code>让子类重写<code>compute</code>方法实现有<code>返回结果</code>的ForkJoin任务</li>
<li>RecursiveAction：扩展ForkJoinTask，也是一个抽象类，通过<code>继承</code>让子类重写<code>compute</code>方法实现<code>不带返回结果</code>的ForkJoin任务</li>
<li>CountedCompleter：扩展ForkJoinTask，也是抽象类，<code>实现某个大任务完成后执行其他任务</code>，子类重写<code>compute</code>方法实现完成大任务的计算和重写<code>onCompletion</code>方法实现完成之后任务的计算</li>
</ul>
<p><strong>方法</strong></p>
<ul>
<li>fork：把创建的新的小任务发送给<code>ForkJoinPool</code>执行器，由它管理并分到其他线程执行</li>
<li>join：等待一个任务执行完成并获取它的<code>返回结果</code>，与JUC中join方法类似，多了返回值</li>
<li>quietlyJoin：没有返回值，与join区别是join任务被<code>撤销</code>的话，就会抛出异常，该方法不抛出异常</li>
</ul>
<h4 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h4><p>计算1乘到100000的计算(过大，得使用BigInteger)，比较串行和ForkJoin的效率</p>
<ul>
<li>串行</li>
</ul>
<pre><code class="java">public class ForLoopTask {
    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        BigInteger res = BigInteger.valueOf(1);
        for(int i=1;i&lt;=100000;i++){
            res = res.multiply(BigInteger.valueOf(i));
        }
        System.out.println(res);
        long end = System.currentTimeMillis();
        System.out.println(&quot;耗时：&quot;+(end-start));
    }
}</code></pre>
<p>耗时</p>
<pre><code class="java">耗时：5464ms</code></pre>
<ul>
<li>ForkJoin</li>
</ul>
<pre><code class="java">public class MyForkJoinTask extends RecursiveTask&lt;BigInteger&gt; {
    private long start;
    private long end;
    public MyForkJoinTask(long start,long end){
        this.start = start;
        this.end = end;
    }
    @Override
    protected BigInteger compute() {
        BigInteger res = new BigInteger(&quot;1&quot;);//使用BigInteger类型存储过大的数
        if(end-start&lt;=2&amp;&amp;end-start&gt;0){//表示可以进行计算，最基本任务计算2个数相乘
            //计算
            for(long i=start;i&lt;=end;i++){
                res = res.multiply(BigInteger.valueOf(i));
            }
        }else {
            //分治
            long half = (end-start)/2;
            MyForkJoinTask leftTask = new MyForkJoinTask(start,start+half);
            MyForkJoinTask rightTask = new MyForkJoinTask(start+half+1,end);
            leftTask.fork();//提交任务到执行器
            rightTask.fork();
            BigInteger a = leftTask.join();//等待任务执行完并获取结果
            BigInteger b = rightTask.join();
            res = a.multiply(b);
        }
        return res;
    }
    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        ForkJoinPool forkJoinPool = ForkJoinPool.commonPool();
        MyForkJoinTask task = new MyForkJoinTask(1,100000);
        Future&lt;BigInteger&gt; future = forkJoinPool.submit(task);//接受Future对象作为返回值
        try {
            System.out.println(future.get());
            long end = System.currentTimeMillis();
            System.out.println(&quot;耗时：&quot;+(end-start));
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
<p>耗时</p>
<pre><code class="java">耗时：1143</code></pre>
<blockquote>
<p>可以明显看到，当数据计算较大时，使用ForkJoin比串行执行有高出4秒的效率</p>
</blockquote>
<h4 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h4><p>我们用一个12万数据量的样本来测试，筛选其中的某个key中value值等于一个值的全部数据</p>
<p>样本：NBA投篮数据</p>
<p>筛选：与Kobe有关的全部数据并打印</p>
<p>样本地址：<a href="https://www.kaggle.com/dansbecker/nba-shot-logs/downloads/nba-shot-logs.zip/1" rel="external nofollow noopener noreferrer" target="_blank">https://www.kaggle.com/dansbecker/nba-shot-logs/downloads/nba-shot-logs.zip/1</a></p>
<ul>
<li>数据对象bean</li>
</ul>
<pre><code class="java">@Data
@AllArgsConstructor
public class ShotDataSet {
    private String game_id;
    private String matchUp;
    private String location;
    private String w;
    private String finalMargin;
    private String shot_number;
    private String period;
    private String gameClock;
    private String shotClock;
    private String dribbles;
    private String touchTime;
    private String shotDist;
    private String ptsType;
    private String shotRes;
    private String closestDefend;
    private String cDPId;
    private String cDDist;
    private String fgm;
    private String points;
    private String playName;
    private String playId;
}</code></pre>
<ul>
<li><p>CSV数据加载器</p>
<p>把CSV中数据转换成一个存储<code>ShotDataSet</code>对象的集合<code>ArrayList</code>，使用了Github上的Java工具项目<code>Hutool</code></p>
</li>
</ul>
<pre><code class="java">public class ShotDataSetLoader {
    public static List&lt;ShotDataSet&gt; loadCsv(String path) {
        List&lt;ShotDataSet&gt; res = new ArrayList&lt;ShotDataSet&gt;();
        CsvReader reader = CsvUtil.getReader();
//从文件中读取CSV数据
        CsvData data = reader.read(FileUtil.file(path));
        List&lt;CsvRow&gt; rows = data.getRows();
//遍历行
        for (CsvRow csvRow : rows) {
            //getRawList返回一个List列表，列表的每一项为CSV中的一个单元格（既逗号分隔部分）
            List&lt;String&gt; strList = csvRow.getRawList();
            ShotDataSet dataSet = new ShotDataSet(strList.get(0),
                    strList.get(1),strList.get(2),strList.get(3),
                    strList.get(4),strList.get(5),strList.get(6),
                    strList.get(7),strList.get(8),strList.get(9),
                    strList.get(10),strList.get(11),strList.get(12),
                    strList.get(13),strList.get(14),strList.get(15),
                    strList.get(16),strList.get(17),strList.get(18),
                    strList.get(19),strList.get(20));
            res.add(dataSet);
        }
        return res;
    }
}</code></pre>
<ul>
<li><p>任务类 继承RecursiveTask</p>
<p>Kobe的PlayerId值等于997，把加载出来的全部数据对象使用ForkJoin分治，保证最基本任务里执行计算的步骤不要太多或太少，我们选取最小集合中有50个对象时执行基本任务。</p>
</li>
</ul>
<pre><code class="java">public class ShotDataSearchTask extends RecursiveTask&lt;List&lt;ShotDataSet&gt;&gt; {
    private List&lt;ShotDataSet&gt; list;
    private static List&lt;ShotDataSet&gt; resList = new ArrayList&lt;&gt;();
    public ShotDataSearchTask(List&lt;ShotDataSet&gt;  list){
        this.list = list;
    }
    @Override
    protected List&lt;ShotDataSet&gt; compute() {
        if(list.size()&lt;50){
            for(int i=0;i&lt;50;i++){
                ShotDataSet dataSet = list.get(i);
                if(dataSet.getPlayId().trim().equals(&quot;977&quot;)){//kobe的playerId值等于997
                    resList.add(dataSet);
                }
            }
        }else {
            long half = list.size()/2;
            ShotDataSearchTask leftTask = new ShotDataSearchTask(list.stream().limit(half).collect(Collectors.toList()));//用limit限制集合里数量为一半并且是前一半
            ShotDataSearchTask rightTask = new ShotDataSearchTask(list.stream().skip(half).collect(Collectors.toList()));//用skip跳过集合中前一半
            leftTask.fork();
            rightTask.fork();
            leftTask.quietlyJoin();
            rightTask.quietlyJoin();
        }
        return resList;
    }
    public static void main(String[] args) {
        List&lt;ShotDataSet&gt; list = ShotDataSetLoader.loadCsv(&quot;/home/dzou/Documents/shot_logs.csv&quot;);
        long start = System.currentTimeMillis();
        ShotDataSearchTask task = new ShotDataSearchTask(list);
        ForkJoinPool pool = ForkJoinPool.commonPool();
        Future&lt;List&lt;ShotDataSet&gt;&gt; future = pool.submit(task);
        try {
            System.out.println(future.get());
            long end = System.currentTimeMillis();
            System.out.println(&quot;耗时：&quot;+(end-start));
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
    }
}</code></pre>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>执行器中执行任务的方法：</p>
<ul>
<li><code>submit</code>：提交任务到执行器并获取返回对象Future，返回值用该对象或者ForkJoinTask接收，用get方法获取</li>
<li><code>invoke</code>：提交任务到执行器，任务完后执行方可返回，不是Future。</li>
<li><code>execute</code>：提交任务到执行器，没有返回值。</li>
</ul>
<p>ForkJoin任务基本形式如下：</p>
<pre><code class="java">     if(size&gt;DEFALUT_SIZE){
            MyForkJoinTask leftTask = new MyForkJoinTask();
            MyForkJoinTask rightTask = new MyForkJoinTask();
            leftTask.fork();//提交任务到执行器
            rightTask.fork();
            leftTask.join();//等待任务执行完并获取结果
            rightTask.join();
        }else {
            //计算
            res = solveProblem();
            return res;
        }</code></pre>
<h2 id="十四-Map-Reduce"><a href="#十四-Map-Reduce" class="headerlink" title="十四.Map/Reduce"></a>十四.Map/Reduce</h2><p>一个主要区别是，<a href="http://gee.cs.oswego.edu/dl/papers/fj.pdf" rel="external nofollow noopener noreferrer" target="_blank">F-J</a>似乎设计为在单个Java VM上工作，而<a href="http://static.googleusercontent.com/external_content/untrusted_dlcp/labs.google.com/en/us/papers/mapreduce-osdi04.pdf" rel="external nofollow noopener noreferrer" target="_blank">M-R</a>则明确设计为在大型机器集群上工作。这些是非常不同的场景。</p>
<p>MapReduce是一种编程模型，用于分布式大规模数据计算。</p>
<ul>
<li>Map：数据筛选和转换</li>
<li>Reduce：数据汇总</li>
</ul>
<p>在Java中的API就是<code>Stream</code>，分为并行流和串行流</p>
<p>使用：</p>
<ul>
<li>大数据数值分析</li>
<li>信息检索</li>
<li>推荐系统</li>
</ul>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    dzou  |  微信：17856530567
  </li>
  <li class="post-copyright-link">
  <strong>本文链接：</strong>
  <a href="http://www.dzou.top/post/37228cde.html" title="Java并发编程学习笔记-更新中">http://www.dzou.top/post/37228cde.html</a>
</li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
  </li>
  <li class="post-copyright-license">
    并保留本声明和上方二维码。感谢您的阅读和支持！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/基础/" rel="tag"># 基础</a>
          
            <a href="/tags/并发编程/" rel="tag"># 并发编程</a>
          
            <a href="/tags/同步器/" rel="tag"># 同步器</a>
          
            <a href="/tags/锁/" rel="tag"># 锁</a>
          
            <a href="/tags/学习笔记/" rel="tag"># 学习笔记</a>
          
            <a href="/tags/同步/" rel="tag"># 同步</a>
          
            <a href="/tags/多线程/" rel="tag"># 多线程</a>
          
            <a href="/tags/线程安全性/" rel="tag"># 线程安全性</a>
          
            <a href="/tags/Synchronized/" rel="tag"># Synchronized</a>
          
            <a href="/tags/volatile/" rel="tag"># volatile</a>
          
            <a href="/tags/原子类/" rel="tag"># 原子类</a>
          
            <a href="/tags/CAS/" rel="tag"># CAS</a>
          
            <a href="/tags/ReentrantLoc/" rel="tag"># ReentrantLoc</a>
          
            <a href="/tags/线程池/" rel="tag"># 线程池</a>
          
            <a href="/tags/并发工具包/" rel="tag"># 并发工具包</a>
          
            <a href="/tags/等待-通信/" rel="tag"># 等待/通信</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div id="needsharebutton-postbottom">
            <span class="btn">
              <i class="fa fa-share-alt" aria-hidden="true"></i>
            </span>
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/post/b3bf778.html" rel="next" title="动态规划算法基本案例">
                <i class="fa fa-chevron-left"></i> 动态规划算法基本案例
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/post/f08593ab.html" rel="prev" title="牛客网算法编程题--办公室路径走法 解答">
                牛客网算法编程题--办公室路径走法 解答 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript" rel="external nofollow noopener noreferrer" target="_blank">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/2.JPG" alt="dzou">
            
              <p class="site-author-name" itemprop="name">dzou</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">46</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">62</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/ding-zou" target="_blank" title="GitHub" rel="external nofollow noopener noreferrer">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="dingxiang.zoufubo@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://me.csdn.net/qq_44760332" target="_blank" title="CSDN" rel="external nofollow noopener noreferrer">
                      
                        <i class="fa fa-fw fa-copyright"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                推荐链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.dzou.top/post/7a5625fe.html" title="Java并发之AQS源码分析" target="_blank">Java并发之AQS源码分析</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://localhost:4000/post/366ffd58.html" title="SpringBoot自动配置原理-源码分析" target="_blank" rel="external nofollow noopener noreferrer">SpringBoot自动配置原理-源码分析</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.dzou.top/post/712f837.html" title="Java Web安全框架Shiro使用" target="_blank">Java Web安全框架Shiro使用</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.dzou.top/post/19e1cc75.html" title="Linux基础命令" target="_blank">Linux基础命令</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.dzou.top/post/8184a8fd.html" title="JDK8新特性——流和Lambda表达式" target="_blank">JDK8新特性——流和Lambda表达式</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://music.163.com/#/user/home?id=564117665" title="网易云音乐" target="_blank" rel="external nofollow noopener noreferrer">网易云音乐</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一-创建线程方式"><span class="nav-number">1.</span> <span class="nav-text">一.创建线程方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二-线程问题"><span class="nav-number">2.</span> <span class="nav-text">二.线程问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-活跃性问题"><span class="nav-number">2.1.</span> <span class="nav-text">1.活跃性问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-线程安全性"><span class="nav-number">2.2.</span> <span class="nav-text">2.线程安全性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三-Synchronized"><span class="nav-number">3.</span> <span class="nav-text">三.Synchronized</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四-锁的类型"><span class="nav-number">4.</span> <span class="nav-text">四.锁的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-重入锁"><span class="nav-number">4.1.</span> <span class="nav-text">1.重入锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-自旋锁"><span class="nav-number">4.2.</span> <span class="nav-text">2.自旋锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-死锁"><span class="nav-number">4.3.</span> <span class="nav-text">3.死锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五-volatile"><span class="nav-number">5.</span> <span class="nav-text">五.volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile-与-synchronized比较"><span class="nav-number">5.0.1.</span> <span class="nav-text">volatile 与 synchronized比较</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#六-JDK-原子类"><span class="nav-number">6.</span> <span class="nav-text">六.JDK 原子类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原子类"><span class="nav-number">6.1.</span> <span class="nav-text">原子类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS"><span class="nav-number">6.2.</span> <span class="nav-text">CAS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七-Lock"><span class="nav-number">7.</span> <span class="nav-text">七.Lock</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lock接口方法"><span class="nav-number">7.1.</span> <span class="nav-text">Lock接口方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">7.2.</span> <span class="nav-text">ReentrantLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lock与synchronized比较"><span class="nav-number">7.3.</span> <span class="nav-text">lock与synchronized比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义锁"><span class="nav-number">7.4.</span> <span class="nav-text">自定义锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#八-AbstractQueuedSynchronizer-AQS"><span class="nav-number">8.</span> <span class="nav-text">八.AbstractQueuedSynchronizer(AQS)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#九-读写锁"><span class="nav-number">9.</span> <span class="nav-text">九.读写锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantReadWriteLock"><span class="nav-number">9.1.</span> <span class="nav-text">ReentrantReadWriteLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现原理"><span class="nav-number">9.2.</span> <span class="nav-text">实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#状态维护"><span class="nav-number">9.3.</span> <span class="nav-text">状态维护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁降级"><span class="nav-number">9.4.</span> <span class="nav-text">锁降级</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十-线程通信"><span class="nav-number">10.</span> <span class="nav-text">十.线程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#wait-notify"><span class="nav-number">10.1.</span> <span class="nav-text">wait notify</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生产者和消费者"><span class="nav-number">10.2.</span> <span class="nav-text">生产者和消费者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Condition——线程通信更高效的方式"><span class="nav-number">10.3.</span> <span class="nav-text">Condition——线程通信更高效的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Condition实现的有界队列"><span class="nav-number">10.3.1.</span> <span class="nav-text">Condition实现的有界队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Condition源码分析"><span class="nav-number">10.3.2.</span> <span class="nav-text">Condition源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#await"><span class="nav-number">10.3.2.1.</span> <span class="nav-text">await</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#addConditionWaiter"><span class="nav-number">10.3.2.2.</span> <span class="nav-text">addConditionWaiter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#unlinkCancelledWaiters"><span class="nav-number">10.3.2.3.</span> <span class="nav-text">unlinkCancelledWaiters</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#signal"><span class="nav-number">10.3.2.4.</span> <span class="nav-text">signal</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#doSignal"><span class="nav-number">10.3.2.5.</span> <span class="nav-text">doSignal</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#transferForSignal"><span class="nav-number">10.3.2.6.</span> <span class="nav-text">transferForSignal</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库连接池"><span class="nav-number">10.4.</span> <span class="nav-text">数据库连接池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用Condition-ReentrantLock实现"><span class="nav-number">10.4.1.</span> <span class="nav-text">使用Condition+ReentrantLock实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程-Join"><span class="nav-number">10.5.</span> <span class="nav-text">线程 Join</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">10.6.</span> <span class="nav-text">ThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用方法"><span class="nav-number">10.6.1.</span> <span class="nav-text">使用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现原理-1"><span class="nav-number">10.6.2.</span> <span class="nav-text">实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">10.6.3.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存泄露"><span class="nav-number">10.6.4.</span> <span class="nav-text">内存泄露</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal应用"><span class="nav-number">10.6.5.</span> <span class="nav-text">ThreadLocal应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InheritableThreadLocal"><span class="nav-number">10.6.6.</span> <span class="nav-text">InheritableThreadLocal</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十一-并发工具类"><span class="nav-number">11.</span> <span class="nav-text">十一.并发工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CountDownLatch——共享锁"><span class="nav-number">11.1.</span> <span class="nav-text">CountDownLatch——共享锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用"><span class="nav-number">11.1.1.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#源码分析"><span class="nav-number">11.1.2.</span> <span class="nav-text">源码分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CyclicBarrier——屏障"><span class="nav-number">11.2.</span> <span class="nav-text">CyclicBarrier——屏障</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用-1"><span class="nav-number">11.2.1.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#源码分析-1"><span class="nav-number">11.2.2.</span> <span class="nav-text">源码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CyclicBarrier和CountDownLatch"><span class="nav-number">11.2.3.</span> <span class="nav-text">CyclicBarrier和CountDownLatch</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Semaphore——信号量"><span class="nav-number">11.3.</span> <span class="nav-text">Semaphore——信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化"><span class="nav-number">11.3.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用-2"><span class="nav-number">11.3.2.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#源码分析-2"><span class="nav-number">11.3.3.</span> <span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#acquire"><span class="nav-number">11.3.3.1.</span> <span class="nav-text">acquire</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#release"><span class="nav-number">11.3.3.2.</span> <span class="nav-text">release</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exchanger——交换者"><span class="nav-number">11.4.</span> <span class="nav-text">Exchanger——交换者</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用-3"><span class="nav-number">11.4.1.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现原理-2"><span class="nav-number">11.4.2.</span> <span class="nav-text">实现原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十二-Future"><span class="nav-number">12.</span> <span class="nav-text">十二.Future</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Callable"><span class="nav-number">12.1.</span> <span class="nav-text">Callable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Future"><span class="nav-number">12.2.</span> <span class="nav-text">Future</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Future和Callable使用"><span class="nav-number">12.3.</span> <span class="nav-text">Future和Callable使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FutureTask"><span class="nav-number">12.4.</span> <span class="nav-text">FutureTask</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FutureTask和Callable使用"><span class="nav-number">12.5.</span> <span class="nav-text">FutureTask和Callable使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FutureTask源码"><span class="nav-number">12.6.</span> <span class="nav-text">FutureTask源码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#run"><span class="nav-number">12.6.1.</span> <span class="nav-text">run</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#get"><span class="nav-number">12.6.2.</span> <span class="nav-text">get</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十三-Fork-Join框架"><span class="nav-number">13.</span> <span class="nav-text">十三.Fork/Join框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理"><span class="nav-number">13.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#局限性"><span class="nav-number">13.2.</span> <span class="nav-text">局限性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-4"><span class="nav-number">13.3.</span> <span class="nav-text">使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#案例1"><span class="nav-number">13.3.1.</span> <span class="nav-text">案例1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#案例2"><span class="nav-number">13.3.2.</span> <span class="nav-text">案例2</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-1"><span class="nav-number">13.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十四-Map-Reduce"><span class="nav-number">14.</span> <span class="nav-text">十四.Map/Reduce</span></a></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dzou</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">68.9k</span>
  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问用户：
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问次数：
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    

    
      <div id="needsharebutton-float">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://dzou.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://www.dzou.top/post/37228cde.html';
          this.page.identifier = 'post/37228cde.html';
          this.page.title = 'Java并发编程学习笔记-更新中';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://dzou.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.4"></script>



  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "box";
      
          pbOptions.boxForm = "horizontal";
      
          pbOptions.position = "topCenter";
      
          pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
      flOptions = {};
      
          flOptions.iconStyle = "box";
      
          flOptions.boxForm = "horizontal";
      
          flOptions.position = "topRight";
      
          flOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-float', flOptions);
    
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

  

  

  

  


</body>
</html>
<script type="text/javascript" src="/js/src/dynamic_bg.js"></script>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
<script type="text/javascript" src="/js/google-code-prettify/prettify.js"></script>
<script type="text/javascript">
$(window).load(function(){
   $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');
   prettyPrint();
 })    
</script>

