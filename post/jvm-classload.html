<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">





  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "d1f94239"
    });
  daovoice('update');
  </script>














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/2.JPG?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/2.JPG?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Java基础,面试,Java,jvm,类加载,类加载器,serviceLoader">





  <link rel="alternate" href="/atom.xml" title="Dzou's Blog" type="application/atom+xml">






<meta name="description" content="把Java字节码加载成一段二进制流，读取到内存，放在运行时数据区的方法区内；创建一个java.lang.Class对象描述该类的数据结构.加载一个类时，会由自底向上检查一个类是否被加载，如果没有被加载过，会尝试从顶向下加载，首先会由启动器加载器rt.jar加载Object，所有类被加载时都要保证Object类已经被加载.">
<meta name="keywords" content="Java基础,面试,Java,jvm,类加载,类加载器,serviceLoader">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Java虚拟机之—JVM类加载过程和类加载器">
<meta property="og:url" content="https://www.dzou.top/post/jvm-classload.html">
<meta property="og:site_name" content="Dzou&#39;s Blog">
<meta property="og:description" content="把Java字节码加载成一段二进制流，读取到内存，放在运行时数据区的方法区内；创建一个java.lang.Class对象描述该类的数据结构.加载一个类时，会由自底向上检查一个类是否被加载，如果没有被加载过，会尝试从顶向下加载，首先会由启动器加载器rt.jar加载Object，所有类被加载时都要保证Object类已经被加载.">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://dzou.wangminwei.top/static/images/jvm/1.png">
<meta property="og:image" content="http://dzou.wangminwei.top/static/images/jvm/2.png">
<meta property="og:image" content="http://dzou.wangminwei.top/static/images/jvm/3.png">
<meta property="og:image" content="http://dzou.wangminwei.top/static/images/jvm/5.png">
<meta property="og:image" content="http://dzou.wangminwei.top/static/images/jvm/7.png">
<meta property="og:image" content="http://dzou.wangminwei.top/static/images/jvm/8.png">
<meta property="og:image" content="http://dzou.wangminwei.top/static/images/jvm/6.png">
<meta property="og:image" content="http://dzou.wangminwei.top/static/images/JVM/7.png">
<meta property="og:updated_time" content="2019-11-07T12:31:58.388Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解Java虚拟机之—JVM类加载过程和类加载器">
<meta name="twitter:description" content="把Java字节码加载成一段二进制流，读取到内存，放在运行时数据区的方法区内；创建一个java.lang.Class对象描述该类的数据结构.加载一个类时，会由自底向上检查一个类是否被加载，如果没有被加载过，会尝试从顶向下加载，首先会由启动器加载器rt.jar加载Object，所有类被加载时都要保证Object类已经被加载.">
<meta name="twitter:image" content="http://dzou.wangminwei.top/static/images/jvm/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'Q66404JRFM',
      apiKey: '27dd0e53d330bf96c9826662fc30055a',
      indexName: 'dzou',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://www.dzou.top/post/jvm-classload.html">





<link href="/js/google-code-prettify/tomorrow-night-eighties.min.css" type="text/css" rel="stylesheet">



  <title>深入理解Java虚拟机之—JVM类加载过程和类加载器 | Dzou's Blog</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  
  
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="bg_content">
    <canvas id="canvas"></canvas>
  </div>

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Dzou's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">No pains,no gains.</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://www.dzou.top/post/jvm-classload.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dzou">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/2.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dzou's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">深入理解Java虚拟机之—JVM类加载过程和类加载器</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-06T18:15:05+08:00">
                2019-11-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/jvm/" itemprop="url" rel="index">
                    <span itemprop="name">jvm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/post/jvm-classload.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="post/jvm-classload.html" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>&nbsp浏览次数：
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8.1k字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  32分
                </span>
              
            </div>
          

          
              <div class="post-description">
                  把Java字节码加载成一段二进制流，读取到内存，放在运行时数据区的方法区内；创建一个java.lang.Class对象描述该类的数据结构.加载一个类时，会由自底向上检查一个类是否被加载，如果没有被加载过，会尝试从顶向下加载，首先会由启动器加载器rt.jar加载Object，所有类被加载时都要保证Object类已经被加载.
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="深入理解Java虚拟机之—JVM类加载过程和类加载器"><a href="#深入理解Java虚拟机之—JVM类加载过程和类加载器" class="headerlink" title="深入理解Java虚拟机之—JVM类加载过程和类加载器"></a>深入理解Java虚拟机之—JVM类加载过程和类加载器</h1><blockquote>
<p>不仅是为了面试，还为了从根本上学习和理解Java代码的执行过程，提高自己对Java的理解</p>
</blockquote>
<img src="http://dzou.wangminwei.top/static/images/jvm/1.png">

<p><strong>Java虚拟机生命周期：</strong></p>
<ol>
<li>程序正常结束</li>
<li>程序异常终止</li>
<li>操作系统错误</li>
<li>System.exit()</li>
</ol>
<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><blockquote>
<p>添加idea属性打印加载的类 <code>-XX:+TraceClassLoading</code></p>
</blockquote>
<p>在Java代码中，类的加载、连接和初始化都是在运行时完后的，每一个类都通过类加载器加入加载到JVM中(堆中)，形成一个虚拟机可以直接使用的Java类型</p>
<h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h3><p><strong>把Java字节码加载成一段二进制流，读取到内存，放在运行时数据区的方法区内；创建一个java.lang.Class对象描述该类的数据结构</strong></p>
<blockquote>
<p>可以从磁盘、jar、war、网络、自己编写的class文件中加载class文件</p>
</blockquote>
<h3 id="2-连接"><a href="#2-连接" class="headerlink" title="2.连接"></a>2.连接</h3><p>分为验证、准备、解析三个阶段</p>
<h4 id="1-验证"><a href="#1-验证" class="headerlink" title="(1)验证"></a>(1)<strong>验证</strong></h4><p>确保类加载的正确性，保证Class文件的字节流不会影响虚拟机的安全(因为class文件可以从任何途径生成)，验证失败抛出<code>VerifyError</code>，验证通过就把内存中的二进制流存放到JVM的运行时数据区的方法区中</p>
<ol>
<li><strong>文件格式验证</strong></li>
</ol>
<p>文件开头魔数代表JDK版本号等信息；常量池中是否有不支持的常量</p>
<blockquote>
<p>只有验证通过，二进制字节流才会进入内存的方法区存储</p>
</blockquote>
<ol start="2">
<li><strong>元数据验证</strong></li>
</ol>
<p>验证该类是否有父类，父类是否继承了不允许继承的类(final类)；是否实现了父类或者接口中要求实现的方法；类中方法字段是否与父类或者接口匹配(参数类型、返回值类型)</p>
<ol start="3">
<li><strong>字节码验证</strong></li>
</ol>
<p>对类的方法体进行验证，保证类型转换是安全的。</p>
<blockquote>
<p>通过字节码验证也不一定是安全的，<code>Halting Problem</code>，没有任何一个程序可以校验所有程序的合法性(比如while true是无法校验的)</p>
</blockquote>
<ol start="4">
<li><strong>符号引用验证</strong></li>
</ol>
<p>发生在符号引用转换为直接引用的时候</p>
<p>确保该符号引用可以找到对应类。</p>
<h4 id="2-准备"><a href="#2-准备" class="headerlink" title="(2)准备"></a>(2)<strong>准备</strong></h4><p>为类的静态变量分配内存(内存中方法区)，并将其初始化为默认值(不是自己设置的值，例如<code>int a=1;</code>将a赋值为0)</p>
<h4 id="3-解析"><a href="#3-解析" class="headerlink" title="(3)解析"></a>(3)<strong>解析</strong></h4><p><strong>将虚拟机常量池中的符号引用(一组符号描述目标引用，也就是JVM中的Reference)转换为直接引用(指向目标的实际内存地址)</strong></p>
<h3 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3.初始化"></a>3.初始化</h3><ul>
<li>被动使用不会导致类的初始化</li>
</ul>
<p>为静态变量赋初始值，执行static块</p>
<p>以下情况将触发初始化：</p>
<ol>
<li>遇到<code>new</code>,<code>getstatic</code>,<code>putstatic</code>,<code>invokestatic</code>指令时，如果没有初始化将进行初始化</li>
<li>反射调用<code>reflect</code>包中，将初始化调用类</li>
<li>虚拟机启动时需要制定一个执行的主类，main函数类将进行初始化</li>
<li>初始化一个类时，父类没有被初始化，则将进行父类初始化</li>
<li>JDK7中MethodHandler</li>
</ol>
<p><strong>对于静态字段，只有直接定义的地方才会被初始化</strong></p>
<pre><code class="java">public class Test8 {
    public static void main(String[] args) {
        System.out.println(Son2.s);
    }
}
class Father2{
    public static int s = 1;
    static{
        System.out.println(&quot;hello i am father&quot;);
    }
}
class Son2 extends Father2{
    //不会打印这句 没有对Son2的主动使用
    static {
        System.out.println(&quot;hello i am son&quot;);
    }
}
</code></pre>
<blockquote>
<p>在初始化一个类时，要求其父类已经被初始化</p>
<p>在初始化一个接口时，不要求其父接口被初始化</p>
<p>在初始化一个类时，不要求其实现接口被初始化</p>
<p><code>接口变量不需要使用public static final修饰 默认是常量</code></p>
</blockquote>
<p>案例：加载静态变量和常量</p>
<pre><code class="java">public class Test1 {
    public static void main(String[] args) {
        System.out.println(MyChild.s);
    }
}
class MyParent{
    /**
     * 当s申明为static时 会加载父类和子类，但是只会调用父类的static块
     * 当s加上final时，表示常量，不会加载任何一个类,编译阶段被放入该Test1类的常量池中
     */
    public static final String s = &quot;dx&quot;;
    static {
        System.out.println(&quot;hello i am my parent&quot;);
    }
}
class MyChild extends MyParent{
    static {
        System.out.println(&quot;i am my child&quot;);
    }
}</code></pre>
<img src="http://dzou.wangminwei.top/static/images/jvm/2.png">



<p>案例：接口初始化</p>
<pre><code class="java">/**
 * 接口初始化时，不要求父接口被初始化完成
 * 常量如果编译时确定，就不会去加载
 * 如果时运行时才可以确定的常量，需要加载
 */
public class Test4 {
    public static void main(String[] args) {
        System.out.println(MyInterfaceSon.b);
    }
}
//一直不加载
interface MyInterface{
    public static final int  a = 5;
}
interface MyInterfaceSon extends MyInterface{
    //会加载，运行时确定
    public static final int  b = new Random().nextInt(10);
    //不会加载，编译时就已经确定
    //public static final int  b = 10;

}</code></pre>
<p>案例：对象数组不被加载</p>
<pre><code class="java">public class Test3 {
    public static void main(String[] args) {
        /*
         * 不会加载MyParen4，数组类型不会导致加载，只会创建数组引用分配空间
         */
        MyParent3[] myParent = new MyParent3[10];
        //class [Ltop.dzou.jvm.MyParent3;
        //数组类型标志 [L 全限定名
        System.out.println(myParent.getClass());
    }
}
class MyParent3{

    static{
        System.out.println(&quot;i am my parent3&quot;);
    }
}</code></pre>
<p>案例：静态常量的初始化</p>
<pre><code class="java">public class Test5 {
    public static void main(String[] args) {
        /**
         * 调用了getInstance方法 主动进行加载Singleton类
         * 准备阶段：初始化count1为0 singleton为null count2为0
         * 初始化完成后，按照顺序调用，执行了invokespecial执行了构造函数，执行完count1=1 count2=1
         * 调用完后执行了自己的putstatic指令 把count2设置为0
         * 最终结果：count1=0 count2=0
         */
        Singleton singleton = Singleton.getInstance();
        System.out.println(singleton.count1);
        System.out.println(singleton.count2);
    }
}
class Singleton{
    public static int count1;
    private static Singleton singleton = new Singleton();
    private Singleton(){
        count1++;count2++;
        System.out.println(count1);
        System.out.println(count2);
    }
    public static int count2 = 0;

    public static Singleton getInstance(){
        return singleton;
    }
}</code></pre>
<img src="http://dzou.wangminwei.top/static/images/jvm/3.png">



<h3 id="双亲委托机制"><a href="#双亲委托机制" class="headerlink" title="双亲委托机制"></a>双亲委托机制</h3><p><strong>加载一个类时，会由自底向上检查一个类是否被加载，如果没有被加载过，会尝试从顶向下加载，首先会由启动器加载器rt.jar加载Object，所有类被加载时都要保证Object类已经被加载</strong></p>
<img src="http://dzou.wangminwei.top/static/images/jvm/5.png">

<blockquote>
<p>包含关系：</p>
<p>子加载器包含一个父亲加载器的引用，即使两个加载器属于一种类型的加载器(例如：同一种自定义加载器)</p>
<p>利用的是ClassLoader中构造方法可以传入一个parent也就是指向父类的类加载器的引用，加载时会优先委托给父类</p>
</blockquote>
<h5 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h5><p>是否可以自定义一个java.lang.System类？</p>
<p>答：不行，因为自定义System在加载时会被委托到启动器类加载器加载，根据全限定名找到真正的System类加载后在执行main函数时会报找不到main方法，原因是自定义的System类不会被加载</p>
<pre><code class="java">public class System {
    public static void main(String[] args) {

    }
}

output：
错误: 在类 java.lang.System 中找不到 main 方法, 请将 main 方法定义为:
   public static void main(String[] args)
否则 JavaFX 应用程序类必须扩展javafx.application.Application</code></pre>
<p><strong>双亲委派模型优点：</strong></p>
<ol>
<li>保证核心库的安全：如果都有自己的加载器加载，那么会存在很多命名空间，会存在很多相同的类，但是<code>无法相互兼容</code>使用(命名空间不同)，<code>确保核心类被优先加载</code>。</li>
<li>JVM相同的类可以存在的，通过命名空间相互隔离，可以一同存在，在不同命名空间中可以使用。</li>
</ol>
<h2 id="类加载器剖析"><a href="#类加载器剖析" class="headerlink" title="类加载器剖析"></a>类加载器剖析</h2><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>JVM虚拟机类加载器：<code>启动器加载器</code>、<code>扩展类加载器</code>、<code>系统加载器</code></p>
<p><strong>类加载器就是根据一个全限定名加载class生成二进制流并转换为一个java.lang.Class对象实例</strong></p>
<ul>
<li>真正类的加载过程是由<code>defineClass</code>完成的，根据Java Doc</li>
</ul>
<pre><code>Converts an array of bytes into an instance of class Class. Before the Class can be used it must be resolved.</code></pre><p>它将一个二进制流转换为一个java.lang.Class对象返回</p>
<h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><ul>
<li><p>每个类加载器都有<code>自己</code>的命名空间。</p>
</li>
<li><p><code>同一个命名空间内的类是相互可见</code>的，命名空间由该加载器及所有父加载器所加载的类组成。</p>
</li>
<li><p>在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类；在不同的命名空间中，<code>有可能</code>会出现类的完整名字（包括类的包名）相同的两个类。</p>
</li>
</ul>
<blockquote>
<p>扩展类加载器加载的class文件需要打成jar包</p>
</blockquote>
<blockquote>
<p>更改系统类加载器目录：修改java.system.class.loader为自定义</p>
<p>命令：<code>java -Djava.system.class.loader /自定义加载器class文件路径</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>loadClass(String name)</code></td>
<td>加载名称为 <code>name</code>的类，返回的结果是 <code>java.lang.Class</code>类的实例。</td>
</tr>
<tr>
<td><code>findClass(String name)</code></td>
<td>查找名称为 <code>name</code>的类，返回的结果是 <code>java.lang.Class</code>类的实例。</td>
</tr>
<tr>
<td><code>findLoadedClass(String name)</code></td>
<td>查找名称为 <code>name</code>的已经被加载过的类，返回的结果是 <code>java.lang.Class</code>类的实例。</td>
</tr>
<tr>
<td><code>defineClass(String name, byte[] b, int off, int len)</code></td>
<td>把字节数组 <code>b</code>中的内容转换成 Java 类，返回的结果是 <code>java.lang.Class</code>类的实例。这个方法被声明为 <code>final</code>的。</td>
</tr>
<tr>
<td><code>resolveClass(Class&lt;?&gt; c)</code></td>
<td>链接指定的 Java 类。</td>
</tr>
</tbody></table>
{% qnimg jvm/4.png %}

<p>案例：反射不导致类的初始化</p>
<pre><code class="java">public class Test9 {
    public static void main(String[] args) throws ClassNotFoundException {
        ClassLoader classLoader = ClassLoader.getSystemClassLoader();
        //classloader不会导致类的初始化
        Class&lt;?&gt; c = classLoader.loadClass(&quot;top.dzou.jvm.class_load.D&quot;);
        System.out.println(&quot;---------&quot;);
        //使用反射加载类会导致类的主动使用，从而初始化该类
        Class.forName(&quot;top.dzou.jvm.class_load.D&quot;);
        System.out.println(c);;
    }
}
class D{
    static {
        System.out.println(&quot;hello i am d&quot;);
    }
}</code></pre>
<p>案例：实现一个类加载器</p>
<p><strong>对于自定义的类加载器，我们通过继承ClassLoader类调用子类的loadClass方法加载类，loadClass方法会为我们自动调用findClass方法，其中需要实现自定义的加载类以及实现defineClass方法</strong></p>
<pre><code class="java">public class Test10 extends ClassLoader{
    private String fileExt = &quot;.class&quot;;
    private String path = null;
    public void setPath(String path) {
        this.path = path;
    }
    public Test10(){
        super();//super方法会使用系统加载器作为默认类加载器
    }
    @Override
    protected Class&lt;?&gt; findClass(String s) throws ClassNotFoundException {
        byte[] data = loadClassData(s);
        //找到class调用核心defineClass方法返回一个Class对象
        return defineClass(s,data,0,data.length);
    }
    //自己实现的加载类方法，把文件读取到二进制流中返回
    public byte[] loadClassData(String fileName){
        InputStream in = null;
        ByteArrayOutputStream baos = null;
        byte[] data = null;
        try {
            fileName = fileName.replace(&quot;.&quot;,&quot;/&quot;);
            in = new FileInputStream(new File(path+fileName+this.fileExt));
            baos = new ByteArrayOutputStream();
            int c = 0;
            while((c=in.read())!=-1){
                baos.write(c);
            }
            data = baos.toByteArray();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            try {
                in.close();
                baos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return data;
    }

    public static void main(String[] args) throws IllegalAccessException, InstantiationException, ClassNotFoundException {
        Test10 loader = new Test10();
        //调用ClassLoader的loadClass方法
        loader.setPath(&quot;/home/dzou/java/jvm-learning/target/classes/&quot;);
        Class&lt;?&gt; c = loader.loadClass(&quot;top.dzou.jvm.class_load.Test9&quot;);
        System.out.println(&quot;class:&quot;+c);
        Object o = c.newInstance();
        System.out.println(o);
        System.out.println(o.getClass().getClassLoader());
    }
}</code></pre>
<blockquote>
<p>注意：根据双亲委托机制，会先交给父类去加载，也就是系统类加载器加载，系统类加载器能加载成功的话，就不会使用我们自定义的类加载器，所以我们需要把target中的.class文件删除，使用我们自定义的.class文件路径才会让系统类加载器加载失败，从而使用我们自定义的类加载器</p>
</blockquote>
<h4 id="命名空间使用"><a href="#命名空间使用" class="headerlink" title="命名空间使用"></a>命名空间使用</h4><p><strong>两个不同实例的加载器加载不同path下的class</strong></p>
<pre><code class="java">public class Test13 {
    public static void main(String[] args) throws Exception {
        Test10 loader1 = new Test10();
        Test10 loader2 = new Test10();
        loader1.setPath(&quot;/home/dzou/Downloads/j/classes/&quot;);
        loader2.setPath(&quot;/home/dzou/Downloads/a/&quot;);
        Class&lt;?&gt; clazz2 = loader2.loadClass(&quot;top.dzou.jvm.class_load.Test1&quot;);
        Class&lt;?&gt; clazz1 = loader1.loadClass(&quot;top.dzou.jvm.class_load.Test1&quot;);
        Object o1 = clazz1.newInstance();
        Object o2 = clazz2.newInstance();
        System.out.println(o1.getClass().getClassLoader());
        System.out.println(o2.getClass().getClassLoader());
        System.out.println(o1==o2);
    }
}

输出：
top.dzou.jvm.class_load.Test10@6f94fa3e
top.dzou.jvm.class_load.Test10@1d44bcfa
false</code></pre>
<h4 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h4><p><code>Launcher</code>系统和扩展类加载类-&gt;<code>ExtClassLoader/AppClassLoader</code>内部类-&gt;<code>URLClassLoader</code>支持通过路径和jar包加载-&gt;<code>SecureClassLoader</code>支持提供保护permissions权限(具体没有了解)-&gt;<code>ClassLoader</code></p>
<blockquote>
<p>任意两个加载器都可以通过构造方法创建父子关系，即使是同一个类的类加载器</p>
</blockquote>
<h3 id="上下文类加载器"><a href="#上下文类加载器" class="headerlink" title="上下文类加载器"></a>上下文类加载器</h3><blockquote>
<p>ContextClassLoader就是为了破坏Java双亲委派模型</p>
</blockquote>
<p><strong>我们了解了类加载器，现在看一下一个核心的加载器，就是<code>上下文类加载器ContextClassLoader</code></strong></p>
<p>我们可以通过<code>Thread.currentThread().getContextClassLoader()</code>获取当前上下文类加载器</p>
<p>通过<code>Thread.currentThread().setContextClassLoader(ClassLoader cl);</code>来设置上下文类加载器</p>
<blockquote>
<p>依赖规则：我们知道每一个类都会使用自己的类加载器加载该类中依赖的类，比如A类中引用了B类，那么加载A类的时候就会使用加载A的加载器加载B，而且每一个我们编写的类都是由<code>系统类加载器(AppClassLoader)</code>加载的，那</p>
</blockquote>
<ul>
<li><strong>为何出现上下文类加载器？</strong></li>
</ul>
<p><strong>知道SPI的同学可能就知道JDBC、JAXP，不了解的下面一节会讲到，他们都是基于SPI实现的，基本上说就是JDK提供接口，服务商提供不同的实现(jar包)，当我们使用这些SPI接口时，我们都要导入相应的jar包到classpath下的指定目录可能为lib，mysql-connectorJ等，但是我们的SPI接口是在rt.jar中的，是由启动器类为我们加载的，那么如果根据<code>依赖规则和双亲委派模型</code>，JVM会使用加载该接口类的启动器加载器来加载我们的接口实现类，但是我们的SPI的不同实现类却在classpath下，这里是启动器类加载器加载不到的，<code>classpath只能由系统类加载器或者自定义加载器加载</code>，那么这样就会导致无法加载SPI接口实现类，所以<code>双亲委派模型</code>就不能在这起到合适的作用，我们就只能想办法去让<code>系统加载器来支持加载SPI实现类</code>，于是出现了上下文类加载器</strong></p>
<blockquote>
<p>可能有人会说直接把各个厂商的实现放入对应的接口类所在包里不就好了，乍一看这么做是可以解决问题，但是你要知道的是无论在设计模式还是JDK中都是<code>面向扩展，对修改关闭的</code>，这样做不仅违背了设计模式还会让JDK包变的务必庞大</p>
</blockquote>
<ul>
<li><strong>上下文类加载器的作用？</strong></li>
</ul>
<p><strong>它改变了父加载器的加载方式，也就是破坏了双亲委托模型，它让父加载器可以使用当前线程的``Thread.currentThread().getContextClassLoader()`类加载器获取到加载classpath下类的加载器，使用该加载器去加载类，这就改变了父加载器不能使用子加载器加载的类的情况</strong></p>
<blockquote>
<p>根据双亲委派模型传递顺序，父类加载器加载不了才会交给子类加载器，所以它自然看不到并无法加载子类加载器加载的类，智慧的JDK开发者发现了这一点，想到了一个<code>线程中的类加载器</code>，就可以通过线程的上下文类加载器来让父加载器可以访问子加载器所加载的类，就相当于把系统类加载器放在当前线程的上下文类加载器中，当父加载器需要获取子类加载器加载的类时，就可以通过这种方式获取</p>
</blockquote>
<img src="http://dzou.wangminwei.top/static/images/jvm/7.png">

<p><strong>由此我们可以想到ThreadLocal类的实现，也是利用每个线程的独立性把需要的信息放入ThreadLocal，思想就是一种以空间换时间的策略（多个线程都有自己独立的ThreadLocal存储区，消耗了一定的空间，但是我们就不需要通过其他方式去存储需要的信息并获取，时间上有很大的优化）</strong></p>
<p>源码文档写道：</p>
<pre><code>If not set, the default is the ClassLoader context of the parent Thread. The context ClassLoader of the primordial thread is typically set to the class loader used to load the application.</code></pre><p><strong>告诉我们如果的上下文类加载器没有被设置，那么默认值就是加载当前线程的类加载器，加载当前线程的类加载器就是加载该应用的类加载器，一般为系统类加载器</strong></p>
<blockquote>
<p>我们后面就根据一些源码分析和案例使用来看一看上下文类加载器到底有多么强大的功能，竟然可以破坏双亲委派模型</p>
</blockquote>
<h3 id="SPI加载以及破坏双亲委派模型"><a href="#SPI加载以及破坏双亲委派模型" class="headerlink" title="SPI加载以及破坏双亲委派模型"></a>SPI加载以及破坏双亲委派模型</h3><p><strong>SPI—Service Provider Interface，服务提供接口，像JDBC加载就是使用了spi，服务提供商使用spi扩展接口功能，类似根据jdk提供的一个接口不同服务提供商实现不同的接口实现，封装成一个jar包，我们通过导入这个jar包就可以使用服务提供商提供的该不同接口实现对应功能，通过ServiceLoader类加载不同服务提供商的实现—你可以简单理解为<code>策略模式</code></strong></p>
<h4 id="ServiceLoader"><a href="#ServiceLoader" class="headerlink" title="ServiceLoader"></a>ServiceLoader</h4><p>官方文档写的：<code>是一个加载服务提供商提供的服务实现的设备</code></p>
<pre><code>A simple service-provider loading facility.</code></pre><p>使用：官方文档写到：</p>
<pre><code>A service provider is identified by placing a provider-configuration file in the resource directory META-INF/services. The file&#39;s name is the fully-qualified binary name of the service&#39;s type. The file contains a list of fully-qualified binary names of concrete provider classes, one per line. </code></pre><p>*<em>就是说服务提供商需要在提供的服务实现所在的resource目录中编写配置文件，指定文件目录为META-INF/services，文件名是服务类型的全限定名(也就是jdk中服务接口的接口全限定名)，用于寻找服务接口，文件内容应该保存服务接口实现类的全限定名，也就是该类在jar包中的包名+类名    *</em></p>
<p>如：<code>JDBC-&gt;文件名：java.sql.Driver 文件内容：com.mysql.cj.jdbc.Driver</code></p>
<p>JDK就会去找到java.sql.Driver这个接口，然后找到文件内容中的在jar包中对应的com.mysql.cj.jdbc.Driver类作为该接口的实现</p>
{% qnimg jvm/6.png %}


<p>同一个服务的不同提供商将根据jdk SPI规范编写符合规范的实现类(对类没有要求，只需要实现接口就好了，但是需要添加<code>META-INF/services/服务限定名</code>文件，在其中每一行写服务提供商提供的类相应的在jar包目录下的全限定名)</p>
<h4 id="自定义SPI服务"><a href="#自定义SPI服务" class="headerlink" title="自定义SPI服务"></a>自定义SPI服务</h4><p>下面我们自己实现一个spi服务看一下它到底是如何运作的，写完之后我们再看源码</p>
<ul>
<li>首先我们编写一个服务接口，接口包路径全限定名<code>top.dzou.jvm.spi</code></li>
</ul>
<pre><code class="java">package top.dzou.jvm.spi;

public interface TestInterface {
    void saySomething();
}
</code></pre>
<ul>
<li>再编写两个不同的接口服务实现，模拟不同服务提供商提供的不同实现，包路径为<code>top.dzou.jvm.spi.impl</code></li>
</ul>
<pre><code class="java">package top.dzou.jvm.spi.impl;
public class ConcreteImpl1 implements TestInterface {
    @Override
    public void saySomething() {
        System.out.println(&quot;I am first service provider interface impl;&quot;);
    }
}</code></pre>
<pre><code class="java">package top.dzou.jvm.spi.impl;
public class ConcreteImpl2 implements TestInterface {
    @Override
    public void saySomething() {
        System.out.println(&quot;I am second service provider interface impl;&quot;);
    }
}</code></pre>
<ul>
<li>我们还需要编写配置文件，在classpath下的创建配置文件目录<code>META-INF/services</code>，配置文件名为接口包路径全限定名``top.dzou.jvm.spi.TestInterface`</li>
</ul>
<pre><code>top.dzou.jvm.spi.impl.ConcreteImpl1
top.dzou.jvm.spi.impl.ConcreteImpl2</code></pre><ul>
<li>编写一个测试类，使用<code>ServiceLoader</code></li>
</ul>
<pre><code class="java">public class TestSpi {
    public static void main(String[] args) {
        //Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader().getParent());
        ServiceLoader&lt;TestInterface&gt; loader = ServiceLoader.load(TestInterface.class);
        Iterator&lt;TestInterface&gt; iterator = loader.iterator();
        System.out.println(&quot;current class loaded by :&quot;+TestSpi.class.getClassLoader());
        System.out.println(&quot;current thread loader :&quot;+Thread.currentThread().getContextClassLoader());
        System.out.println(&quot;service interface loader :&quot;+loader.getClass().getClassLoader());
        while(iterator.hasNext()){
            TestInterface next = iterator.next();
            next.saySomething();
        }
    }
}

输出：
current class loaded by :sun.misc.Launcher$AppClassLoader@18b4aac2
current thread loader :sun.misc.Launcher$AppClassLoader@18b4aac2
service interface loader :null
I am first service provider interface impl;
I am second service provider interface impl;</code></pre>
<p>如果我们把main函数第一行之前加上一行</p>
<pre><code>Thread.currentThread().setContextClassLoader(ClassLoader.getSystemClassLoader().getParent());</code></pre><p>输出为</p>
<pre><code>current class loaded by :sun.misc.Launcher$AppClassLoader@18b4aac2
current thread loader :sun.misc.Launcher$ExtClassLoader@266474c2
service interface loader :null</code></pre><blockquote>
<p>解释：</p>
<p>你可以把我们写的接口实现看成是某个服务商提供者编写的jar包的类，把接口看成是JDK提供的服务接口，然后在jar包中的resource目录下的<code>META-INF/services</code>中编写了一个与JDK提供服务接口全限定名相同的配置文件，在其中配置了两个具体实现类的类全限定名，就可以通过ServiceLoader去使用这两个类作为JDK接口的实现类，我们在测试类中测试的结果可以看到除了ServiceLoader类由启动类加载器加载，线程和测试类都是通过系统类加载器加载的；</p>
<p><code>但是</code>当我们设置了扩展类为线程上文文类加载器的时候，可以看到打印结果是我们自己编写的服务接口实现没有被加载，那这是为什么？</p>
<p>答：很简单，因为ServiceLoader是通过上下文类加载器获取到系统类加载器的引用，通过系统类加载器来帮助我们实现访问服务实现的类，但是现在我们的上下文类加载器为扩展类加载器，显然扩展类加载器是加载和访问不了我们自己编写的服务实现类，所以自然没有打印处加载的信息，更没有去调用方法</p>
</blockquote>
<h4 id="SPI原理以及ServiceLoader源码分析"><a href="#SPI原理以及ServiceLoader源码分析" class="headerlink" title="SPI原理以及ServiceLoader源码分析"></a>SPI原理以及ServiceLoader源码分析</h4><p>我们通过上下文类加载器和自定义SPI实现大致已经知道SPI是怎么运作的了，我们下面看一下它的源码</p>
<blockquote>
<p>因为sun公司源码有些是不对外开放的，所以我们看一下反编译的源码就好了，大致都能理解</p>
</blockquote>
<ul>
<li>首先在ServiceLoader中有这样一段代码</li>
</ul>
<pre><code class="java">private static final String PREFIX = &quot;META-INF/services/&quot;;</code></pre>
<p><strong>现在我们就可以看懂这是什么了，为什么服务提供商都要在jar包中在classpath目录下编写这么一个目录，就是一个绝对路径，系统类加载器就是通过这个路径去寻找jar包中的服务接口实现类</strong></p>
<ul>
<li>我们再看一下自定义SPI实现的ServiceLoader.load()方法</li>
</ul>
<pre><code class="java">public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; var0) {
    ClassLoader var1 = Thread.currentThread().getContextClassLoader();//核心方法
    return load(var0, var1);
}</code></pre>
<p><strong>在load中ServiceLoader拿到了上下文类加载器，作为参数传入load方法</strong></p>
<pre><code class="java">private ServiceLoader(Class&lt;S&gt; var1, ClassLoader var2) {
        this.service = (Class)Objects.requireNonNull(var1, &quot;Service interface cannot be null&quot;);
        this.loader = var2 == null ? ClassLoader.getSystemClassLoader() : var2;
        this.acc = System.getSecurityManager() != null ? AccessController.getContext() : null;
        this.reload();
    }</code></pre>
<p><strong>load方法返回了一个ServiceLoader对象，构造方法把loader设置为了刚刚拿到的当前线程上下文类加载器</strong></p>
<ul>
<li>我们看一下使用<code>loader</code>的地方</li>
</ul>
<p>ServiceLoader维护了一个内部类<code>LazyIterator</code>实现了<code>Iterator</code>接口作为使用服务提供商在配置文件中编写的所有服务实现类的迭代器，看一下<code>hasNextService</code>方法，我把关键部分留了下来</p>
<pre><code class="java">private boolean hasNextService() {
    //关键是这里，反编译把常量直接加载过来了
    if (this.configs == null) {
        try {
            String var1 = &quot;META-INF/services/&quot; + this.service.getName();//这里service就是
            if (this.loader == null) {
                this.configs = ClassLoader.getSystemResources(var1);//一般不会来到这，如果出现异常来到这也要把loader设置为系统类加载器
            } else {
                this.configs = this.loader.getResources(var1);//使用系统类加载器根据jar包中路径获取资源，也就是使用服务实现
            }
        } catch (IOException var2) {
            ServiceLoader.fail(this.service, &quot;Error locating configuration files&quot;, var2);
        }

//下面使用迭代器，负责判断是否有其他服务实现
                while(this.pending == null || !this.pending.hasNext()) {
                    if (!this.configs.hasMoreElements()) {
                        return false;
                    }

                    this.pending = ServiceLoader.this.parse(this.service, (URL)this.configs.nextElement());
                }

                this.nextName = (String)this.pending.next();
                return true;
            }
        }</code></pre>
<p><strong>再看一下nextService()方法</strong></p>
<pre><code class="java">private S nextService() {
                String var1 = this.nextName;//拿到下一个服务类的类全限定名
                this.nextName = null;
                Class var2 = null;
                try {
                    var2 = Class.forName(var1, false, this.loader);//使用反射加载服务实现，loader为系统类加载器，var1为nextName就是服务类全限定名

                    Object var3 = this.service.cast(var2.newInstance());
                    ServiceLoader.this.providers.put(var1, var3);//加载成功放入Maop中
                    return var3;
                    }
        }</code></pre>
<img src="http://dzou.wangminwei.top/static/images/jvm/8.png">


<ul>
<li>我们看一下最根本的Launcher中的初始化方法，我们知道Launcher就是负责类加载器的加载，相当于应用的主启动类</li>
</ul>
<p>里面有这样一段代码</p>
<pre><code class="java">try {
        this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);
        } catch (IOException var9) {
            throw new InternalError(&quot;Could not create application class loader&quot;, var9);
        }

        Thread.currentThread().setContextClassLoader(this.loader);</code></pre>
<blockquote>
<p>它首先就是获取系统类加载器作为Launcher中把保存的loader引用，因为它是JDK最下面的类加载器。可以通过getParent方法获取上册加载器；并且调用了 Thread.currentThread().setContextClassLoader方法把系统类加载器设置为当前线程的上下文类加载器</p>
</blockquote>
<blockquote>
<p>SPI原理和ServiceLoader的源码讲完我们下面看一下SPI对服务接口的实际使用</p>
</blockquote>
<h3 id="SPI—JDBC加载分析"><a href="#SPI—JDBC加载分析" class="headerlink" title="SPI—JDBC加载分析"></a>SPI—JDBC加载分析</h3><p><strong>我们一般通过<code>Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</code>先使用加载当前类的加载器(也就是系统类加载器)加载该classpath下的mysql驱动</strong></p>
<img src="http://dzou.wangminwei.top/static/images/jvm/6.png">


<blockquote>
<p>现在我们再来看这张图片就能会容易理解了，配置文件的内容你可能也已经想到了，就是JDBC的mysql驱动</p>
<p><code>com.mysql.cj.jdbc.Driver</code>或者<code>com.mysql.jdbc.Driver</code></p>
</blockquote>
<ul>
<li>我们看一下这个mysql的Driver类</li>
</ul>
<pre><code class="java">public class Driver extends NonRegisteringDriver implements java.sql.Driver {
    public Driver() throws SQLException {
    }
    static {
        try {
            DriverManager.registerDriver(new Driver());
        } catch (SQLException var1) {
            throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);
        }
    }
}</code></pre>
<blockquote>
<p>我们在通过Class.forName加载完该Driver时会自动初始化该类，就会执行static语句块，自然就会加载引用的DriverManger，根据双亲委托模型，把加载DriverManager的任务交给启动器类加载器</p>
</blockquote>
<ul>
<li><strong>加载完成后继续执行上面static块会执行registerDriver方法，自然就会先初始化DriverManager，执行下述DriverManager的static块</strong></li>
</ul>
<pre><code class="java">static {
        loadInitialDrivers();
    }</code></pre>
<ul>
<li><strong>loadInitialDrivers</strong></li>
</ul>
<p>我们看一下它静态块中执行的初始化Driver的方法</p>
<pre><code class="java">private static void loadInitialDrivers() {
        String var0 = (String)AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() {
                public String run() {
                    return System.getProperty(&quot;jdbc.drivers&quot;);//如果存在系统的jdbc driver则返回，一般不存在，需要加载
                }
            });
        AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
            public Void run() {
                ServiceLoader var1 = ServiceLoader.load(Driver.class);//ServiceLoader加载java.sql.Driver
                Iterator var2 = var1.iterator();
                while(var2.hasNext()) {//通过hasNext调用hasNextService方法拿取配置文件中指定的类的资源
                    var2.next();//调用nextService方法会通过Class.forName()加载这个类
                }
            } 
                return null;
            }
        });
        if (var0 != null &amp;&amp; !var0.equals(&quot;&quot;)) {//如果System.getProperty(&quot;jdbc.drivers&quot;);中有驱动
            String[] var1 = var0.split(&quot;:&quot;);
            String[] var2 = var1;
            int var3 = var1.length;
            for(int var4 = 0; var4 &lt; var3; ++var4) {
                String var5 = var2[var4];
                println(&quot;DriverManager.Initialize: loading &quot; + var5);
                Class.forName(var5, true, ClassLoader.getSystemClassLoader());//尝试加载System.getProperty中的驱动
            }
        }
    }</code></pre>
<blockquote>
<p><strong>这么一看进行了很多次Class.forName()加载驱动，那我们为什么还需要手动调用<code>Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</code>？是不是可以不手动调用这一步？</strong></p>
<p>答案是可以的，我们手动调用这步是因为JDK以前还不支持这种做法，需要调用，但是后面版本的JDK中可以不需在调用这一句了，因为只要在classpath中，它就会在loadInitialDrivers中调用next中调用nextService方法中调用了这句Class.forName()</p>
</blockquote>
<ul>
<li><strong>加载了驱动后，下面我们再看一下它的获取连接的方法，里面还有与类加载有关的过程</strong></li>
</ul>
<p>String var0： 驱动类全限定名</p>
<p>Properties var1： 包含数据库连接参数的配置信息</p>
<p>Class var2： 反射拿到的调用getConnetion方法的类</p>
<p>关键代码如下</p>
<pre><code class="java">private static Connection getConnection(String var0, Properties var1, Class&lt;?&gt; var2) throws SQLException {
        ClassLoader var3 = var2 != null ? var2.getClassLoader() : null;//拿到加载调用类的类加载器，一般为系统类加载器
        Class var4 = DriverManager.class;
        synchronized(DriverManager.class) {
            if (var3 == null) {
                var3 = Thread.currentThread().getContextClassLoader();//如果不是系统类加载器就设置为当前线程的1类加载器，也就是存储的系统类加载器的引用
            }
        } 
            Iterator var5 = registeredDrivers.iterator();
            while(true) {
                while(var5.hasNext()) {//调用迭代器来加载驱动
                    DriverInfo var6 = (DriverInfo)var5.next();
                    if (isDriverAllowed(var6.driver, var3)) {//关键在这里
                        Connection var7 = var6.driver.connect(var0, var1);
                        if (var7 != null) {
                            return var7;
                        }
                    }
                }
            }
    }</code></pre>
<ul>
<li><strong>isDriverAllowed方法</strong></li>
</ul>
<p><strong>就是为了辨别驱动var0是否有var1(当前线程的类加载器、加载当前调用类的类加载器)所加载，也就是var0是否在var1类加载器的命名空间中</strong></p>
<blockquote>
<p>出现这种情况的原因：</p>
<p>1.上下文类加载器被设置为了高层的类加载器而不是系统类加载器</p>
<p>2.线程被切换了，当前线程的上下文类加载器不是加载调用类的类加载器</p>
</blockquote>
<p><strong>不同的类加载器对应不同的命名空间，这样的话，上下文类加载器引用的类加载器无法加载该驱动，也就无法使用该驱动</strong></p>
<pre><code class="java">private static boolean isDriverAllowed(Driver var0, ClassLoader var1) {
    boolean var2 = false;
    if (var0 != null) {
        Class var3 = null;
        try {
            var3 = Class.forName(var0.getClass().getName(), true, var1);
        } catch (Exception var5) {
            var2 = false;//如果异常发生，表示无法由var0加载var1，命名空间不同
        }
        var2 = var3 == var0.getClass();//否则只需要判断加载的类和var0驱动类是否是一个类
    }
    return var2;
}</code></pre>
<h3 id="Tomcat加载简要分析"><a href="#Tomcat加载简要分析" class="headerlink" title="Tomcat加载简要分析"></a>Tomcat加载简要分析</h3><h4 id="Web服务器加载需求"><a href="#Web服务器加载需求" class="headerlink" title="Web服务器加载需求"></a>Web服务器加载需求</h4><ul>
<li>部署在同一个服务器的两个web应用程序使用的java类库相互隔离，两个不同的应用程序也可以依赖用一个第三方类库的不用版本，所以一个类库只能在一个应用程序中可见</li>
<li>部署在一个服务器上的两个web应用可以共享Java类库，10个依赖Spring，那么10个应用都需要一个独立的Spring？显然是不需要的</li>
<li>为了安全性，服务器所使用的类库应该与应用程序类库隔离</li>
<li>像JSP这种文件，需要支持动态热更新，JSP修改后无需重启服务器，只需要刷新页面就可以了</li>
</ul>
<h4 id="tomcat加载模型"><a href="#tomcat加载模型" class="headerlink" title="tomcat加载模型"></a>tomcat加载模型</h4><p>我们在上述情况下思考一下双亲委托模型可以实现吗？</p>
<p>显然不行，所以tomcat创建了自己的一套加载模型，如下：</p>
<img src="http://dzou.wangminwei.top/static/images/JVM/7.png">

<ol>
<li><code>common类加载器</code>就是负责加载服务器和应用程序都可以共享的类库，如classpath下的lib目录</li>
<li><code>catalina类加载器</code>负责加载服务器独立的类库，为了安全性不与应用程序共享的类库</li>
<li><code>shared类加载器</code>就负责加载应用程序之间共享的类库，像是Spring这样的</li>
<li><code>WebApp类加载器</code>加载单个应用程序独立的类库，对其他应用程序不可见，如webapp下类库</li>
<li><code>jsp类加载器</code>负责jsp文件加载成servlet类，它需要解决<code>热更新</code>的问题</li>
</ol>
<h4 id="JSP文件的热更新加载"><a href="#JSP文件的热更新加载" class="headerlink" title="JSP文件的热更新加载"></a>JSP文件的热更新加载</h4><p><strong>我们知道一般加载过程，创建一个JSP页面，启动服务器时由加载器加载成servlet类字节码文件，但是当你JSP内容修改了以后，就相当于类文件被修改了，这个时候我们只能重新启动应用程序来再次加载这个类来实现修改后的更新，但是如果是这样的话就没有人使用<code>JSP</code>了</strong></p>
<blockquote>
<p>tomcat考虑到了这一点，提出了一种<code>一个类加载器对应一个JSP文件</code>的实现方法</p>
</blockquote>
<p><strong>我们每次为JSP文件加载创建一个特定的加载器，每个JSP就有一个类加载器，当我们在运行时发现JSP被修改了的话，我们就丢弃那个加载出来的Class文件，通过重新建立一个新的JSP类加载器来加载更新的JSP文件</strong></p>
<blockquote>
<p>为了实现不同应用程序隔离，服务器和应用程序隔离，就不同在使用双亲委托模型，它会把所有加载交给父类，而保证每个类有且仅由一个，所以tomcat不得不<code>破坏双亲委托模型</code>，但它只是没有遵循交给上层加载的规定，加载模型还是自上而下的</p>
</blockquote>
<p><strong>Tomcat决定把webapp目录下的类由自己的WebappClassLoader加载，不委托给父类加载器，然后通过舞弊的<code>上下文类加载器</code>来实现父加载器对子类加载器加载的类的访问与可见性</strong></p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    dzou  |  微信：17856530567
  </li>
  <li class="post-copyright-link">
  <strong>本文链接：</strong>
  <a href="http://www.dzou.top/post/jvm-classload.html" title="深入理解Java虚拟机之—JVM类加载过程和类加载器">http://www.dzou.top/post/jvm-classload.html</a>
</li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
  </li>
  <li class="post-copyright-license">
    并保留本声明和上方二维码。感谢您的阅读和支持！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/基础/" rel="tag"># 基础</a>
          
            <a href="/tags/面试/" rel="tag"># 面试</a>
          
            <a href="/tags/源码/" rel="tag"># 源码</a>
          
            <a href="/tags/jvm/" rel="tag"># jvm</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        

        

        
          
          <div id="needsharebutton-postbottom">
            <span class="btn">
              <i class="fa fa-share-alt" aria-hidden="true"></i>
            </span>
          </div>
        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/post/napzack-algorithm.html" rel="next" title="动态规划—搞懂01背包和完全背包算法">
                <i class="fa fa-chevron-left"></i> 动态规划—搞懂01背包和完全背包算法
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript" rel="external nofollow noopener noreferrer" target="_blank">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/2.JPG" alt="dzou">
            
              <p class="site-author-name" itemprop="name">dzou</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">80</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">93</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/ding-zou" target="_blank" title="GitHub" rel="external nofollow noopener noreferrer">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="dingxiang.zoufubo@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://me.csdn.net/qq_44760332" target="_blank" title="CSDN" rel="external nofollow noopener noreferrer">
                      
                        <i class="fa fa-fw fa-copyright"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                推荐链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.dzou.top/post/7a5625fe.html" title="Java并发之AQS源码分析" target="_blank">Java并发之AQS源码分析</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.dzou.top/post/366ffd58.html" title="SpringBoot自动配置原理-源码分析" target="_blank">SpringBoot自动配置原理-源码分析</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.dzou.top/post/712f837.html" title="Java Web安全框架Shiro使用" target="_blank">Java Web安全框架Shiro使用</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.dzou.top/post/19e1cc75.html" title="Linux基础命令" target="_blank">Linux基础命令</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.dzou.top/post/8184a8fd.html" title="JDK8新特性——流和Lambda表达式" target="_blank">JDK8新特性——流和Lambda表达式</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://music.163.com/#/user/home?id=564117665" title="网易云音乐" target="_blank" rel="external nofollow noopener noreferrer">网易云音乐</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#深入理解Java虚拟机之—JVM类加载过程和类加载器"><span class="nav-number">1.</span> <span class="nav-text">深入理解Java虚拟机之—JVM类加载过程和类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#类加载"><span class="nav-number">1.1.</span> <span class="nav-text">类加载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-加载"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-连接"><span class="nav-number">1.1.2.</span> <span class="nav-text">2.连接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-验证"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">(1)验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-准备"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">(2)准备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-解析"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">(3)解析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-初始化"><span class="nav-number">1.1.3.</span> <span class="nav-text">3.初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#双亲委托机制"><span class="nav-number">1.1.4.</span> <span class="nav-text">双亲委托机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#面试题："><span class="nav-number">1.1.4.0.1.</span> <span class="nav-text">面试题：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类加载器剖析"><span class="nav-number">1.2.</span> <span class="nav-text">类加载器剖析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类加载器"><span class="nav-number">1.2.1.</span> <span class="nav-text">类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命名空间"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">命名空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#命名空间使用"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">命名空间使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#继承关系"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">继承关系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#上下文类加载器"><span class="nav-number">1.2.2.</span> <span class="nav-text">上下文类加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SPI加载以及破坏双亲委派模型"><span class="nav-number">1.2.3.</span> <span class="nav-text">SPI加载以及破坏双亲委派模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ServiceLoader"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">ServiceLoader</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义SPI服务"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">自定义SPI服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SPI原理以及ServiceLoader源码分析"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">SPI原理以及ServiceLoader源码分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SPI—JDBC加载分析"><span class="nav-number">1.2.4.</span> <span class="nav-text">SPI—JDBC加载分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tomcat加载简要分析"><span class="nav-number">1.2.5.</span> <span class="nav-text">Tomcat加载简要分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Web服务器加载需求"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">Web服务器加载需求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tomcat加载模型"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">tomcat加载模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JSP文件的热更新加载"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">JSP文件的热更新加载</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dzou</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">122.5k</span>
  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问用户：
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问次数：
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    

    
      <div id="needsharebutton-float">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://dzou.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://www.dzou.top/post/jvm-classload.html';
          this.page.identifier = 'post/jvm-classload.html';
          this.page.title = '深入理解Java虚拟机之—JVM类加载过程和类加载器';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://dzou.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.4"></script>



  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "box";
      
          pbOptions.boxForm = "horizontal";
      
          pbOptions.position = "topCenter";
      
          pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
      flOptions = {};
      
          flOptions.iconStyle = "box";
      
          flOptions.boxForm = "horizontal";
      
          flOptions.position = "topRight";
      
          flOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-float', flOptions);
    
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

  

  

  

  


</body>
</html>
<script type="text/javascript" src="/js/src/dynamic_bg.js"></script>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
<script type="text/javascript" src="/js/google-code-prettify/prettify.js"></script>
<script type="text/javascript">
$(window).load(function(){
   $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');
   prettyPrint();
 })    
</script>

