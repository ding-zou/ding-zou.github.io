<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dzou&#39;s Blog</title>
  
  <subtitle>No pains,no gains.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.dzou.top/"/>
  <updated>2019-08-16T13:53:23.156Z</updated>
  <id>https://www.dzou.top/</id>
  
  <author>
    <name>dzou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java设计模式总结</title>
    <link href="https://www.dzou.top/post/2c936afd.html"/>
    <id>https://www.dzou.top/post/2c936afd.html</id>
    <published>2019-08-16T13:52:12.000Z</published>
    <updated>2019-08-16T13:53:23.156Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式总结"><a href="#Java设计模式总结" class="headerlink" title="Java设计模式总结"></a>Java设计模式总结</h2><p><strong>模式：在某种<code>情景</code>下，针对某<code>问题</code>的<code>解决方案</code>。</strong></p><ul><li>情景：应用某个设计模式的情况。</li><li>问题：要达到的目标。</li><li>解决方案：解决约束，达到目标的设计。</li></ul><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>设计原则：</p><ul><li>类应该对扩展开放，对修改关闭</li><li>把变化的抽取出来，不要和不变化的放在一起。</li><li>针对接口编程，不针对实现编程。</li><li>多用组合，少用继承。</li><li>单一原则：一个类应该只有一个引起变化的原因。</li><li>依赖倒置：要依赖抽象，不依赖具体类。</li><li>为了交互对象之间的松耦合的设计而努力。</li><li>好莱坞原则：别调用我们，我们会调用你。</li><li>最少设计原则：只和你的密友谈话(减少耦合)。</li></ul><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/38.png"><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/39.png">]]></content>
    
    <summary type="html">
    
      模式：在某种`情景`下，针对某`问题`的`解决方案`。设计原则总结。模式分类。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式——中介者模式</title>
    <link href="https://www.dzou.top/post/6c0cb1a1.html"/>
    <id>https://www.dzou.top/post/6c0cb1a1.html</id>
    <published>2019-08-16T13:50:23.000Z</published>
    <updated>2019-08-16T13:51:20.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之中介者模式"><a href="#Java设计模式之中介者模式" class="headerlink" title="Java设计模式之中介者模式"></a>Java设计模式之中介者模式</h2><p><strong><em>中介者模式：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</em></strong></p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/34.png"><p>角色：</p><ul><li><strong>Mediator（抽象中介者）</strong>：该接口用于与各同事对象之间进行通信。</li><li><strong>ConcreteMediator（具体中介者）</strong>：它是抽象中介者的子类，通过协调各个同事对象来实现协作行为，它维持了对各个同事对象的引用。</li><li><strong>Colleague（抽象同事类）</strong>：它定义各个同事类公有的方法，并声明了一些抽象方法来供子类实现，同时它维持了一个对抽象中介者类的引用，其子类可以通过该引用来与中介者通信。</li><li><strong>ConcreteColleague（具体同事类）</strong>：它是抽象同事类的子类；每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信。</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><strong>一个相亲中介所负责处理相亲者的约会请求和被约会对象的回应。</strong></p><p>如果让他们各自联系并进行约会，耗时长，还混乱，所以我们使用<code>中介者模式</code></p><ul><li>Mediator 中介类</li></ul><pre><code class="java">/** * 中介者抽象类 */public abstract class Mediator {    public abstract void register(DatingPerson person);//注册到中介所    public abstract void response(String datingPerson,String datedPerson);//回应相亲对象的是否接受}</code></pre><ul><li>DatingPerson 相亲的人 同事抽象类</li></ul><pre><code class="java">/** * 相亲的人抽象类 */public abstract class DatingPerson {    protected Mediator mediator;//保存中介所的引用    protected String name;//名字    public String getName(){        return name;    }    //相亲操作，调用的对象与传入参数名字的人发起约会请求，中介所处理，都相同所以写在抽象类实现中    public void makeOneDate(String datePersonName){        System.out.println(&quot;我想和 &quot;+datePersonName+&quot; 约个会&quot;);        mediator.response(this.getName(),datePersonName);    }    //接受    public void accept(String name){        System.out.println(&quot;我接受这次和 &quot;+name+&quot; 约会\n&quot;);    }    //拒绝    public void refuse(String name) {        System.out.println(&quot;我不想和 &quot;+name+&quot; 约会\n&quot;);    }}</code></pre><ul><li>PersonA 具体同事类</li></ul><blockquote><p>创建时调用构造方法传入中介所并注册</p></blockquote><pre><code class="java">public class PersonA extends DatingPerson {    public PersonA(Mediator mediator) {        this.mediator = mediator;        name = &quot;a&quot;;        this.mediator.register(this);    }}</code></pre><ul><li>PersonB 具体同事类</li></ul><pre><code class="java">public class PersonB extends DatingPerson {    public PersonB(Mediator mediator) {        this.mediator = mediator;        name = &quot;b&quot;;        this.mediator.register(this);    }}</code></pre><ul><li>PersonC 具体同事类</li></ul><pre><code class="java">public class PersonC extends DatingPerson{    public PersonC(Mediator mediator){        this.mediator = mediator;        name = &quot;c&quot;;        this.mediator.register(this);    }}</code></pre><ul><li>PersonD 具体同事类</li></ul><pre><code class="java">public class PersonD extends DatingPerson{    public PersonD(Mediator mediator){        this.mediator = mediator;        name = &quot;d&quot;;        this.mediator.register(this);    }}</code></pre><ul><li>DateMediator 相亲中介所 中介实现类</li></ul><pre><code class="java">/** * 相亲中介所 */public class DateMediator extends Mediator{    private Map&lt;String,DatingPerson&gt; datingPeople;//存放所有要相亲的人    public DateMediator(){        datingPeople = new HashMap&lt;&gt;();    }    //把要相亲的人注册到中介所    public void register(DatingPerson person) {        datingPeople.put(person.getName(),person);    }    //回应约会请求    @Override    public void response(String datingPerson,String datedPerson) {        DatingPerson person = datingPeople.get(datedPerson);//获取被约会对象        if(datingPerson.equals(&quot;c&quot;)){//所有人都不想和c约会            person.refuse(datingPerson);//被约会对象拒绝        }else {            person.accept(datingPerson);//被约会对象接受        }    }}</code></pre><ul><li>测试</li></ul><pre><code class="java">public class ClientTest {    public static void main(String[] args) {        Mediator mediator = new DateMediator();        DatingPerson a = new PersonA(mediator);        DatingPerson b = new PersonB(mediator);        DatingPerson c = new PersonC(mediator);        DatingPerson d = new PersonD(mediator);        a.makeOneDate(&quot;c&quot;);        b.makeOneDate(&quot;d&quot;);        c.makeOneDate(&quot;d&quot;);        d.makeOneDate(&quot;a&quot;);    }}输出：我想和 c 约个会我接受这次和 a 约会我想和 d 约个会我接受这次和 b 约会我想和 d 约个会我不想和 c 约会我想和 a 约个会我接受这次和 d 约会</code></pre><blockquote><p>MVC模式中<code>Controller</code>就是中介者</p></blockquote><p>中介者模式优点：</p><ul><li>同事间的解耦，他们只需要保存中介者的引用</li><li>同事间传递消息变得简单，系统易于维护</li></ul><p>代码地址：<a href="https://github.com/ding-zou/design_patterns/tree/master/mediator_patterns" rel="external nofollow noopener noreferrer" target="_blank">Github中介者模式</a></p>]]></content>
    
    <summary type="html">
    
      中介者模式：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式——责任链模式</title>
    <link href="https://www.dzou.top/post/de32d4c3.html"/>
    <id>https://www.dzou.top/post/de32d4c3.html</id>
    <published>2019-08-16T13:49:25.000Z</published>
    <updated>2019-08-16T13:50:04.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之责任链模式"><a href="#Java设计模式之责任链模式" class="headerlink" title="Java设计模式之责任链模式"></a>Java设计模式之责任链模式</h2><p><strong><em>责任链模式：为某个请求创建一个对象链，每个对象义序检查此请求，并对其进行处理，或者将其出给链中下一个对象。</em></strong></p><ul><li>Handler：抽象的处理对象接口</li><li>ConcreteHandler：具体的处理对象，有多个构成对象链，每个处理对象持有下一个处理对象的引用</li></ul><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/31.png"><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>场景：一个公司的邮件分为三类：</p><ul><li>粉丝发的：交给老板处理</li><li>抱怨产品的：交给产品部处理</li><li>垃圾邮件：交给管理员处理</li></ul><blockquote><p>先交给<code>管理员</code>处理，处理不了传给<code>产品部</code>，处理不了传给<code>老板</code>处理，<code>责任链：管理员—&gt;产品部—&gt;老板</code></p></blockquote><p>代码：</p><ul><li>EmailHandler 抽象邮件处理类接口</li></ul><pre><code class="java">public abstract class EmailHandler {    private EmailHandler nextHandler;//链中下一个处理对象    public void setNextHandler(EmailHandler handler){        this.nextHandler = handler;    }    public EmailHandler getNextHandler(){        return nextHandler;    }    public abstract void handlerEmail(Email email);}</code></pre><ul><li>ComplainEmailHandler 抱怨邮件处理类</li></ul><pre><code class="java">public class ComplainEmailHandler extends EmailHandler{    public void handlerEmail(Email email) {        if(email.equals(Email.COMPLAIN)){            System.out.println(&quot;这封邮件是：&quot;+email.getKind());            System.out.println(&quot;交给产品部处理&quot;);        }else {            getNextHandler().handlerEmail(email);        }    }}</code></pre><ul><li>FansEmailHandler 粉丝邮件处理类</li></ul><pre><code class="java">public class FansEmailHandler extends EmailHandler{    public void handlerEmail(Email email) {        if(email.equals(Email.FANS)){            System.out.println(&quot;这封邮件是：&quot;+email.getKind());            System.out.println(&quot;交给老板处理&quot;);        }    }}</code></pre><ul><li>TrashEmailHandler 垃圾邮件处理类</li></ul><pre><code class="java">public class TrashEmailHandler extends EmailHandler{    public void handlerEmail(Email email) {        if(email.equals(Email.TRASH)){            System.out.println(&quot;这封邮件是：&quot;+email.getKind());            System.out.println(&quot;交给管理员处理&quot;);        }else {            getNextHandler().handlerEmail(email);        }    }}</code></pre><ul><li>Email 邮件枚举类</li></ul><pre><code class="java">public enum Email {    FANS(1,&quot;粉丝邮件&quot;),    COMPLAIN(2,&quot;抱怨产品邮件&quot;),    TRASH(3,&quot;垃圾邮件&quot;);    private int i;    private String kind;    Email(int i, String kind) {        this.i = i;        this.kind = kind;    }    public String getKind(){        return kind;    }}</code></pre><ul><li>Test测试</li></ul><pre><code class="java">public class Test {    //设置处理链    public static EmailHandler getAndsetEmailHandlerChain(){        EmailHandler fansHandler  = new FansEmailHandler();        EmailHandler complainHandler = new ComplainEmailHandler();        EmailHandler trashHandler = new TrashEmailHandler();        trashHandler.setNextHandler(complainHandler);        complainHandler.setNextHandler(fansHandler);        return trashHandler;    }    public static void main(String[] args) {        EmailHandler firstHandler = Test.getAndsetEmailHandlerChain();        firstHandler.handlerEmail(Email.COMPLAIN);        System.out.println(&quot;\n&quot;);        firstHandler.handlerEmail(Email.FANS);        System.out.println(&quot;\n&quot;);        firstHandler.handlerEmail(Email.TRASH);    }}输出：这封邮件是：抱怨产品邮件交给产品部处理这封邮件是：粉丝邮件交给老板处理这封邮件是：垃圾邮件交给管理员处理</code></pre><blockquote><p>tomcat的过滤器就是使用责任链模式</p><pre><code class="java">public void doFilter(ServletRequest request, ServletResponse response,         FilterChain chain) throws IOException, ServletException {     chain.doFilter(request, response); }</code></pre></blockquote><p>责任链模式优点：</p><ul><li>将请求发送者和接收者解耦</li><li>可以动态改变链顺序</li></ul><p>代码地址：<a href="https://github.com/ding-zou/design_patterns/tree/master/chain_of_response_patterns" rel="external nofollow noopener noreferrer" target="_blank">Github责任链模式</a></p>]]></content>
    
    <summary type="html">
    
      责任链模式：为某个请求创建一个对象链，每个对象义序检查此请求，并对其进行处理，或者将其出给链中下一个对象。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式——原型模式</title>
    <link href="https://www.dzou.top/post/8fcaf333.html"/>
    <id>https://www.dzou.top/post/8fcaf333.html</id>
    <published>2019-08-16T13:48:18.000Z</published>
    <updated>2019-08-16T13:49:08.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之原型模式"><a href="#Java设计模式之原型模式" class="headerlink" title="Java设计模式之原型模式"></a>Java设计模式之原型模式</h2><p><strong><em>原型模式：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。</em></strong></p><p>较为简单，经常与其他模式一同使用</p><ul><li>实现<code>Cloneable</code>接口，重写<code>clone</code>方法</li></ul><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/36.png"><blockquote><p>原型模式设计到深拷贝和浅拷贝</p></blockquote><h4 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h4><ul><li>深拷贝：对基本数据类型进行值传递，<code>对引用数据类型，创建一个新的对象，并复制其内容</code>，也就是使用<code>clone</code>方法后创建一个新的内存空间存储引用。</li><li>浅拷贝：对基本数据类型进行值传递，<code>对引用数据类型进行引用传递般的拷贝</code>，也就是使用<code>clone</code>方法后基本类型值相同，引用类型引用地址相同，指向同一个原型。</li></ul><p><strong>深拷贝与浅拷贝问题中，会发生深拷贝的有java中的8中基本类型以及他们的封装类型，另外还有String类型。其余的都是浅拷贝。</strong></p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>场景：绵羊有颜色、名字和年龄三个成员变量，其中<code>颜色是具体的类对象</code>，名字和年龄是<code>String</code>，我们知道String会发生深拷贝，但是颜色对象是浅拷贝，我们现在尝试使用原型模式创建<code>两只克隆羊</code></p><h5 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><ul><li>Color 颜色</li></ul><pre><code class="java">/** * 颜色 */public class Color implements Cloneable {    private String color;    public Color(String color) {        this.color = color;    }    public String getColor() {        return color;    }    //重写clone方法    @Override    protected Object clone() throws CloneNotSupportedException {        Color color = null;        color = (Color) super.clone();        return color;    }}</code></pre><ul><li>Sheep 绵羊类 </li></ul><p>使用了<code>lombok</code>插件提供<code>getter/setter</code>、<code>构造方法</code>，不会自行百度</p><pre><code class="java">@Data@AllArgsConstructorpublic class Sheep implements Cloneable{    private Color color;//保存引用 非基本类型    private String name;    private String age;    @Override    public String toString() {        return &quot;Sheep{&quot; +                &quot;color=&quot; + color.getColor() +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&#39;&quot; + age + &#39;\&#39;&#39; +                &#39;}&#39;;    }    @Override    protected Object clone() throws CloneNotSupportedException {        Sheep sheep = null;        sheep = (Sheep) super.clone();        return sheep;    }}</code></pre><ul><li>测试</li></ul><pre><code class="java">public class ClientTest {    public static void main(String[] args) throws CloneNotSupportedException {        Color color = new Color(&quot;white&quot;);        Sheep sheep = new Sheep(color,&quot;小白&quot;,&quot;12&quot;);        Sheep cloneSheep1 = (Sheep) sheep.clone();        Sheep cloneSheep2 = (Sheep) sheep.clone();        System.out.println(&quot;sheep:&quot;+sheep);        System.out.println(&quot;cloneSheep1:&quot;+cloneSheep1);        System.out.println(&quot;cloneSheep2:&quot;+cloneSheep2);        System.out.println(&quot;\n&quot;);        System.out.println(&quot;cloneSheep1是否等于sheep：&quot;+ (cloneSheep1 == sheep));        System.out.println(&quot;cloneSheep1是否等于cloneSheep2：&quot;+ (cloneSheep1 == cloneSheep2));        System.out.println(&quot;\n&quot;);        System.out.println(&quot;sheep中非基本类型Color是否与cloneSheep1中Color相等：&quot;+(sheep.getColor()==cloneSheep1.getColor()));        System.out.println(&quot;cloneSheep2中非基本类型Color是否与cloneSheep1中Color相等：&quot;+(cloneSheep2.getColor()==cloneSheep1.getColor()));    }}输出：sheep:Sheep{color=white, name=&#39;小白&#39;, age=&#39;12&#39;}cloneSheep1:Sheep{color=white, name=&#39;小白&#39;, age=&#39;12&#39;}cloneSheep2:Sheep{color=white, name=&#39;小白&#39;, age=&#39;12&#39;}cloneSheep1是否等于sheep：falsecloneSheep1是否等于cloneSheep2：falsesheep中非基本类型Color是否与cloneSheep1中Color相等：truecloneSheep2中非基本类型Color是否与cloneSheep1中Color相等：true</code></pre><blockquote><p>说明浅拷贝复制的对象是不同的，但是对象中的<code>引用型</code>成员变量指向同一个引用</p></blockquote><h5 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h5><blockquote><p>深拷贝有两种方法：<code>序列化</code>和<code>更改clone方法</code></p></blockquote><ul><li>Color 颜色</li></ul><pre><code class="java">@AllArgsConstructor@Datapublic class Color implements Serializable,Cloneable {    private String color;    @Override    protected Object clone() throws CloneNotSupportedException {        Color color = null;        color = (Color) super.clone();        return color;    }}</code></pre><ul><li>DeepCloneSheep</li></ul><pre><code class="java">/** * 深拷贝绵羊，让它的颜色Color拷贝时创建新的引用 */@Data@AllArgsConstructorpublic class DeepCloneSheep implements Serializable,Cloneable {    private Color color;//保存引用 非基本类型    private String name;//String类型    private String age;    /**     * 深克隆方法一 修改clone方法     * @return     * @throws CloneNotSupportedException     */    @Override    protected Object clone() throws CloneNotSupportedException {        DeepCloneSheep sheep = null;        sheep = (DeepCloneSheep) super.clone();//sheep先克隆        sheep.color = (Color) color.clone();//其中非基本类型再克隆        return sheep;    }    /**     * 方法2.使用序列化     * @return     */    public Object deepClone(){        Object o = null;        ByteArrayOutputStream bos;        ObjectOutputStream oos;        ByteArrayInputStream bis;        ObjectInputStream ois;        try{            //序列化 对象流            bos = new ByteArrayOutputStream();            oos = new ObjectOutputStream(bos);            oos.writeObject(this);            //反序列化            bis = new ByteArrayInputStream(bos.toByteArray());            ois = new ObjectInputStream(bis);            o = ois.readObject();            bos.close();            bis.close();            ois.close();            bis.close();        } catch (ClassNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }        return o;    }    @Override    public String toString() {//重写toString打印颜色        return &quot;DeepCloneSheep{&quot; +                &quot;color=&quot; + color.getColor() +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&#39;&quot; + age + &#39;\&#39;&#39; +                &#39;}&#39;;    }}</code></pre><ul><li>测试</li></ul><pre><code class="java">public class ClientTest {    @Test//方法一：修改clone，让颜色也被clone    public void testCloneMethod1() throws CloneNotSupportedException {        Color color = new Color(&quot;white&quot;);        DeepCloneSheep sheep = new DeepCloneSheep(color,&quot;小白&quot;,&quot;12&quot;);        DeepCloneSheep cloneSheep1 = (DeepCloneSheep) sheep.clone();        DeepCloneSheep cloneSheep2 = (DeepCloneSheep) sheep.clone();        System.out.println(&quot;sheep:&quot;+sheep);        System.out.println(&quot;cloneSheep1:&quot;+cloneSheep1);        System.out.println(&quot;cloneSheep2:&quot;+cloneSheep2+&quot;\n&quot;);        System.out.println(&quot;方法一：修改clone方法&quot;);        System.out.println(&quot;cloneSheep1是否等于sheep：&quot;+ (cloneSheep1 == sheep));        System.out.println(&quot;cloneSheep1是否等于cloneSheep2：&quot;+ (cloneSheep1 == cloneSheep2)+&quot;\n&quot;);        System.out.println(&quot;sheep中非基本类型Color是否与cloneSheep1中Color相等：&quot;+(sheep.getColor()==cloneSheep1.getColor()));        System.out.println(&quot;cloneSheep2中非基本类型Color是否与cloneSheep1中Color相等：&quot;+(cloneSheep2.getColor()==cloneSheep1.getColor())+&quot;\n&quot;);    }//方法二：序列化    @Test    public void testCloneMethod2(){        Color color = new Color(&quot;white&quot;);        DeepCloneSheep sheep = new DeepCloneSheep(color,&quot;小白&quot;,&quot;12&quot;);        DeepCloneSheep cloneSheep3 = (DeepCloneSheep) sheep.deepClone();        DeepCloneSheep cloneSheep4 = (DeepCloneSheep) sheep.deepClone();        System.out.println(&quot;sheep:&quot;+sheep);        System.out.println(&quot;cloneSheep3:&quot;+cloneSheep3);        System.out.println(&quot;cloneSheep4:&quot;+cloneSheep4+&quot;\n&quot;);        System.out.println(&quot;方法二：序列化方法&quot;);        System.out.println(&quot;cloneSheep3是否等于sheep：&quot;+ (cloneSheep3 == sheep));        System.out.println(&quot;cloneSheep3是否等于cloneSheep4：&quot;+ (cloneSheep3 == cloneSheep4)+&quot;\n&quot;);        System.out.println(&quot;sheep中非基本类型Color是否与cloneSheep3中Color相等：&quot;+(sheep.getColor()==cloneSheep3.getColor()));        System.out.println(&quot;cloneSheep3中非基本类型Color是否与cloneSheep4中Color相等：&quot;+(cloneSheep3.getColor()==cloneSheep4.getColor()));    }}</code></pre><p>输出：两种方法输出一样</p><pre><code class="java">sheep:DeepCloneSheep{color=white, name=&#39;小白&#39;, age=&#39;12&#39;}cloneSheep1:DeepCloneSheep{color=white, name=&#39;小白&#39;, age=&#39;12&#39;}cloneSheep2:DeepCloneSheep{color=white, name=&#39;小白&#39;, age=&#39;12&#39;}cloneSheep1是否等于sheep：falsecloneSheep1是否等于cloneSheep2：falsesheep中非基本类型Color是否与cloneSheep1中Color相等：falsecloneSheep2中非基本类型Color是否与cloneSheep1中Color相等：false</code></pre><blockquote><p>可以看到，深拷贝中引用类型<code>颜色</code>在clone过程中没有再指向同一引用</p></blockquote><h4 id="Spring中原型模式使用"><a href="#Spring中原型模式使用" class="headerlink" title="Spring中原型模式使用"></a>Spring中原型模式使用</h4><blockquote><p>我们都知道在Spring中，创建bean的scope域可以为<code>Singleton</code>或者是<code>protoType</code>，这就是使用到了原型模式</p></blockquote><p>我们创建一个<code>Conponent</code>，使用xml配置声明为<code>原型模式protoType</code>，加入到容器，我们获取两次该Bean看它们是否相等</p><pre><code class="java">@Componentpublic class Bean {}</code></pre><pre><code class="xml">&lt;bean id=&quot;bean&quot; scope=&quot;prototype&quot; name=&quot;bean&quot; class=&quot;top.dzou.prototype_pattern.spring.Bean&quot;/&gt;</code></pre><p>测试：</p><pre><code class="java">public class SpringBeanTest {    public static void main(String[] args) {        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);        Object bean = context.getBean(&quot;bean&quot;);//获取该bean        Object bean2 = context.getBean(&quot;bean&quot;);//再获取一个        //打印是否相等，测试原型模式        //调用BeanFactory中 doGetBean方法 其中判断是否为if (mbd.isPrototype())        System.out.println(&quot;bean是否等于bean2：&quot;+(bean==bean2));    }}</code></pre><p>输出：<code>bean是否等于bean2：false</code></p><p>源码：</p><p>调用<code>getBean</code>时调用了<code>AbstractBeanFactory</code>类中的<code>doGetBean</code>方法，其中有下面部分代码</p><pre><code class="java">if (mbd.isSingleton()) {//判断是否为单例模式                    bean = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);                } else if (mbd.isPrototype()) {//判断是否为原型模式                        this.beforePrototypeCreation(beanName);                        prototypeInstance = this.createBean(beanName, mbd, args);</code></pre><blockquote><p>这就是Spring中<code>原型模式</code>的使用，当然也使用了单例模式</p></blockquote><p><strong>原型模式优点：</strong></p><ul><li>某些情况，复制对象比创建对象更有效，<code>clone</code>方法是本地方法，直接操作内存，比创建对象高效不少</li><li>简化对象的创建，不被构造方法束缚</li></ul><p>代码地址：<a href="https://github.com/ding-zou/design_patterns/tree/master/prototype_patterns" rel="external nofollow noopener noreferrer" target="_blank">Github原型模式</a></p>]]></content>
    
    <summary type="html">
    
      原型模式：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式——享元模式(蝇量模式)</title>
    <link href="https://www.dzou.top/post/12fa71d.html"/>
    <id>https://www.dzou.top/post/12fa71d.html</id>
    <published>2019-08-16T13:46:55.000Z</published>
    <updated>2019-08-16T13:48:01.757Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之蝇量模式-享元模式"><a href="#Java设计模式之蝇量模式-享元模式" class="headerlink" title="Java设计模式之蝇量模式(享元模式)"></a>Java设计模式之蝇量模式(享元模式)</h2><p>蝇量可以理解为很小的数量，享元可以理解为共享的元素；通过这两个理解，我们初步可以知道该模式就是把<code>对象的数量减少，让他们之间可以共享使用</code></p><p><strong><em>享元模式：让一个类的实例可以提供多个“虚拟实例”，创建较少的对象实例，多与工厂模式一起使用。</em></strong></p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/32.png"><ul><li>内部状态：不会变化的状态，可以共享的状态</li><li>外部状态：会随着对象不同二有不同的状态，不可以共享的状态</li></ul><p>角色：</p><ul><li><strong>Flyweight（抽象享元类）</strong>：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法</li><li><strong>ConcreteFlyweight（具体享元类）</strong>：它实现了抽象享元类，其实例称为享元对象</li><li><strong>UnsharedConcreteFlyweight（非共享具体享元类）</strong>：不能被共享的子类可设计为非共享具体享元类</li><li><strong>FlyweightFactory（享元工厂类）</strong>：享元工厂类用于创建并管理享元对象，它针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中，如果存在需要的对象就从池中拿(Map)，不存在就创建</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>场景：在网络围棋比赛中，一个棋盘有361个棋子，我们不需要创建361个棋子对象，我们使用享元模式实现</p><ul><li>颜色是内部状态可以共享，位置时外部状态不可以共享，将作为参数传入，我们就可以只需要2个实例(一黑一白)，在需要棋子的时候从<code>棋子工厂</code>中拿相应颜色的棋子，外部变量<code>位置</code>调用下棋方法时传入</li></ul><p>代码：</p><ul><li>Color 枚举颜色类</li></ul><pre><code class="java">public enum  Color {    WHITE,BLACK}</code></pre><ul><li>FlyWeight 棋子方法接口</li></ul><pre><code class="java">public interface FlyWeight {    public void display(int x,int y);    public Color getColor();    public void setColor(Color color);}</code></pre><ul><li>ChessFlyWeight 棋子实现类</li></ul><pre><code class="java">public class ChessFlyWeight implements FlyWeight{    private Color color;//内部状态    public void setColor(Color color) {        this.color = color;    }    public Color getColor() {        return color;    }    //外部状态作为参数传入    public void display(int x, int y) {        System.out.println(&quot;you put a &quot;+getColor().name().toLowerCase()+&quot; chess at &quot;+&quot;(&quot;+x+&quot;,&quot;+y+&quot;)&quot;);    }}</code></pre><ul><li>ChessFlyweightFactory 棋子工厂类</li></ul><pre><code class="java">public class ChessFlyweightFactory {    //定义一个HashMap用于存储享元对象，实现享元池    private HashMap&lt;Color,FlyWeight&gt; flyweights = new HashMap&lt;&gt;();    public FlyWeight getFlyweight(Color color){        //如果对象存在，则直接从享元池获取        if(flyweights.containsKey(color)){            return flyweights.get(color);        }        //如果对象不存在，先创建一个新的对象添加到享元池中，然后返回        else {            FlyWeight fw = new ChessFlyWeight();            fw.setColor(color);            flyweights.put(fw.getColor(),fw);            return fw;        }    }}</code></pre><ul><li>测试</li></ul><pre><code class="java">public class ChessGameTest {    public static void main(String[] args) {        Random random = new Random();        ChessFlyweightFactory flyweightFactory = new ChessFlyweightFactory();        ChessFlyWeight chess1 = (ChessFlyWeight) flyweightFactory.getFlyweight(Color.BLACK);        chess1.display(random.nextInt(361),random.nextInt(361));        ChessFlyWeight chess2 = (ChessFlyWeight) flyweightFactory.getFlyweight(Color.WHITE);        chess2.display(random.nextInt(361),random.nextInt(361));    }}输出：you put a black chess at (243,252)you put a white chess at (261,147)</code></pre><h4 id="Java中享元模式使用"><a href="#Java中享元模式使用" class="headerlink" title="Java中享元模式使用"></a>Java中享元模式使用</h4><h5 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h5><p>Java中String类被修饰为final类，保证了安全性，不能被继承，值创建出来不能被修改，是可以共享的。</p><p>当使用：</p><p><code>String s = &quot;abd&quot;;</code>这种字面量的形式创建String时，它是会加载到<code>常量池</code>，而不是创建的对象放在堆，常量的拼接还是常量，池中对应的字面量字符串都只会保存一个</p><p>但是使用：</p><p><code>String s = &quot;abd&quot;;</code>这种方式创建的String会放在堆里而不是常量池中。</p><pre><code class="java">String s = &quot;kobe&quot;;String s1 = &quot;ko&quot;;String s2 = &quot;be&quot;;String s3 = s1+s2;String s4 = new String(&quot;kobe&quot;)String s5 = s4.intern();s == s3? trues == s4? falses == s5? true</code></pre><ul><li><strong>intern方法</strong></li></ul><p>存在于.class文件中的常量池，在运行期被JVM装载，并且可以扩充。String的intern()方法就是扩充常量池的一个方法；当一个String实例str调用intern()方法时，Java查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用；</p><h4 id="池技术"><a href="#池技术" class="headerlink" title="池技术"></a>池技术</h4><ul><li>对象池、线程池、数据连接池、常量池都是池技术的使用</li></ul><p><code>池技术</code>：其实就是在一个集合，里面包含了我们需要的对象集合，当然这些对象都被池化了，也就是被对象池所管理，想要这样的对象，从池子里取个就行，但是用完得归还，每个需要的元素是有限个。</p><ul><li>常量池只保存一个相同字符串引用</li><li>数据连接池、线程池可包含多个实例，用完需放回</li></ul><p>优点：</p><ul><li>主要用于减少创建对象的数量，以减少内存占用和提高性能。</li></ul><p>缺点：</p><ul><li>提高了系统的复杂度，需要分离出外部状态和内部状态</li></ul><p>代码地址：<a href="https://github.com/ding-zou/design_patterns/tree/master/flyweight_patterns" rel="external nofollow noopener noreferrer" target="_blank">Github享元模式</a></p>]]></content>
    
    <summary type="html">
    
      蝇量可以理解为很小的数量，享元可以理解为共享的元素；通过这两个理解，我们初步可以知道该模式就是把`对象的数量减少，让他们之间可以共享使用。享元模式：让一个类的实例可以提供多个“虚拟实例”，创建较少的对象实例，多与工厂模式一起使用。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式——生成器模式</title>
    <link href="https://www.dzou.top/post/43e936df.html"/>
    <id>https://www.dzou.top/post/43e936df.html</id>
    <published>2019-08-16T13:45:36.000Z</published>
    <updated>2019-08-16T13:46:29.812Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之生成器模式"><a href="#Java设计模式之生成器模式" class="headerlink" title="Java设计模式之生成器模式"></a>Java设计模式之生成器模式</h2><p><strong><em>生成器模式(建造者模式)：封装一个产品的构造过程，并允许按步骤构造。</em></strong></p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/30.png"><h4 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h4><p>场景：去旅游时先创建好旅游方案，<code>时间</code>、<code>项目</code>、<code>车票</code>、<code>酒店</code>、<code>预订</code>等信息，这些都要根据客户需求来创建，所以我们把<code>创建过程</code>封装在对象中，客户调用其生成器构造想要的旅游方案。(类似迭代器思想)</p><p>代码：</p><ul><li>AbstractBuilder 抽象生成者</li></ul><pre><code class="java">public abstract class AbstractBuilder {    public abstract void buildDay(String day);    public abstract void addHotel(String hotel);    public abstract void addReservation(String reservation);    public abstract void addSpecialEvent(String specialEvent);    public abstract void addTickets(String ticket);    public abstract Planner getVacationPlanner();}</code></pre><ul><li>VacationBuilder 具体生成者</li></ul><pre><code class="java">public class VacationBuilder extends AbstractBuilder {    private String hotel;    private String day;    private String ticket;    private String reservation;    private String specialEvent;    public void buildDay(String day) {        this.day = day;    }    public void addHotel(String hotel) {        this.hotel = hotel;    }    public void addReservation(String reservation) {        this.reservation = reservation;    }    public void addSpecialEvent(String specialEvent) {        this.specialEvent = specialEvent;    }    public void addTickets(String ticket) {        this.ticket = ticket;    }    public Planner getVacationPlanner() {        return new Planner(hotel,day,ticket,reservation,specialEvent);    }}</code></pre><ul><li><p>Planner 计划方案</p><p>关于<code>lombok</code>注解<code>@AllArgsConstructor</code>将自动创建一个包含所有成员属性的构造函数<br><code>@Data</code>将为你提供<code>getter、setter、construct、toString</code>方法，需要可重写</p></li></ul><pre><code class="java">@AllArgsConstructor@Datapublic class Planner {    private String hotel;    private String day;    private String ticket;    private String reservation;    private String specialEvent;    @Override    public String toString() {        return &quot;Planner：\n&quot; +                &quot;hotel:&quot; + hotel + &#39;\n&#39; +                &quot;day:&quot; + day + &#39;\n&#39; +                &quot;ticket:&quot; + ticket + &#39;\n&#39; +                &quot;reservation:&quot; + reservation + &#39;\n&#39; +                &quot;specialEvent:&quot; + specialEvent + &#39;\n&#39;;    }}</code></pre><ul><li>测试</li></ul><pre><code class="java">public class BuilderTest {    public static void main(String[] args) {        AbstractBuilder vacationBuilder = new VacationBuilder();        vacationBuilder.addHotel(&quot;名宿&quot;);        vacationBuilder.addReservation(&quot;预定两天&quot;);        vacationBuilder.addSpecialEvent(&quot;逛游乐园，游玩海底世界，蹦极&quot;);        vacationBuilder.addTickets(&quot;两天后回昆明的票&quot;);        vacationBuilder.buildDay(&quot;明天上午10点到&quot;);        Planner plan = vacationBuilder.getVacationPlanner();        System.out.println(plan);    }}输出：Planner：hotel:名宿day:明天上午10点到ticket:两天后回昆明的票reservation:预定两天specialEvent:逛游乐园，游玩海底世界，蹦极</code></pre><p>生成者模式优点：</p><ul><li>将一个复杂对象的创建封装，允许有多个步骤</li><li>向客户隐藏创建过程</li><li>产品创建实现可更改，因为创建只需要一个抽象接口</li></ul><p>代码地址：<a href="https://github.com/ding-zou/design_patterns/tree/master/builder_patterns" rel="external nofollow noopener noreferrer" target="_blank">Github生成器模式</a></p>]]></content>
    
    <summary type="html">
    
      生成器模式(建造者模式)：封装一个产品的构造过程，并允许按步骤构造。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式——桥接模式</title>
    <link href="https://www.dzou.top/post/4855070c.html"/>
    <id>https://www.dzou.top/post/4855070c.html</id>
    <published>2019-08-16T13:44:23.000Z</published>
    <updated>2019-08-16T13:45:15.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之桥接模式"><a href="#Java设计模式之桥接模式" class="headerlink" title="Java设计模式之桥接模式"></a>Java设计模式之桥接模式</h2><p><strong><em>桥接模式：将实现和抽象放在两个不同的类层次中而使得他们可以独立改变。</em></strong></p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/29.png"><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>例子：有<code>米线</code>、<code>面条</code>、<code>饺子</code>三种食物，它们分为<code>加辣</code>和<code>不加辣</code></p><ul><li>我们可以把<code>食物</code>写成一个抽象类，三种食物可以分别扩展，还有一个调料抽象类，<code>加辣</code>、<code>不加辣</code>扩展其</li></ul><p>代码：</p><ul><li>spicy</li></ul><pre><code class="java">public abstract class Spicy {    public abstract String addSpicy();}</code></pre><ul><li>NoSpicy 不加辣</li></ul><pre><code class="java">public class NoSpicy extends Spicy{    public String addSpicy() {        return &quot;不加辣&quot;;    }}</code></pre><ul><li>WithSpicy 加辣</li></ul><pre><code class="java">public class WithSpicy extends Spicy{    public String addSpicy() {        return  &quot;加辣&quot;;    }}</code></pre><ul><li>Launch 午餐类</li></ul><pre><code class="java">public abstract class Launch {    public abstract void orderLaunch();    public abstract void setSpicy(Spicy spicy);}</code></pre><ul><li>Dumplings</li></ul><pre><code class="java">public class Dumplings extends Launch{    private Spicy spicy;    public void orderLaunch() {        System.out.println(spicy.addSpicy()+&quot; 饺子&quot;);    }    public void setSpicy(Spicy spicy) {        this.spicy = spicy;    }}</code></pre><ul><li>Noodle</li></ul><pre><code class="java">public class Noodle extends Launch{    private Spicy spicy;    public void orderLaunch() {        System.out.println(spicy.addSpicy()+&quot; 面条&quot;);    }    public void setSpicy(Spicy spicy) {        this.spicy = spicy;    }}</code></pre><ul><li>RiceNoodle</li></ul><pre><code class="java">public class RiceNoodle extends Launch{    private Spicy spicy;    public void orderLaunch() {        System.out.println(spicy.addSpicy()+&quot; 米线&quot;);    }    public void setSpicy(Spicy spicy) {        this.spicy = spicy;    }}</code></pre><ul><li>测试</li></ul><pre><code class="java">public class BridgeClient {    public static void main(String[] args) {        Spicy noSpicy = new WithSpicy();        Dumplings dumplings = new Dumplings();        dumplings.setSpicy(noSpicy);        dumplings.orderLaunch();        System.out.println(&quot;\n&quot;);        Noodle noodle = new Noodle();        noodle.setSpicy(noSpicy);        noodle.orderLaunch();        System.out.println(&quot;\n&quot;);        Spicy withSpicy = new WithSpicy();        RiceNoodle riceNoodle = new RiceNoodle();        riceNoodle.setSpicy(withSpicy);        riceNoodle.orderLaunch();    }}输出：加辣 饺子加辣 面条加辣 米线</code></pre><p>桥接模式优点：</p><ul><li>方便扩展接口和实现</li><li>将实现解耦，抽象和实现互不影响</li></ul><p>代码地址：<a href="https://github.com/ding-zou/design_patterns/tree/master/bridge_patterns" rel="external nofollow noopener noreferrer" target="_blank">GIthub桥接模式</a></p>]]></content>
    
    <summary type="html">
    
      桥接模式：将实现和抽象放在两个不同的类层次中而使得他们可以独立改变。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式——复合模式</title>
    <link href="https://www.dzou.top/post/ecc07d1a.html"/>
    <id>https://www.dzou.top/post/ecc07d1a.html</id>
    <published>2019-08-16T13:43:23.000Z</published>
    <updated>2019-08-16T13:44:07.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之复合模式"><a href="#Java设计模式之复合模式" class="headerlink" title="Java设计模式之复合模式"></a>Java设计模式之复合模式</h2><p><strong><em>复合模式：结合两个或者两个以上的模式，组合一个解决方案，解决一再发生的一般性问题。</em></strong></p><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p><strong><em>MVC是典型的复合模式</em></strong>，我们主要了解MVC模式</p><p>使用到了：</p><ul><li>策略模式</li><li>组合模式</li><li>观察者模式</li></ul><p><strong><em>MVC：M(Model)模型、V(View)视图、C(Controller)控制器</em></strong></p><ul><li>Model:是程序主体，代表了业务数据和业务逻辑</li><li>View:是与用户交互的界面，显示数据、 接收输入，但不参与实际业务逻辑</li><li>Controler:接收用户输入，并解析反馈给 Model</li></ul><p>设计模式的应用：</p><ul><li><p>策略模式</p><p><code>视图</code>和<code>控制器</code>使用了策略模式，视图是一个对象，可以使用不同的策略，控制器提供策略。</p></li><li><p>观察者模式</p><p><code>模型</code>实现了观察者模式，当模型状态改变时，通知控制器和视图更新。</p></li><li><p>组合模式</p><p><code>视图</code>使用了组合模式，不论是<code>Swing</code>的组件还是<code>Web</code>的标签元素，都使用了组合模式。</p></li></ul><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><ul><li>M（model）：javaBean对象（将参数封装成JavaBean对象交给业务层处理）</li><li>V(view)：jsp （向控制器提交数据，显示模型中的数据）</li><li>C（controller）：servlet（根据视图提出的请求判断将请求交给那个模型处理，将处理后的结果交给对应的视图更新显示）</li></ul><h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><p><strong>SpringMVC：一种基于Java实现的MVC设计模型的请求驱动类型的轻量级框架</strong></p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/28.png"><p>SpringMvc工作流程：</p><ol><li>首先用户发送请求——&gt;<code>DispatcherServlet</code>，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；</li><li><code>DispatcherServlet</code>——&gt;<code>HandlerMapping</code>， <code>HandlerMapping</code>将会把请求映射为<code>HandlerExecutionChain</code>对象（包含一个Handler处理器（页面控制器）对象、多个<code>HandlerInterceptor</code>拦截器）对象，通过这种策略模式，很容易添加新的映射策略；</li><li><code>DispatcherServlet</code>——&gt;<code>HandlerAdapter</code>，<code>HandlerAdapter</code>将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；</li><li><code>HandlerAdapter</code>——&gt;处理器功能处理方法的调用，<code>HandlerAdapter</code>将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个<code>ModelAndView</code>对象（包含模型数据、逻辑视图名）；</li><li><code>ModelAndView</code>的逻辑视图名——&gt; <code>ViewResolver</code>， <code>ViewResolver</code>将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；</li><li>View——&gt;渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术；</li><li>返回控制权给<code>DispatcherServlet</code>，由<code>DispatcherServlet</code>返回响应给用户，到此一个流程结束</li></ol><p>可以看到SpringmVC中还使用了：</p><ul><li><p>适配器模式</p><p><code>DispatcherServlet</code>——&gt;<code>HandlerAdapter</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      复合模式：结合两个或者两个以上的模式，组合一个解决方案，解决一再发生的一般性问题。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式——访问者模式</title>
    <link href="https://www.dzou.top/post/d88fa864.html"/>
    <id>https://www.dzou.top/post/d88fa864.html</id>
    <published>2019-08-16T13:42:01.000Z</published>
    <updated>2019-08-16T13:43:01.538Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之访问者模式"><a href="#Java设计模式之访问者模式" class="headerlink" title="Java设计模式之访问者模式"></a>Java设计模式之访问者模式</h2><p><strong><em>访问者模式：封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。</em></strong></p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/37.png"><blockquote><p>使用到了Java<code>双分派</code></p></blockquote><p>角色：</p><ul><li>Vistor（抽象访问者）：为该对象结构中具体元素角色声明一个访问操作接口。</li><li>ConcreteVisitor（具体访问者）：每个具体访问者都实现了Vistor中定义的操作。</li><li>Element（抽象元素）：定义了一个accept操作，以Visitor作为参数。</li><li>ConcreteElement（具体元素）：实现了Element中的accept()方法，调用Vistor的访问方法以便完成对一个元素的操作。</li><li>ObjectStructure（对象结构）：可以是组合模式，也可以是集合；能够枚举它包含的元素；提供一个接口，允许Vistor访问它的元素。</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>适用场景：</p><ul><li>假如一个对象中存在着一些与本对象不相干（或者关系较弱）的操作，为了避免这些操作污染这个对象，则可以使用访问者模式来把这些操作封装到访问者中去。</li><li>一组对象有相似的方法，使用访问者模式减少重复代码量</li></ul><p>场景：</p><p>运动员每天都在训练，我们需要访问运动员的一些信息，这些信息是根据内部状态获取的，比赛的成绩获取到获奖情况，身体状态获取到相应的医学指导。</p><p>现在有三种运动员：<code>跳高运动员</code>，<code>跳远运动员</code>，<code>径赛运动员</code></p><p>我们要访问他们比赛的获奖情况和身体状况的指导信息，采用访问者模式</p><ul><li>Visitor 访问者接口 定义访问者的行为</li></ul><pre><code class="java">/** * 访问者接口，接口方法访问具体对象，违背依赖倒置原则 */public interface Visitor {    public void visit(HighJumperAthlete athlete);    public void visit(LongJumperAthlete athlete);    public void visit(RunnerAthlete athlete);}</code></pre><ul><li>Element 运动员元素接口</li></ul><pre><code class="java">/** * 元素接口 */public interface Element {    public void accept(Visitor visitor);}</code></pre><ul><li>HealthState 身体健康状态枚举类</li></ul><pre><code class="java">/** * 身体健康状态枚举类 */public enum HealthState {    MORE_BETTER,//较好    GOOD,//好    NORMAL,//正常    A_LITTLE_BAD,//较差    BAD;//很差}</code></pre><ul><li>HighJumperAthlete 跳高运动员元素类</li></ul><pre><code class="java">/** * 跳高运动员元素类 */@Data@AllArgsConstructorpublic class HighJumperAthlete implements Element {    private String name;//名字    private String highJumpGrade;//成绩    private HealthState healthCondition;//健康状态    public void accept(Visitor visitor) {        visitor.visit(this);    }}</code></pre><ul><li>LongJumperAthlete 跳远运动员元素类</li></ul><pre><code class="java">/** * 跳远运动员元素类 */@Data@AllArgsConstructorpublic class LongJumperAthlete implements Element{    private String name;    private String longJumpGrade;    private HealthState healthCondition;    public void accept(Visitor visitor) {        visitor.visit(this);    }}</code></pre><ul><li>RunnerAthlete 径赛运动员元素类</li></ul><pre><code class="java">/** * 径赛运动员元素类 */@Data@AllArgsConstructorpublic class RunnerAthlete implements Element {    private String name;    private String longRunGrade;    private String shortRunGrade;    private HealthState healthCondition;    public void accept(Visitor visitor) {        visitor.visit(this);    }}</code></pre><ul><li>GradeSelectionsVisitor 比赛成绩获奖情况访问类</li></ul><pre><code class="java">/** * 访问运动员成绩获奖信息 * 根据成绩信息获取获奖情况的实现类 */public class GradeSelectionsVisitor implements Visitor{    //实现访问跳高运动员操作    public void visit(HighJumperAthlete athlete) {        double grade = Double.parseDouble(athlete.getHighJumpGrade());        if(grade&gt;=7.00){            System.out.println(athlete.getName()+&quot; 获得了跳高一等奖&quot;);        }else if(grade&gt;=6.00){            System.out.println(athlete.getName()+&quot; 获得了跳高二等奖&quot;);        }else {            System.out.println(&quot;很遗憾，&quot;+athlete.getName()+&quot; 在跳高比赛中没有获得奖&quot;);        }    }    //实现访问跳远运动员    public void visit(LongJumperAthlete athlete) {        double grade = Double.parseDouble(athlete.getLongJumpGrade());        if(grade&gt;=12.00){            System.out.println(athlete.getName()+&quot; 获得了跳远一等奖&quot;);        }else if(grade&gt;=10.00){            System.out.println(athlete.getName()+&quot; 获得了跳远二等奖&quot;);        }else {            System.out.println(&quot;很遗憾，&quot;+athlete.getName()+&quot; 在跳远比赛中没有获得奖&quot;);        }    }    //实现访问径赛运动员    public void visit(RunnerAthlete athlete) {        double longRunGrade = Double.parseDouble(athlete.getLongRunGrade());        double shortRunGrade = Double.parseDouble(athlete.getShortRunGrade());        if(longRunGrade&lt;=45.00){            System.out.println(athlete.getName()+&quot; 获得了长跑一等奖&quot;);        }else if(longRunGrade&lt;=53.00){            System.out.println(athlete.getName()+&quot; 获得了长跑二等奖&quot;);        }else {            System.out.println(&quot;很遗憾，&quot;+athlete.getName()+&quot; 在长跑比赛中没有获得奖&quot;);        }        if(shortRunGrade&lt;=11.00){            System.out.println(athlete.getName()+&quot; 获得了短跑一等奖&quot;);        }else if(shortRunGrade&lt;=12.50){            System.out.println(athlete.getName()+&quot; 获得了短跑二等奖&quot;);        }else {            System.out.println(&quot;很遗憾，&quot;+athlete.getName()+&quot; 在短跑比赛中没有获得奖&quot;);        }    }}</code></pre><ul><li>HeathEvaluateVisitor 身体健康访问实现类</li></ul><pre><code class="java">/** * 访问运动员身体健康状态 * 执行相应操作提醒实现类 */public class HeathEvaluateVisitor implements Visitor {    public void visit(HighJumperAthlete athlete) {        HealthState state = athlete.getHealthCondition();        healthEvaluate(athlete.getName(),state);    }    public void visit(LongJumperAthlete athlete) {        HealthState state = athlete.getHealthCondition();        healthEvaluate(athlete.getName(),state);    }    public void visit(RunnerAthlete athlete) {        HealthState state = athlete.getHealthCondition();        healthEvaluate(athlete.getName(),state);    }    public static void healthEvaluate(String name,HealthState state){        if(state.equals(HealthState.MORE_BETTER)){            System.out.println(name+&quot; 你的身体状态非常好&quot;);        }else if(state.equals(HealthState.GOOD)){            System.out.println(name+&quot; 你的身体状况挺好，继续保持&quot;);        }else if(state.equals(HealthState.NORMAL)){            System.out.println(name+&quot; 你的身体状况没问题，不过要加以注意&quot;);        }else if(state.equals(HealthState.A_LITTLE_BAD)){            System.out.println(name+&quot; 你的身体状况出了些问题，请作进一步检查&quot;);        }else{            System.out.println(name+&quot; 你的身体状况很不好，你将不能继续训练，请立即进行检查&quot;);        }    }}</code></pre><ul><li>ObjectStructure 元素结构类，控制元素的操作和访问</li></ul><pre><code class="java">/** * 元素访问入口，元素结构容器 */public class ObjectStructure {    //list存放运动员元素    private List&lt;Element&gt; athletes;    public ObjectStructure(){        athletes = new ArrayList&lt;&gt;();    }    //添加运动员    public void add(Element element){        athletes.add(element);    }    //访问所有运动员    public void visitAll(Visitor visitor){        athletes.forEach((o)-&gt;o.accept(visitor));    }}</code></pre><ul><li>测试</li></ul><pre><code class="java">public class ClientTest {    public static void main(String[] args) {        ObjectStructure objectStructure = addAndGetAthlete();        GradeSelectionsVisitor visitor = new GradeSelectionsVisitor();        System.out.println(&quot;比赛最终结果------&quot;);        objectStructure.visitAll(visitor);        System.out.println(&quot;\n身体健康检查结果------&quot;);        HeathEvaluateVisitor visitor1 = new HeathEvaluateVisitor();        objectStructure.visitAll(visitor1);    }    /**     * 添加运动员     * @return 操作运动员的数据结构     */    private static ObjectStructure addAndGetAthlete(){        ObjectStructure objectStructure = new ObjectStructure();        objectStructure.add(new HighJumperAthlete(&quot;张三&quot;,&quot;8.00&quot;,HealthState.A_LITTLE_BAD));        objectStructure.add(new HighJumperAthlete(&quot;李四&quot;,&quot;6.00&quot;,HealthState.GOOD));        objectStructure.add(new HighJumperAthlete(&quot;王五&quot;,&quot;7.00&quot;,HealthState.NORMAL));        objectStructure.add(new LongJumperAthlete(&quot;小白&quot;,&quot;13.00&quot;,HealthState.MORE_BETTER));        objectStructure.add(new LongJumperAthlete(&quot;小丁&quot;,&quot;10&quot;,HealthState.BAD));        objectStructure.add(new LongJumperAthlete(&quot;小周&quot;,&quot;11.00&quot;,HealthState.NORMAL));        objectStructure.add(new RunnerAthlete(&quot;小吴&quot;,&quot;46&quot;,&quot;11&quot;,HealthState.NORMAL));        objectStructure.add(new RunnerAthlete(&quot;小王&quot;,&quot;44&quot;,&quot;13&quot;,HealthState.GOOD));        objectStructure.add(new RunnerAthlete(&quot;小邹&quot;,&quot;45&quot;,&quot;10&quot;,HealthState.A_LITTLE_BAD));        objectStructure.add(new RunnerAthlete(&quot;小赵&quot;,&quot;43&quot;,&quot;11.5&quot;,HealthState.BAD));        return objectStructure;    }}</code></pre><ul><li>输出</li></ul><pre><code class="java">比赛最终结果------张三 获得了跳高一等奖李四 获得了跳高二等奖王五 获得了跳高一等奖小白 获得了跳远一等奖小丁 获得了跳远二等奖小周 获得了跳远二等奖小吴 获得了长跑二等奖小吴 获得了短跑一等奖小王 获得了长跑一等奖很遗憾，小王 在短跑比赛中没有获得奖小邹 获得了长跑一等奖小邹 获得了短跑一等奖小赵 获得了长跑一等奖小赵 获得了短跑二等奖身体健康检查结果------张三 你的身体状况出了些问题，请作进一步检查李四 你的身体状况挺好，继续保持王五 你的身体状况没问题，不过要加以注意小白 你的身体状态非常好小丁 你的身体状况很不好，你将不能继续训练，请立即进行检查小周 你的身体状况没问题，不过要加以注意小吴 你的身体状况没问题，不过要加以注意小王 你的身体状况挺好，继续保持小邹 你的身体状况出了些问题，请作进一步检查小赵 你的身体状况很不好，你将不能继续训练，请立即进行检查</code></pre><p><strong>访问者模式优点</strong></p><ul><li>可以对组合结构加入新的操作，无需改变结构</li><li>便于扩展组合对象的新的操作</li></ul><p>缺点</p><ul><li>违背了依赖倒置原则，<code>访问者</code>依赖了具体元素类</li><li>扩展元素类不方便，需要修改访问者</li></ul><p>代码地址：<a href="https://github.com/ding-zou/design_patterns/tree/master/visitor_patterns" rel="external nofollow noopener noreferrer" target="_blank">Github访问者模式</a></p>]]></content>
    
    <summary type="html">
    
      访问者模式：封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式——备忘录模式</title>
    <link href="https://www.dzou.top/post/7f2dd2e8.html"/>
    <id>https://www.dzou.top/post/7f2dd2e8.html</id>
    <published>2019-08-16T13:40:28.000Z</published>
    <updated>2019-08-16T13:41:43.001Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之备忘录模式"><a href="#Java设计模式之备忘录模式" class="headerlink" title="Java设计模式之备忘录模式"></a>Java设计模式之备忘录模式</h2><p><strong><em>备忘录模式：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。</em></strong></p><blockquote><p>遵循了的单一责任原则，关键对象不负责保存状态，由备忘录负责保存</p></blockquote><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/35.png"><p>角色：</p><ul><li><strong>发起人：</strong>记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据。</li><li><strong>备忘录：</strong>负责存储发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。</li><li><strong>管理角色：</strong>对备忘录进行管理，保存和提供备忘录。</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li>Originator 发起者 负责状态的设置 当需要时恢复状态</li></ul><pre><code class="java">public class Originator {    private String state;    public String getState() {        return state;    }    public void setState(String state) {        this.state = state;    }    public Memento saveStateToMemento(){        return new Memento(state);    }    public void restoreStateFromMemento(Memento memento){        setState(memento.getState());    }}</code></pre><ul><li>Memento 备忘录 保存维护状态的对象</li></ul><pre><code class="java">/** * 备忘录对象 主要负责保存维护状态 */public class Memento {    private String state;    public Memento(String state) {        this.state = state;    }    public String getState() {        return state;    }}</code></pre><ul><li>CareTaker 状态维护者</li></ul><pre><code class="java">/** * 负责人，负责保存所有备忘录 */public class CareTaker {    private List&lt;Memento&gt; list;    public CareTaker(){        list = new ArrayList&lt;&gt;();    }    //添加备忘录    public void add(Memento memento){        list.add(memento);    }    //获得备忘录，从中可以获得状态    public Memento get(int i){        return list.get(i);    }}</code></pre><ul><li>测试</li></ul><pre><code class="java">public class ClientTest {    public static void main(String[] args) {        CareTaker careTaker = new CareTaker();        Originator originator = new Originator();        originator.setState(&quot;状态1&quot;);        careTaker.add(originator.saveStateToMemento());        originator.setState(&quot;状态2&quot;);        careTaker.add(originator.saveStateToMemento());        originator.setState(&quot;状态3&quot;);        careTaker.add(originator.saveStateToMemento());        System.out.println(&quot;当前状态：&quot;+originator.getState());        //恢复到1状态        System.out.println(&quot;我想要恢复到状态1&quot;);        originator.restoreStateFromMemento(careTaker.get(0));        System.out.println(&quot;当前状态：&quot;+originator.getState());    }}输出：当前状态：状态3我想要恢复到状态1当前状态：状态1</code></pre><blockquote><p>事务回滚可使用备忘录模式</p></blockquote><p>备忘录模式优点：</p><ul><li>提供了恢复状态的功能</li><li>保持关键对象的封装</li></ul><p>缺点：</p><ul><li>状态需要存储到备忘录对象是消耗资源的</li></ul><p>代码地址：<a href="https://github.com/ding-zou/design_patterns/tree/master/memento_patterns" rel="external nofollow noopener noreferrer" target="_blank">Github备忘录模式</a></p>]]></content>
    
    <summary type="html">
    
      备忘录模式：在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式——代理模式</title>
    <link href="https://www.dzou.top/post/653661c0.html"/>
    <id>https://www.dzou.top/post/653661c0.html</id>
    <published>2019-08-13T16:09:42.000Z</published>
    <updated>2019-08-16T13:31:42.410Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之代理模式"><a href="#Java设计模式之代理模式" class="headerlink" title="Java设计模式之代理模式"></a>Java设计模式之代理模式</h2><p><strong><em>代理模式：为另一种对象提供一个替身或者占位符来控制对这个对象的访问。</em></strong></p><blockquote><p>使用代理对象创建代表对象，让代表对象控制对对象的访问，被代理对象可以使远程对象、创建开销大的对象或者是需要安全控制的对象。</p></blockquote><p>代理访问控制：</p><ul><li><p>远程代理控制访问远程对象</p><p>可以作为另一个JVM上的对象的本地代表，利用网络Socket进行连接，通过网络将结果返回给代理。</p></li><li><p>虚拟代理控制访问创建开销大的对象</p></li><li><p>保护代理基于权限控制对资源的访问</p></li><li><p>智能引用代理，相当于对原对象的一种功能扩展，在访问原对象时，加入了新功能，例如统计访问次数等。</p></li></ul><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/26.png"><ul><li>Subject：提供统一接口，让Proxy可以替代RealSubject</li><li>RealSubject：真正做事的对象，被Proxy代理控制访问</li><li>Proxy：代理对象，持有RealSubject引用，负责客户的调用</li></ul><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><blockquote><p>静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类.</p></blockquote><p><strong>关键：在程序未运行之前，代理对象就已经被创建出来了，.class文件存在。</strong></p><p>优点：</p><ul><li>在不修改元对象的情况下，对目标进行扩展。</li></ul><p>缺点：</p><ul><li>每个方法都需要扩展，当有很多方法时，需要对每个方法都添加相应的操作，不方便维护。</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li>点餐</li></ul><pre><code class="java">public interface MenuOrder {    public void order();}</code></pre><ul><li>被代理类——厨师</li></ul><pre><code class="java">public class ChefAcceptOrder implements MenuOrder{    public void order() {        System.out.println( new Meal().toString());    }}</code></pre><ul><li>任务返回值——Meal</li></ul><pre><code class="java">public class Meal {    private String[] names;    public Meal(){        names = new String[3];        names[0] = &quot;鱼香肉丝&quot;;        names[1] = &quot;宫保鸡丁&quot;;        names[2] = &quot;紫菜汤&quot;;    }    @Override    public String toString() {        return &quot;Meal{&quot; +                &quot;names=&quot; + Arrays.toString(names) +                &#39;}&#39;;    }}</code></pre><ul><li>代理类——女服务员</li></ul><pre><code class="java">public class WaitressProxy implements MenuOrder{    private ChefAcceptOrder acceptOrder;    public WaitressProxy(ChefAcceptOrder acceptOrder){        this.acceptOrder = acceptOrder;    }    public void order() {        System.out.println(&quot;请您稍等，正在为你备餐&quot;);        acceptOrder.order();        System.out.println(&quot;请您享用&quot;);    }}</code></pre><ul><li>测试</li></ul><pre><code class="java">public class Test {    public static void main(String[] args) {        ChefAcceptOrder acceptOrder = new ChefAcceptOrder();        WaitressProxy proxy = new WaitressProxy(acceptOrder);        proxy.order();    }}</code></pre><h3 id="远程代理"><a href="#远程代理" class="headerlink" title="远程代理"></a>远程代理</h3><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><ul><li>远程方法调用接口</li></ul><pre><code class="java">public interface MyRemote extends Remote {    public String doSomething() throws RemoteException;}</code></pre><ul><li>远程方法调用实现——还需继承<code>UnicastRemoteObject</code></li></ul><pre><code class="java">public class MyRemoteImpl extends UnicastRemoteObject implements MyRemote{    protected MyRemoteImpl() throws RemoteException {    }    public String doSomething() throws RemoteException {        return &quot;我完成了一件事。&quot;;    }}</code></pre><ul><li>客户端测试远程调用</li></ul><pre><code class="java">    public static void main(String[] args) {        try {            MyRemote remote = new MyRemoteImpl();            Context context = new InitialContext();            LocateRegistry.createRegistry(8090);            context.bind(&quot;rmi://localhost:8090/myRemoteService&quot;,remote);            MyRemote remote1 = (MyRemote) context.lookup(&quot;rmi://localhost:8090/myRemoteService&quot;);            System.out.println(remote1.doSomething());        } catch (RemoteException e) {            e.printStackTrace();        } catch (NamingException e) {            e.printStackTrace();        }    }</code></pre><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p><strong><em>在运行时，为被代理对象利用反射创建代理对象</em></strong></p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/27.png"><blockquote><p>其中Proxy实际没有，是由JDK为我们动态创建的</p></blockquote><p>动态代理有两种类型：</p><ul><li>有<code>接口</code>被实现的情况下，属于JDK中的<code>Proxy</code>代理</li><li>没有接口被实现，属于<code>Cglib</code>代理</li></ul><p>优点：</p><ul><li>对代理类的函数进行统一的处理，而不用修改每个代理类的函数</li></ul><h4 id="JDK动态代理——Proxy"><a href="#JDK动态代理——Proxy" class="headerlink" title="JDK动态代理——Proxy"></a>JDK动态代理——Proxy</h4><p>通过<code>Proxy</code>类中静态方法<code>newProxyInstance</code>创建代理对象，<code>用代理对象class文件加载造出被代理对象，相当于复制一份</code></p><pre><code class="java">newProxyInstance(ClassLoader loader, Class [] interfaces, InvocationHandler handler)</code></pre><p>接受三个参数：</p><ul><li>被代理对象的类加载器，加载被代理对象</li><li>被代理对象的方法数组</li><li>方法执行处理器，<code>你需要实现一个调用处理器</code>，实现<code>InvocationHandler</code>接口</li></ul><p>所有方法都被提交到<code>InvocationHandler.invoke</code>中执行</p><p><code>java.lang.reflect.InvocationHandler</code>类就一个<code>invoke</code>方法</p><pre><code class="java">// 该方法负责集中处理动态代理类上的所有方法调用。第一个参数既是代理类实例，第二个参数是被调用的方法对象// 第三个方法是调用参数。Object invoke(Object proxy, Method method, Object[] args)</code></pre><h5 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h5><ul><li>调用方法接口</li></ul><pre><code class="java">public interface SayHello {    public void sayHello();}</code></pre><ul><li>调用方法接口实现</li></ul><pre><code class="java">public class SayHelloImpl implements SayHello {    public void sayHello() {        System.out.println(&quot;hello&quot;);    }}</code></pre><ul><li><code>InvocationHandler</code>-处理方法调用</li></ul><pre><code class="java">public class SayHelloInvocationHandler implements InvocationHandler {    private SayHello sayHello;    public SayHelloInvocationHandler(SayHello sayHello){        this.sayHello = sayHello;    }    public Object invoke(Object proxy, Method method, Object[] args) {        try {            System.out.println(&quot;before&quot;);            Object o = method.invoke(sayHello, args);            System.out.println(&quot;after&quot;);            return o;        } catch (IllegalAccessException e) {            e.printStackTrace();        } catch (InvocationTargetException e) {            e.printStackTrace();        }        return null;    }}</code></pre><ul><li>获取代理对象</li></ul><pre><code class="java">public class ProxyFactory {    //维护一个目标对象    private SayHello target;    public ProxyFactory(SayHello target){        this.target=target;    }    public Object getNewProxy(){        return Proxy.newProxyInstance(target.getClass().getClassLoader(),                target.getClass().getInterfaces(),                new SayHelloInvocationHandler(target));    }}</code></pre><ul><li>测试</li></ul><pre><code class="java">public static void main(String[] args) {        SayHelloImpl sayHello = new SayHelloImpl();        ProxyFactory proxyFactory = new ProxyFactory(sayHello);        SayHello proxy = (SayHello) proxyFactory.getNewProxy();        proxy.sayHello();    }</code></pre><h4 id="动态代理——Cglib"><a href="#动态代理——Cglib" class="headerlink" title="动态代理——Cglib"></a>动态代理——Cglib</h4><p><strong><em>上面的静态代理和动态代理模式都是要求目标对象实现一个接口或者多个接口,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候就可以使用构建目标对象子类的方式实现代理,这种方法就叫做:Cglib代理</em></strong></p><ul><li>实现<code>MethodInterceptor</code>接口，提供<code>intercept</code>方法拦截</li></ul><h5 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h5><ul><li>服务类——被代理对象</li></ul><pre><code class="java">public class TaskService {    public void doTask(){        System.out.println(&quot;正在进行紧张的计算&quot;);    }}</code></pre><ul><li>获取代理对象</li></ul><pre><code class="java">public class ProxyFactory implements MethodInterceptor {    private Object target;    public ProxyFactory(Object target){        this.target = target;    }    public Object getNewProxy(){        Enhancer enhancer = new Enhancer();        enhancer.setSuperclass(target.getClass());        enhancer.setCallback(this);        return enhancer.create();    }    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {        System.out.println(&quot;开始执行&quot;);        Object res = method.invoke(target,objects);        System.out.println(&quot;结束执行&quot;);        return res;    }}</code></pre><ul><li>测试</li></ul><pre><code class="java">public static void main(String[] args) {        TaskService taskService = new TaskService();        ProxyFactory proxyFactory = new ProxyFactory(taskService);        TaskService cglib = (TaskService) proxyFactory.getNewProxy();        cglib.doTask();    }</code></pre><h3 id="代理模式和装饰者模式"><a href="#代理模式和装饰者模式" class="headerlink" title="代理模式和装饰者模式"></a>代理模式和装饰者模式</h3><p><strong><em>代理模式和装饰者模式UML基本一样，但是两者的核心不一样：</em></strong></p><ul><li><p>装饰者模式强调<code>添加行为</code></p></li><li><p>代理模式强调<code>控制访问</code></p><hr></li></ul><p>代码地址：<a href="https://github.com/ding-zou/design_patterns/tree/master/proxy_patterns" rel="external nofollow noopener noreferrer" target="_blank">Github代理模式</a></p>]]></content>
    
    <summary type="html">
    
      代理模式：为另一种对象提供一个替身或者占位符来控制对这个对象的访问。使用代理对象创建代表对象，让代表对象控制对对象的访问，被代理对象可以使远程对象、创建开销大的对象或者是需要安全控制的对象。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式——状态模式</title>
    <link href="https://www.dzou.top/post/94ac76a6.html"/>
    <id>https://www.dzou.top/post/94ac76a6.html</id>
    <published>2019-08-13T16:08:23.000Z</published>
    <updated>2019-08-16T13:38:31.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之状态模式"><a href="#Java设计模式之状态模式" class="headerlink" title="Java设计模式之状态模式"></a>Java设计模式之状态模式</h2><p><strong><em>首先你可能会想用int值存储状态，实现状态切换，Java中很多地方都像这样使用，特别时并发JUC中，但是我们的设计模式将提供一个更符合设计原则，更有弹性的状态模式。(JUC中使用int存储状态是因为不想让一个并发类的实现需要依赖很多的状态类，int值已经可以满足需求，状态模式更多是针对系统的设计)</em></strong></p><p><strong><em>状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</em></strong></p><p>把对象设计成一个<code>接口</code>，该接口定义状态共同的方法，具体的状态的实现就实现该接口。</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/25.png"><ol><li>为状态定义一个接口(可能为抽象类)，接口中的方法定义一些动作</li><li>为每个状态实现状态类，重写各个状态不同的行为实现</li><li>在<code>Context</code>中将操作委托给状态</li></ol><blockquote><p>但是状态模式有一个缺点就是，状态和状态之间依赖太强了，但是这种操作提供的是一个更有弹性的设计，而且<code>Context</code>只需要知道我需要提交的请求而不需要知道它是怎么执行的，因为实现是有<code>状态</code>内部负责的。</p></blockquote><h3 id="Head-first-设计模式例子"><a href="#Head-first-设计模式例子" class="headerlink" title="Head first 设计模式例子"></a>Head first 设计模式例子</h3><p>一个糖果机售卖糖果，你放入15分就可以后转动转盘就可以获取一个糖果，但是也有糖果售完的情况。</p><p>我们有<code>放入钱</code>，<code>转动转盘</code>，<code>放出糖果</code>和<code>退款</code>四个操作，这些操作接口由一个<code>接口</code>或者<code>抽象类</code>定义(抽象类可实现默认方法)，这个类就是<code>状态抽象类</code>或者<code>状态接口类</code></p><p>该糖果机这里就有以下4个状态：</p><ul><li>没有放钱的状态——NoMoney</li><li>放入钱的状态——HasMoney</li><li>售出糖果的状态——Sold</li><li>售完的状态——SoldOut</li></ul><p>每一个状态都有对应操作的不同实现，像<code>NoMoney</code>状态就不可以操作退款和放出糖果，转动转盘也没有糖果掉出，所以我们可以使用抽象类的默认方法(无法进行该操作)或者使用重写的方法实现更人性化的操作。</p><blockquote><p>实现了对修改关闭，对扩展开放的原则，有新的状态只需新添加一个类并实现其方法</p></blockquote><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/24.png"><ul><li>State</li></ul><pre><code class="java">public abstract class State {    protected void insertMoney(){        System.out.println(&quot;错误的请求&quot;);    }    protected void returnMoney(){        System.out.println(&quot;错误的请求&quot;);    }    protected void turnCrank(){        System.out.println(&quot;错误的请求&quot;);    }    protected void distribute(){        System.out.println(&quot;错误的请求&quot;);    }}</code></pre><ul><li>HasMoney</li></ul><pre><code class="java">public class HasMoney extends State{    private CandyMachine candyMachine;    public HasMoney(CandyMachine candyMachine){        this.candyMachine = candyMachine;    }    protected void insertMoney() {        System.out.println(&quot;已经放入15分了。请不要再次放入&quot;);    }    protected void turnCrank() {        System.out.println(&quot;你转动了轮盘，等待糖果放出-------&quot;);        candyMachine.setCurrentState(candyMachine.getSoldSate());    }}</code></pre><ul><li>NoMoney</li></ul><pre><code class="java">public class NoMoney extends State{    private CandyMachine candyMachine;    public NoMoney(CandyMachine candyMachine){        this.candyMachine = candyMachine;    }    @Override    protected void insertMoney() {        System.out.println(&quot;你放入了15分,请你转动轮盘来获取糖果-------&quot;);        candyMachine.setCurrentState(candyMachine.getHasMoneyState());    }}</code></pre><ul><li>Sold</li></ul><pre><code class="java">public class Sold extends State{    private CandyMachine candyMachine;    public Sold(CandyMachine candyMachine){        this.candyMachine = candyMachine;    }    @Override    protected void distribute() {        if(candyMachine.getCount()&gt;0){            System.out.println(&quot;您好，这里是一个糖果-------&quot;);            candyMachine.setCount((candyMachine.getCount()-1));            candyMachine.setCurrentState(candyMachine.getNoMoneyState());        }else {            System.out.println(&quot;您好，不好意思，我们的糖果售空了，稍后将退钱给你-------&quot;);            candyMachine.setCurrentState(candyMachine.getSoldOutSate());            candyMachine.getCurrentState().returnMoney();        }    }}</code></pre><ul><li>SoldOut</li></ul><pre><code class="java">public class SoldOut extends State{    private CandyMachine candyMachine;    public SoldOut(CandyMachine candyMachine){        this.candyMachine = candyMachine;    }    @Override    protected void returnMoney() {        System.out.println(&quot;您好，不好意思，这里是给您退的15分-------&quot;);        candyMachine.setCurrentState(candyMachine.getNoMoneyState());    }}</code></pre><ul><li>CandyMachine：操作糖果机</li></ul><pre><code class="java">@Datapublic class CandyMachine {    private State noMoneyState;    private State hasMoneyState;    private State soldSate;    private State soldOutSate;    //糖果数量    private int count;    private State currentState;    public CandyMachine(int initCandyCount) {        count = initCandyCount;        noMoneyState = new NoMoney(this);        hasMoneyState = new HasMoney(this);        soldSate = new Sold(this);        soldOutSate = new SoldOut(this);        currentState = noMoneyState;    }    public void purchaseOneCandy(){        currentState.insertMoney();        currentState.turnCrank();        currentState.distribute();    }}</code></pre><ul><li>测试</li></ul><pre><code class="java">public class TestMain {    public static void main(String[] args) {        CandyMachine candyMachine = new CandyMachine(2);        candyMachine.purchaseOneCandy();        System.out.println(&quot;\n&quot;);        candyMachine.purchaseOneCandy();        System.out.println(&quot;\n&quot;);        candyMachine.purchaseOneCandy();    }}</code></pre><ul><li>输出</li></ul><pre><code class="java">你放入了15分,请你转动轮盘来获取糖果-------你转动了轮盘，等待糖果放出-------您好，这里是一个糖果-------你放入了15分,请你转动轮盘来获取糖果-------你转动了轮盘，等待糖果放出-------您好，这里是一个糖果-------你放入了15分,请你转动轮盘来获取糖果-------你转动了轮盘，等待糖果放出-------您好，不好意思，我们的糖果售空了，稍后将退钱给你-------您好，不好意思，这里是给您退的15分-------</code></pre><h3 id="状态模式和策略模式"><a href="#状态模式和策略模式" class="headerlink" title="状态模式和策略模式"></a>状态模式和策略模式</h3><p>你可以看到，状态模式的类图和策略模式基本一致，它俩很相同，但是最大的区别是<code>意图</code>不同。</p><ul><li>状态模式将行为封装在状态中，Context的行为委托于状态对象，随着时间改变自己的状态</li><li>策略模式是将行为封装起来，使用委托决定使用哪个行为</li></ul><p>Context有多个实例，共享状态对象：状态对象声明为<code>静态</code>的，通过引用传入</p><p>代码地址：<a href="https://github.com/ding-zou/design_patterns/tree/master/state_patterns" rel="external nofollow noopener noreferrer" target="_blank">Github状态模式</a></p>]]></content>
    
    <summary type="html">
    
      首先你可能会想用int值存储状态，实现状态切换，Java中很多地方都像这样使用，特别时并发JUC中，但是我们的设计模式将提供一个更符合设计原则，更有弹性的状态模式。(JUC中使用int存储状态是因为不想让一个并发类的实现需要依赖很多的状态类，int值已经可以满足需求，状态模式更多是针对系统的设计)。状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式——迭代器模式和组合模式</title>
    <link href="https://www.dzou.top/post/7244f815.html"/>
    <id>https://www.dzou.top/post/7244f815.html</id>
    <published>2019-08-11T04:54:09.000Z</published>
    <updated>2019-08-16T13:33:30.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之迭代器模式以及组合模式"><a href="#Java设计模式之迭代器模式以及组合模式" class="headerlink" title="Java设计模式之迭代器模式以及组合模式"></a>Java设计模式之迭代器模式以及组合模式</h2><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p><strong><em>迭代器模式：提供一种方法顺序访问一个聚合对象的各个元素，而又不暴露其内部的表示。</em></strong></p><blockquote></blockquote><ul><li>用于封装对象的遍历，无论是<code>数组</code>存储还是<code>ArrayList</code>，调用统一的接口，根据多态调用。</li></ul><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/21.png"><ul><li>迭代器接口：定义迭代器的方法</li><li>具体迭代器：实现不同对象的迭代器方法的不同实现</li></ul><p>迭代器模式让我们游走在聚合内的每一个元素，而又不暴露内部的实现。</p><h4 id="Head-first-设计模式例子"><a href="#Head-first-设计模式例子" class="headerlink" title="Head first 设计模式例子"></a>Head first 设计模式例子</h4><p>有一个饭店有多个菜单，由女招待把菜单的内容展示出来，这里使用迭代器模式，每个菜单都是由其他公司合并的，有不同的实现方式(数组、列表、链表)</p><ul><li>Menu</li></ul><pre><code class="java">public interface Menu {    public void addItem(String name,String price,String des);    public Iterator createIterator();}</code></pre><ul><li>MenuItem</li></ul><pre><code class="java">@Datapublic class MenuItem {    private String name;    private String des;    private String price;    public MenuItem(String name, String des, String price) {        this.name = name;        this.des = des;        this.price = price;    }}</code></pre><ul><li>Iterator</li></ul><pre><code class="java">public interface Iterator {    public Object next();    public boolean hasNext();}</code></pre><ul><li>列表式菜单——CakeMenu</li></ul><pre><code class="java">public class CakeMenu implements Menu {    private ArrayList&lt;MenuItem&gt; cakeItems;    public CakeMenu(){        cakeItems = new ArrayList&lt;&gt;();        addItem(&quot;Bread&quot;,&quot;10.00&quot;,&quot;面包&quot;);        addItem(&quot;Ice-cream&quot;,&quot;15.00&quot;,&quot;冰淇淋&quot;);        addItem(&quot;Cake&quot;,&quot;20.00&quot;,&quot;饼干&quot;);    }    public void addItem(String name,String price,String des) {        MenuItem item = new MenuItem(name,price,des);        cakeItems.add(item);    }    public Iterator createIterator() {        return new ListIterator(cakeItems);    }}</code></pre><ul><li>数组式菜单——CoffeeMenu</li></ul><pre><code class="java">public class CoffeeMenu implements Menu {    private MenuItem[] menuItems;    private final int MAX_SIZE = 10;    private int i;    public CoffeeMenu(){        menuItems = new MenuItem[MAX_SIZE];        addItem(&quot;Moka&quot;,&quot;10.00&quot;,&quot;摩卡咖啡&quot;);        addItem(&quot;Fragrant&quot;,&quot;15.00&quot;,&quot;香浓咖啡&quot;);        addItem(&quot;Milk&quot;,&quot;20.00&quot;,&quot;牛奶咖啡&quot;);    }    public void addItem(String name,String price,String des) {        MenuItem item = new MenuItem(name,price,des);        menuItems[i] = item;        i++;    }    public Iterator createIterator() {        return new ArrayIterator(menuItems);    }}</code></pre><ul><li>链表式菜单——DinnerMenu</li></ul><pre><code class="java">public class DinnerMenu implements Menu {    private LinkedList&lt;MenuItem&gt; dinnerItems;    private int i;    public DinnerMenu(){        dinnerItems = new LinkedList&lt;&gt;();        addItem(&quot;fish&quot;,&quot;100.00&quot;,&quot;糖醋鱼&quot;);        addItem(&quot;chicken&quot;,&quot;125.00&quot;,&quot;辣子鸡&quot;);        addItem(&quot;duck&quot;,&quot;200.00&quot;,&quot;北京烤鸭&quot;);    }    public void addItem(String name,String price,String des) {        MenuItem item = new MenuItem(name,price,des);        dinnerItems.add(item);    }    public Iterator createIterator() {        return new ListIterator(dinnerItems);    }}</code></pre><ul><li>ArrayIterator</li></ul><pre><code class="java">public class ArrayIterator implements Iterator {    private MenuItem[] menuItems;    private int index;    public ArrayIterator(MenuItem[] menuItems){        this.menuItems = menuItems;    }    @Override    public Object next() {        return menuItems[index++];    }    @Override    public boolean hasNext() {        if(index==menuItems.length||menuItems[index]==null){            return false;        }        return true;    }}</code></pre><ul><li>ListIterator</li></ul><pre><code class="java">public class ListIterator implements Iterator {    private List&lt;MenuItem&gt; menuItems;    private int index = 0;    public ListIterator(List&lt;MenuItem&gt; menuItems){        this.menuItems = menuItems;    }    @Override    public Object next() {        return menuItems.get(index++);    }    @Override    public boolean hasNext() {        if(index == menuItems.size()||menuItems.get(index)==null){            return false;        }        return true;    }}</code></pre><ul><li>Waitress</li></ul><pre><code class="java">public class Waitress {    private Menu cakeMenu;    private Menu coffeeMenu;    private Menu dinnerMenu;    public Waitress(Menu cakeMenu,Menu coffeeMenu,Menu dinnerMenu){        this.cakeMenu = cakeMenu;        this.coffeeMenu = coffeeMenu;        this.dinnerMenu = dinnerMenu;    }    public void printMenu(){        Iterator cakeI = cakeMenu.createIterator();        Iterator coffeeI = coffeeMenu.createIterator();        Iterator dinnerI = dinnerMenu.createIterator();        System.out.println(&quot;Menu is here:&quot;);        System.out.println(&quot;Cake:&quot;);        printMenu(cakeI);        System.out.println(&quot;Coffee:&quot;);        printMenu(coffeeI);        System.out.println(&quot;Dinner:&quot;);        printMenu(dinnerI);    }    private void printMenu(Iterator iterator) {        while (iterator.hasNext()){            MenuItem menuItem = (MenuItem) iterator.next();            System.out.println(menuItem);        }    }}</code></pre><ul><li>测试</li></ul><pre><code class="java">public static void main(String[] args) {        CakeMenu cakeMenu = new CakeMenu();        CoffeeMenu coffeeMenu = new CoffeeMenu();        DinnerMenu dinnerMenu = new DinnerMenu();        Waitress waitress = new Waitress(cakeMenu,coffeeMenu,dinnerMenu);        waitress.printMenu();    }——outputMenu is here:Cake:MenuItem{name=&#39;Bread&#39;, des=&#39;10.00&#39;, price=&#39;面包&#39;}MenuItem{name=&#39;Ice-cream&#39;, des=&#39;15.00&#39;, price=&#39;冰淇淋&#39;}MenuItem{name=&#39;Cake&#39;, des=&#39;20.00&#39;, price=&#39;饼干&#39;}Coffee:MenuItem{name=&#39;Moka&#39;, des=&#39;10.00&#39;, price=&#39;摩卡咖啡&#39;}MenuItem{name=&#39;Fragrant&#39;, des=&#39;15.00&#39;, price=&#39;香浓咖啡&#39;}MenuItem{name=&#39;Milk&#39;, des=&#39;20.00&#39;, price=&#39;牛奶咖啡&#39;}Dinner:MenuItem{name=&#39;fish&#39;, des=&#39;100.00&#39;, price=&#39;糖醋鱼&#39;}MenuItem{name=&#39;chicken&#39;, des=&#39;125.00&#39;, price=&#39;辣子鸡&#39;}MenuItem{name=&#39;duck&#39;, des=&#39;200.00&#39;, price=&#39;北京烤鸭&#39;}</code></pre><h3 id="单一原则"><a href="#单一原则" class="headerlink" title="单一原则"></a>单一原则</h3><p>新的设计原则：</p><ul><li>单一原则：一个类应该只有一个引起变化的原因。</li></ul><blockquote><p>内聚：度量一个类或者模块的紧密程度。</p><ul><li>当一类或模块被设计成支持一组不相关的功能时，它具有低内聚</li><li>被设计成支持一组相关的功能时，具有高内聚</li></ul></blockquote><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p><strong><em>组合模式：允许你将对象组合成树型结构来表现整体/部分。组合能让客户以一致的方式处理个别对象以及对象组合。</em></strong></p><p>以上面这个例子来说就是：我们的菜单中出现新的小菜单时，让我们处理<code>MenuItem</code>的方式和处理<code>小菜单</code>的方式是一样的，客户不需要知道它具体处理的是什么，因为它会根据多态进行处理。换句话说：我们可以忽略组合和个别对象的差别。</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/22.png"><ul><li>所以他们必须有相同的基类型</li></ul><blockquote><p>组合模式让我们用树型的方式创建对象的结构，树中包含了<code>组合</code>和<code>个别的对象</code>。</p></blockquote><p>菜单需求：大菜单中有小菜单(对象组合)和食物(个别对象)，形成树型结构</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/23.png"><h4 id="修改后"><a href="#修改后" class="headerlink" title="修改后"></a>修改后</h4><ul><li><p>MenuComponent</p><blockquote><p>这里把菜单组件类定义为抽象类是因为<code>Item</code>和<code>Menu</code>没必要全部实现这些方法，各自实现需要用到的就好了，没有用到的被调用的话使用该抽象类提供的默认实现：抛出不支持异常。(Java中Iterator就是这种实现)</p></blockquote></li></ul><pre><code class="java">public abstract class MenuComponent {    public void add(MenuComponent menuComponent){        throw new UnsupportedOperationException();    }    public void remove(MenuComponent menuComponent){        throw new UnsupportedOperationException();    }    public MenuComponent getChild(int i){        throw new UnsupportedOperationException();    }    public String getName(){        throw new UnsupportedOperationException();    }    public String getDes(){        throw new UnsupportedOperationException();    }    public String getPrice(){        throw new UnsupportedOperationException();    }    public void print(){        throw new UnsupportedOperationException();    }}</code></pre><ul><li>Menu(对象组合)</li></ul><pre><code class="java">public class Menu extends MenuComponent {    private ArrayList&lt;MenuComponent&gt; menuList;    private String name;    private String des;    public Menu(String name,String des){        menuList = new ArrayList&lt;&gt;();        this.des = des;        this.name = name;    }    @Override    public void print() {        System.out.println(&quot;menu name:&quot;+getName()+                &quot;\n&quot;+&quot;menu des:&quot;+getDes());        Iterator iterator = menuList.iterator();        while (iterator.hasNext()){            MenuComponent component = (MenuComponent) iterator.next();            component.print();        }    }    @Override    public String getName() {        return name;    }    @Override    public String getDes() {        return des;    }    @Override    public MenuComponent getChild(int i) {        return menuList.get(i);    }    @Override    public void add(MenuComponent menuComponent) {        menuList.add(menuComponent);    }    @Override    public void remove(MenuComponent menuComponent) {        menuList.remove(menuComponent);    }}</code></pre><ul><li>MenuItem(个别对象)</li></ul><pre><code class="java">public class MenuItem extends MenuComponent {    private String name;    private String des;    private String price;    public MenuItem(String name, String des, String price) {        this.name = name;        this.des = des;        this.price = price;    }    @Override    public String getDes() {        return des;    }    @Override    public String getPrice() {        return price;    }    @Override    public String getName() {        return name;    }    @Override    public void print() {        System.out.println(&quot;MenuItem{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, des=&#39;&quot; + des + &#39;\&#39;&#39; +                &quot;, price=&#39;&quot; + price + &#39;\&#39;&#39; +                &#39;}&#39;);    }}</code></pre><ul><li>Waitress</li></ul><pre><code class="java">public class Waitress {    private MenuComponent allMenus;    public Waitress(MenuComponent allMenus){        this.allMenus = allMenus;    }    public void printMenu(){        allMenus.print();    }}</code></pre><ul><li>测试</li></ul><pre><code class="java"> public static void main(String[] args) {        MenuComponent cakeMenu = new Menu(&quot;cake&quot;,&quot;饼干类&quot;);        MenuComponent dinnerMenu = new Menu(&quot;dinner&quot;,&quot;晚餐&quot;);        MenuComponent coffeeMenu = new Menu(&quot;coffee&quot;,&quot;小吃甜点咖啡&quot;);        cakeMenu.add(new MenuItem(&quot;Bread&quot;,&quot;10.00&quot;,&quot;面包&quot;));        cakeMenu.add(new MenuItem(&quot;Ice-cream&quot;,&quot;15.00&quot;,&quot;冰淇淋&quot;));        cakeMenu.add(new MenuItem(&quot;Cake&quot;,&quot;20.00&quot;,&quot;饼干&quot;));        coffeeMenu.add(new MenuItem(&quot;Moka&quot;,&quot;10.00&quot;,&quot;摩卡咖啡&quot;));        coffeeMenu.add(new MenuItem(&quot;Fragrant&quot;,&quot;15.00&quot;,&quot;香浓咖啡&quot;));        coffeeMenu.add(new MenuItem(&quot;Milk&quot;,&quot;20.00&quot;,&quot;牛奶咖啡&quot;));        dinnerMenu.add(new MenuItem(&quot;fish&quot;,&quot;100.00&quot;,&quot;糖醋鱼&quot;));        dinnerMenu.add(new MenuItem(&quot;chicken&quot;,&quot;125.00&quot;,&quot;辣子鸡&quot;));        dinnerMenu.add(new MenuItem(&quot;duck&quot;,&quot;200.00&quot;,&quot;北京烤鸭&quot;));        MenuComponent allMenus = new Menu(&quot;allMenus&quot;,&quot;所有菜单&quot;);        allMenus.add(cakeMenu);        allMenus.add(dinnerMenu);        allMenus.add(coffeeMenu);        Waitress waitress = new Waitress(allMenus);        waitress.printMenu();    }</code></pre><ul><li>output</li></ul><pre><code class="java">menu name:allMenusmenu des:所有菜单menu name:cakemenu des:饼干类MenuItem{name=&#39;Bread&#39;, des=&#39;10.00&#39;, price=&#39;面包&#39;}MenuItem{name=&#39;Ice-cream&#39;, des=&#39;15.00&#39;, price=&#39;冰淇淋&#39;}MenuItem{name=&#39;Cake&#39;, des=&#39;20.00&#39;, price=&#39;饼干&#39;}menu name:dinnermenu des:晚餐MenuItem{name=&#39;fish&#39;, des=&#39;100.00&#39;, price=&#39;糖醋鱼&#39;}MenuItem{name=&#39;chicken&#39;, des=&#39;125.00&#39;, price=&#39;辣子鸡&#39;}MenuItem{name=&#39;duck&#39;, des=&#39;200.00&#39;, price=&#39;北京烤鸭&#39;}menu name:coffeemenu des:小吃甜点咖啡MenuItem{name=&#39;Moka&#39;, des=&#39;10.00&#39;, price=&#39;摩卡咖啡&#39;}MenuItem{name=&#39;Fragrant&#39;, des=&#39;15.00&#39;, price=&#39;香浓咖啡&#39;}MenuItem{name=&#39;Milk&#39;, des=&#39;20.00&#39;, price=&#39;牛奶咖啡&#39;}</code></pre><p><strong><em>但是这么一看，好像违反了单一原则，一个类不但要管理Item还要管理Menu</em></strong></p><ul><li>但是它这样做得到的是对象和对象组合的一致，被一视同仁对待。如果加了判断是否为Item和Menu的代码就失去了在这种性质</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>迭代器模式：</p><ul><li>迭代器允许访问聚合的元素，而不需要暴露它内部实现。</li><li>迭代器将遍历工作封装进对象中，解决不同的遍历实现。</li><li>迭代器提供一个通用接口遍历，根据多态机制。</li><li>努力使用一个类一个责任原则</li></ul><p>组合模式：</p><ul><li>提供一个树型结构存储对象和对象组合</li><li>组合模式将单个对象和对象组合一视同仁</li><li>任意对象或组合都是一个组件(抽象基类继承)</li><li>透明性：客户将组合和对象一视同仁</li></ul><p>总结一下学到的设计原则：</p><ul><li><p>类应该对扩展开放，对修改关闭</p></li><li><p>把变化的抽取出来，不要和不变化的放在一起。</p></li><li><p>针对接口编程，不针对实现编程。</p></li><li><p>多用组合，少用继承。</p></li><li><p>单一原则：一个类应该只有一个引起变化的原因。</p></li><li><p>依赖倒置：要依赖抽象，不依赖具体类。</p></li><li><p>为了交互对象之间的松耦合的设计而努力。</p></li><li><p>好莱坞原则：别调用我们，我们会调用你。</p></li><li><p>最少设计原则：只和你的密友谈话(减少耦合)。</p></li></ul><p>代码地址：<a href="https://github.com/ding-zou/design_patterns/tree/master/iterator_patterns" rel="external nofollow noopener noreferrer" target="_blank">Github迭代器模式</a>  <a href="https://github.com/ding-zou/design_patterns/tree/master/composite_patterns" rel="external nofollow noopener noreferrer" target="_blank">Github组合模式</a></p>]]></content>
    
    <summary type="html">
    
      迭代器模式：提供一种方法顺序访问一个聚合对象的各个元素，而又不暴露其内部的表示.迭代器模式：提供一种方法顺序访问一个聚合对象的各个元素，而又不暴露其内部的表示
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式——模板方法模式</title>
    <link href="https://www.dzou.top/post/55d3fc38.html"/>
    <id>https://www.dzou.top/post/55d3fc38.html</id>
    <published>2019-08-10T11:25:22.000Z</published>
    <updated>2019-08-16T13:36:05.333Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之模板方法模式"><a href="#Java设计模式之模板方法模式" class="headerlink" title="Java设计模式之模板方法模式"></a>Java设计模式之模板方法模式</h2><p><strong><em>模板方法：定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。</em></strong></p><p>模板方法使得子类在可以不改变算法结构的情况下，重新定义算法的某些步骤。</p><blockquote><p>这个模式用来定义一个模板方法，这个方法将总的算法定义成多个步骤，其中步骤可以是抽象的，由子类负责实现；其中不变的步骤(共有的)由该抽象类本身实现。（和策略模式很像，但是策略模式使用组合，更加解耦）</p></blockquote><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/20.png"><h3 id="方法分为三种"><a href="#方法分为三种" class="headerlink" title="方法分为三种"></a>方法分为三种</h3><ol><li><strong>抽象方法</strong>：一个抽象方法由抽象类声明、由其具体子类实现。</li><li><strong>具体方法</strong>：一个具体方法由一个抽象类或具体类声明并实现。</li><li><strong>钩子方法</strong>：一个钩子方法由一个抽象类或具体类声明并实现，而其子类可能会加以扩展。通常在父类中给出的实现是一个空实现，并以该空实现作为方法的默认实现，当然钩子方法也可以提供一个非空的默认实现。</li></ol><h3 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h3><p>钩子方法是指步骤中<code>可选的</code>部分，可以使用钩子为某些步骤做判断是否要执行</p><h4 id="挂钩"><a href="#挂钩" class="headerlink" title="挂钩"></a>挂钩</h4><p>与某些步骤有关系(挂钩)的钩子方法。</p><pre><code class="java">//这个wantCondiments就是一个挂钩if(wantCondiments()) {            addCondiments();        }</code></pre><h3 id="Head-first-设计模式案例"><a href="#Head-first-设计模式案例" class="headerlink" title="Head first 设计模式案例"></a>Head first 设计模式案例</h3><p><strong><em>饮料类的生产步骤：</em></strong></p><ol><li>烧水</li><li>冲泡</li><li>等待</li><li>加原料</li></ol><p>其中<code>2</code>和<code>4</code>是抽象方法，不同饮料有不同的实现，<code>1</code>和<code>3</code>是不变的，具体的实现，由抽象类完成；判断用户<code>是否需要加原料</code>就是一个钩子hook。</p><pre><code class="java">public abstract class Drinks {    /**     * 这就是模板方法 里面调用了相关的算法（自己实现的和抽象的由子类实现的）     */    final void prepareDrinks(){        //烧水        boilWater();        //冲泡        pourCup();        //等待        waitForWhile();        //添加原料        //wantCondiments是挂钩        if(wantCondiments()) {            addCondiments();        }    }    protected boolean wantCondiments() {        return true;    }    private void boilWater(){        System.out.println(&quot;步骤一：正在烧水&quot;);    }    protected abstract void pourCup();    protected abstract void addCondiments();    private void waitForWhile(){        System.out.println(&quot;步骤三：等待5分钟&quot;);    }}</code></pre><ul><li>咖啡</li></ul><pre><code class="java">public class CoffeeDrinks extends Drinks{    protected void pourCup() {        System.out.println(&quot;步骤二：倒入咖啡粉冲泡&quot;);    }    protected void addCondiments() {        System.out.println(&quot;步骤四：添加牛奶、摩卡和奶泡&quot;);    }    @Override    protected boolean wantCondiments() {        try {            char want = getUserInput();            return want == &#39;y&#39;;        } catch (IOException e) {            e.printStackTrace();        }        return super.wantCondiments();    }    private char getUserInput() throws IOException {        System.out.println(&quot;请输入你是否需要添加原料(y/n):&quot;);        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));        return  (char) in.read();    }}</code></pre><ul><li>茶水</li></ul><pre><code class="java">public class TeaDrinks extends Drinks{    protected void pourCup() {        System.out.println(&quot;步骤二：添加茶叶冲泡&quot;);    }    protected void addCondiments() {        System.out.println(&quot;步骤四：放入少量的柠檬&quot;);    }    @Override    protected boolean wantCondiments() {        try {            char want = getUserInput();            return want == &#39;y&#39;;        } catch (IOException e) {            e.printStackTrace();        }        return super.wantCondiments();    }    private char getUserInput() throws IOException {        System.out.println(&quot;请输入你是否需要添加原料(y/n):&quot;);        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));        return  (char) in.read();    }}</code></pre><ul><li>测试结果</li></ul><pre><code class="java">步骤一：正在烧水步骤二：倒入咖啡粉冲泡步骤三：等待5分钟请输入你是否需要添加原料(y/n):n步骤一：正在烧水步骤二：添加茶叶冲泡步骤三：等待5分钟请输入你是否需要添加原料(y/n):y步骤四：放入少量的柠檬</code></pre><h3 id="好莱坞原则"><a href="#好莱坞原则" class="headerlink" title="好莱坞原则"></a>好莱坞原则</h3><p><strong><em>新的设计原则：</em></strong></p><ul><li>好莱坞原则：别调用我们，我们会调用你。(高层组件对待低层组件的方式)</li></ul><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/19.png"><h3 id="好莱坞原则和模板方法"><a href="#好莱坞原则和模板方法" class="headerlink" title="好莱坞原则和模板方法"></a>好莱坞原则和模板方法</h3><p>定义算法的抽象类就是我们的高层组件，它的子类就是低层组件，低层组件无法调用高层组件，减少<code>依赖</code></p><ul><li><code>依赖倒置原则</code>教我们少用具体实现类，多用接口、抽象。</li><li><code>好莱坞原则</code>是一种创建算法、框架的技巧，减少依赖。</li></ul><h3 id="JDK中模板方法"><a href="#JDK中模板方法" class="headerlink" title="JDK中模板方法"></a>JDK中模板方法</h3><ul><li>数组的<code>sort</code>方法</li><li>swing的<code>paint</code>方法</li></ul><h3 id="策略模式和模板方法模式"><a href="#策略模式和模板方法模式" class="headerlink" title="策略模式和模板方法模式"></a>策略模式和模板方法模式</h3><ul><li>策略模式使用组合，模板方法使用继承</li><li>模板方法模式需要更少的对象</li><li>策略模式更有弹性(组合)，模板方法模式耦合度高，依赖多</li></ul><p>代码地址：<a href="https://github.com/ding-zou/design_patterns/tree/master/template_patterns" rel="external nofollow noopener noreferrer" target="_blank">Github模板方法模式</a></p>]]></content>
    
    <summary type="html">
    
      模板方法：定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。这个模式用来定义一个模板方法，这个方法将总的算法定义成多个步骤，其中步骤可以是抽象的，由子类负责实现；其中不变的步骤(共有的)由该抽象类本身实现。（和策略模式很像，但是策略模式使用组合，更加解耦）
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式——适配器模式及外观模式</title>
    <link href="https://www.dzou.top/post/519a7c00.html"/>
    <id>https://www.dzou.top/post/519a7c00.html</id>
    <published>2019-08-08T04:41:33.000Z</published>
    <updated>2019-08-16T13:37:21.750Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之适配器模式和外观模式"><a href="#Java设计模式之适配器模式和外观模式" class="headerlink" title="Java设计模式之适配器模式和外观模式"></a>Java设计模式之适配器模式和外观模式</h2><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p><strong><em>适配器模式：将一个类的接口，转换成客户期望的有两个接口。适配器让原来的接口不兼容的类可以合作无间。</em></strong></p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/16.png"><ul><li>类适配器：多重继承完成，Java中不允许，高耦合</li><li>对象适配器：只用组合完成，低耦合</li></ul><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/18.png"><ol><li>创建目标接口</li></ol><pre><code class="java">public interface Target {    //这是源类Adapteee没有的方法    public void Request(); }</code></pre><ol start="2"><li>创建被适配器</li></ol><pre><code class="java">public class Adaptee {    public void SpecificRequest(){    }}</code></pre><ol start="3"><li>创建适配器类（Adapter）</li></ol><pre><code class="java">class Adapter implements Target{      // 直接关联被适配类      private Adaptee adaptee;      // 可以通过构造函数传入具体需要适配的被适配类对象      public Adapter (Adaptee adaptee) {          this.adaptee = adaptee;      }      @Override    public void Request() {          // 这里是使用委托的方式完成特殊功能          this.adaptee.SpecificRequest();      }  }  </code></pre><ol start="4"><li>适配器使用</li></ol><pre><code class="java">public class AdapterPattern {    public static void main(String[] args){        //需要先创建一个被适配类的对象作为参数          Target mAdapter = new Adapter(new Adaptee())；        mAdapter.Request();    }}</code></pre><h4 id="适配器模式实际应用"><a href="#适配器模式实际应用" class="headerlink" title="适配器模式实际应用"></a>适配器模式实际应用</h4><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/17.png"><p>JDK以前使用<code>Enumeration</code>枚举接口遍历，现在使用<code>Iterator</code>迭代器</p><pre><code class="java">public interface Enumeration&lt;E&gt; {    boolean hasMoreElements();    E nextElement();}</code></pre><pre><code class="java">public interface Iterator&lt;E&gt; {    boolean hasNext();    E next();    default void remove() {        throw new UnsupportedOperationException(&quot;remove&quot;);    }}</code></pre><p>我们写一个适配器将<code>枚举</code>适配到<code>迭代器</code></p><ul><li>目标接口：迭代器</li><li>被适配接口：枚举接口</li></ul><p><code>Enumeration</code>的<code>hasMoreElements</code>就对应<code>Iterator</code>的<code>hasNext</code>；<code>nextElement</code>对应<code>next</code>；</p><p>Enumeration不支持<code>remove</code>，就像Iterator设计好的，抛出一个不支持的运行时异常。</p><pre><code class="java">public class EnumerationIteratorAdapter implements Iterator {    private Enumeration enumeration;    public EnumerationIteratorAdapter(Enumeration enumeration){        this.enumeration = enumeration;    }    public boolean hasNext() {        return enumeration.hasMoreElements();    }    public Object next() {        return enumeration.nextElement();    }    public void remove() {        throw new UnsupportedOperationException();    }}</code></pre><p>测试：<code>Vector</code></p><pre><code class="java">public static void main(String[] args) {        Vector&lt;Double&gt; vector = new Vector&lt;&gt;();        vector.add(12.21);        vector.add(10.26);        EnumerationIteratorAdapter enumerationIteratorAdapter = new EnumerationIteratorAdapter(vector.elements());        double a;        while (enumerationIteratorAdapter.hasNext()){            a = (double) enumerationIteratorAdapter.next();            System.out.println(a);        }    }</code></pre><p>我们再写一个适配器将<code>枚举</code>适配到<code>迭代器</code></p><ul><li>被适配接口：迭代器</li><li>目标接口：枚举接口</li></ul><pre><code class="java">public class IteratorEnumerationAdapter implements Enumeration {    private Iterator iterator;    public IteratorEnumerationAdapter(Iterator iterator){        this.iterator = iterator;    }    public boolean hasMoreElements() {        return iterator.hasNext();    }    public Object nextElement() {        return iterator.next();    }}</code></pre><p>测试：<code>ArrayList</code></p><pre><code class="java">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;1&quot;);        list.add(&quot;2&quot;);        list.add(&quot;3&quot;);        list.add(&quot;4&quot;);        IteratorEnumerationAdapter iteratorEnumerationAdapter = new IteratorEnumerationAdapter(list.iterator());        String a = &quot;&quot;;        while (iteratorEnumerationAdapter.hasMoreElements()){            a = (String) iteratorEnumerationAdapter.nextElement();            System.out.println(a);        }</code></pre><h4 id="装饰者和适配器"><a href="#装饰者和适配器" class="headerlink" title="装饰者和适配器"></a>装饰者和适配器</h4><ul><li>适配器：存在不被客户知道，客户只知道请求对应的行为，适配器帮助客户和被适配者解耦，<code>将一个接口转换为另一个接口</code></li><li>装饰者：<code>不改变接口，但加入责任</code></li><li>适配器将一个对象包装起来以改变其接口，装饰者将对象包装起来以增加新的行为或者责任。</li></ul><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p><strong><em>外观模式：提供了一个同一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</em></strong></p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/15.png"><p><code>新的设计原则</code>：</p><ul><li>最少设计原则：只和你的密友谈话</li></ul><p>设计中不要让太多的类耦合在一起，免得修改系统中的一部分又会影响到另一部分。如果系统各个部分依赖太多，这个系统会需要大量成本维护。</p><p>像下面这个代码：</p><pre><code class="java">public void getTemp(){    //耦合了三个类    return station.getFirstTemp().getSecondTemp();}</code></pre><p>该原则缺点：</p><p>虽然减少了对象的依赖，但是也会导致更多的类被创建出来用于处理组件的沟通，导致系统复杂度高，并且降低性能。</p><h4 id="外观模式的使用"><a href="#外观模式的使用" class="headerlink" title="外观模式的使用"></a>外观模式的使用</h4><p>一个私人影院由多个子系统构成:DVD播放器、投影仪、自动屏幕、环绕立体声、爆米花机</p><p>你每次观影之前需要做很多准备工作，结束还要做很多清理工作</p><p>我们可以使用外观模式，提供一个更合理的接口类，简化你的子系统的使用。</p><ul><li>该外观接口中有<code>watchMovie</code>方法，里面综合了各个子系统需要做的一切准备工作</li><li><code>endMovie</code>方法综合了所有的清理工作</li></ul><p>接口</p><pre><code class="java">public interface HomeTheaterFacadeAPI {    public void watchMovie();    public void endMovie();}</code></pre><pre><code class="java">public class HomeTheaterFacade implements HomeTheaterFacadeAPI{    private Amplifier amplifier;    private CDplayer cDplayer;    private DVDplayer dvDplayer;    private PopCornPopper popCornPopper;    private Screen screen;    private TheaterLight theaterLight;    private Projector projector;    public HomeTheaterFacade(Amplifier amplifier,                             CDplayer cDplayer,                             DVDplayer dvDplayer,                             PopCornPopper popCornPopper,                             Screen screen,                             TheaterLight theaterLight,                             Projector projector){        this.amplifier = amplifier;        this.cDplayer = cDplayer;        this.dvDplayer = dvDplayer;        this.popCornPopper = popCornPopper;        this.screen = screen;        this.theaterLight = theaterLight;        this.projector = projector;    }    public void watchMovie() {        System.out.println(&quot;准备开始看电影&quot;);        popCornPopper.on();        popCornPopper.pop();        theaterLight.dim(10);        screen.down();        projector.open();        amplifier.on();        amplifier.setDvdAndCd();        amplifier.setVolume(20);        dvDplayer.open();        cDplayer.open();    }    public void endMovie() {        System.out.println(&quot;正在关闭设备&quot;);        popCornPopper.close();        theaterLight.close();        screen.up();        projector.close();        amplifier.close();        dvDplayer.close();        cDplayer.close();    }}</code></pre><h3 id="外观模式和适配器的使用"><a href="#外观模式和适配器的使用" class="headerlink" title="外观模式和适配器的使用"></a>外观模式和适配器的使用</h3><ul><li>当需要一个现有类而接口不符合要求时，使用适配器。</li><li>当需要简化并统一一个很大的接口或者一群很复杂接口时，使用外观。(将客户和子系统解耦)</li></ul><p>代码地址：<a href="https://github.com/ding-zou/design_patterns/tree/master/adapter_patterns" rel="external nofollow noopener noreferrer" target="_blank">Github适配器模式</a>  <a href="https://github.com/ding-zou/design_patterns/tree/master/facade_patterns" rel="external nofollow noopener noreferrer" target="_blank">Github外观模式</a></p>]]></content>
    
    <summary type="html">
    
      适配器模式：将一个类的接口，转换成客户期望的有两个接口。适配器让原来的接口不兼容的类可以合作无间。外观模式：提供了一个同一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式——命令模式</title>
    <link href="https://www.dzou.top/post/667421d7.html"/>
    <id>https://www.dzou.top/post/667421d7.html</id>
    <published>2019-08-07T15:54:07.000Z</published>
    <updated>2019-08-16T13:35:24.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之命令模式"><a href="#Java设计模式之命令模式" class="headerlink" title="Java设计模式之命令模式"></a>Java设计模式之命令模式</h2><p>他能帮助我们将<code>动作的请求者</code>和<code>动作的执行者</code>解耦</p><p>把请求封装（打开灯）成一个特定对象（打开厨房灯）</p><p><strong><em>命令模式：将“请求”封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象，命令模式也可以支持可撤销的操作。</em></strong></p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/14.png"><p>遥控器当按下按键时，把控制灯开关、门开关的的请求提交，把请求提交给相应的<code>命令对象</code>执行其接受者对应的行为。</p><ul><li>测试类就是客户，创建很多命令对象，把它加载到遥控器卡槽</li><li>遥控器就是命令模式的客户，提交请求，通过<code>setCommand</code>方法把命令传给调用者</li><li>灯、车库就是具体的接受者，具有相应的行为</li><li>命令对象就是打开关闭灯、打开关闭门灯命令对象</li></ul><p>命令对象在遥控器中初始化时，使用了空对象<code>NoCommand</code>，也是一种设计模式，避免进行不必要的判断</p><pre><code class="java">//非空判断if(object!=null){    ....}</code></pre><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/13.png"><p>撤销功能：可以使用<code>添加状态变量</code>来获取前一次状态</p><p>多次撤销：可以使用<code>堆栈</code>记录每一次调用状态，撤销时从<code>堆栈</code>中取出</p><p>为什么命令对象不实现具体的<code>execute</code>方法？</p><p>答：我们尽量使用<code>傻瓜</code>的命令对象，不许关注接受者实现细节，实现调用者和接受者解耦。</p><h2 id="命令模式用途"><a href="#命令模式用途" class="headerlink" title="命令模式用途"></a>命令模式用途</h2><h3 id="队列请求"><a href="#队列请求" class="headerlink" title="队列请求"></a>队列请求</h3><p>命令可以将运算块打包，将他传来传去，命令对象创建许久后依然可以调用运算。</p><p>可以实现：日程安排、线程池、工作队列</p><h4 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h4><p>你在一端添加命令，在另一端使用线程依次取出命令并执行</p><h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>我们执行命令时将历史记录存储在磁盘里。一旦系统死机，我们就可以利用命令对象重新加载，依次调用他们的execute方法（使用序列化实现）</p><p>代码地址：<a href="https://github.com/ding-zou/design_mode/tree/master/command_patterns" rel="external nofollow noopener noreferrer" target="_blank">Github命令模式</a></p>]]></content>
    
    <summary type="html">
    
      命令模式：将“请求”封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象，命令模式也可以支持可撤销的操作。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java 设计模式——工厂模式</title>
    <link href="https://www.dzou.top/post/4caa56ee.html"/>
    <id>https://www.dzou.top/post/4caa56ee.html</id>
    <published>2019-08-06T04:56:52.000Z</published>
    <updated>2019-08-16T13:34:00.964Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之工厂模式"><a href="#Java设计模式之工厂模式" class="headerlink" title="Java设计模式之工厂模式"></a>Java设计模式之工厂模式</h2><p>工厂模式有下面两种:</p><ol><li><p>简单工厂模式</p></li><li><p>工厂方法模式</p></li><li><p>抽象工厂模式</p></li></ol><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><ul><li><p>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</p></li><li><p>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</p></li><li><p>工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。</p></li></ul><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p><strong><em>工厂方法模式：定义了一个创建对象的接口，但由子类决定要实例化哪一个。工厂方法把类实例化延迟到子类。抽象工厂模式：提供一个接口，用于创建相关或者依赖对象的家族，而不需要明确指定具体类。</em></strong></p><p><code>接口</code>，广义的说法，指的是<code>抽象类或方法</code>和<code>接口或接口方法</code></p><ul><li>创建者类：抽象类，定义了一个抽象工厂方法，让子类实现此方法制造产品。</li><li>具体创建者类：创建者的子类，实现了工厂方法，由该子类决定要实例化哪一个类不代表子类真正决定创建哪一个产品，而是说编写创建者类时，不需要具体知道需要创建哪一个类，而是根据选择哪一个类，就自然在运行时创建该产品类。</li><li>产品类：抽象类或接口，实现该产品接口创建具体的产品类，在使用时只需要把引用指向他，而不是具体的类(<code>多态</code>)。</li></ul><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/11.png"><p>这样做的目的：</p><ul><li>使用子类实现创建产品帮助我们将产品的<code>实现</code>和<code>使用</code>解耦，需要增加产品或者改变产品的实现时，创建者都不受影响。</li><li>客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可。</li></ul><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/12.png"><h4 id="依赖倒置"><a href="#依赖倒置" class="headerlink" title="依赖倒置"></a>依赖倒置</h4><p>设计原则：</p><ul><li>要依赖抽象，不依赖具体类。</li></ul><blockquote><p>不能让<code>高层组件</code>依赖<code>低层组件</code>。高层组件：由其他低层组件定义其行为的类（有低层组件构成，具体更复杂的功能），面向接口编程的思想。</p></blockquote><p>问题：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/9.png"><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p><strong><em>抽象工厂模式：提供一个接口，用于创建相关或者依赖对象的家族，而不需要明确指定具体类。</em></strong></p><p>接口中创建每个产品的接口就使用了工厂方法。</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/10.png"><h3 id="普通工厂、抽象工厂模式和工厂方法模式比较"><a href="#普通工厂、抽象工厂模式和工厂方法模式比较" class="headerlink" title="普通工厂、抽象工厂模式和工厂方法模式比较"></a>普通工厂、抽象工厂模式和工厂方法模式比较</h3><p>比较：</p><ul><li><p>普通工厂不是一种设计模式，但是实现了对象创建的封装和松耦合</p></li><li><p>工厂方法使用继承：把创建委托给子类，子类实现工厂方法创建产品</p></li><li><p>抽象工厂使用组合：对象的创建被实现接口方法的类创建</p></li></ul><p>优点：</p><ul><li>都实现松耦合，把应用程序和具体类促进解耦</li><li>依赖倒置原则：避免依赖具体对象，尽量依赖抽象</li></ul><p>使用：</p><ul><li>抽象工厂：当你需要创建一整套产品家族时使用</li><li>工厂方法：把产品使用和实例化解耦。如果你不知道要实例化哪些类时可以使用。</li></ul><p>代码地址：<a href="https://github.com/ding-zou/design_mode/tree/master/facotory_patterns" rel="external nofollow noopener noreferrer" target="_blank">Github工厂模式</a></p>]]></content>
    
    <summary type="html">
    
      工厂方法模式：定义了一个创建对象的接口，但由子类决定要实例化哪一个。工厂方法把类实例化延迟到子类。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式——装饰者模式</title>
    <link href="https://www.dzou.top/post/1b3210b0.html"/>
    <id>https://www.dzou.top/post/1b3210b0.html</id>
    <published>2019-08-05T04:04:46.000Z</published>
    <updated>2019-08-16T13:38:00.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之装饰者模式"><a href="#Java设计模式之装饰者模式" class="headerlink" title="Java设计模式之装饰者模式"></a>Java设计模式之装饰者模式</h2><p>前面两篇文章介绍了四个设计模式的原则：</p><ul><li>把变化的抽取出来，不要和不变化的放在一起</li><li>针对接口编程，不针对实现编程</li><li>多用组合，少用继承</li><li>为了交互对象之间的松耦合的设计而努力。</li></ul><p>现在我们要介绍最重要的设计原则：</p><ul><li>类应该对扩展开放，对修改关闭</li></ul><p><strong><em>装饰者模式：动态地将责任附加到对象上。若要扩展功能，装饰者提供比继承更有弹性的替代方案。</em></strong></p><p>可以动态地给对象添加一些额外的属性或者行为</p><p>装饰者模式：</p><ul><li>装饰者和被装饰者有相同的超类</li><li>可以用一个或者多个装饰者包装一个对象</li><li>因为装饰者和被装饰者有相同的超类，所以在任何需要原始对象（被包装的）的时候，你都可以用装饰过的对象替代。</li><li>装饰者可以在被装饰者的行为前后添加自己的行为。</li><li>装饰者可以如何时候被装饰，可以运行时动态地装饰对象。</li></ul><h3 id="Head-First-设计模式中案例"><a href="#Head-First-设计模式中案例" class="headerlink" title="Head First 设计模式中案例"></a>Head First 设计模式中案例</h3><p>星巴克做的咖啡有很多种类，我们想在这些咖啡上添加一些原料（牛奶、豆浆、奶泡、摩卡），还有咖啡的规格Size（大中小），我们决定使用装饰者模式来完成</p><ul><li><p>装饰者就是具体的原料类</p></li><li><p>被装饰者就是具体咖啡类</p></li></ul><p>我们使用一个抽象的<code>Beverage</code>类描述星巴克的咖啡（当然也可以使用接口），各个不同种类的咖啡继承该抽象类，我们还需要一个抽象的装饰者类，继承该装饰者类实现具体的原料装饰类，根据装饰者模式的<code>被装饰者和装饰者用相同的超类</code>，我们的装饰者抽象类需要继承<code>Beverage</code>类</p><p>计算价格我们要调用最外层的<code>cost</code>方法，每一层会委托<code>它装饰的对象-被装饰者</code>计算出价格</p><p>当我们最外层装饰者为奶泡<code>Whip</code>时，它会委托给上一层装饰者摩卡<code>Mocha</code>计算出摩卡所装饰的具体咖啡的价格+摩卡的价格；然后再加上自己奶泡的价格。(之所以可以这样实现调用多层cost是因为他们都来自一个超类对象)</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/6.png"><p>Beverage类：</p><pre><code class="java">public abstract class Beverage {    //规格    protected Size size = Size.UNKNOWN;    public void setSize(Size size){        this.size = size;    }    //描述    protected String description = &quot;unKnown Beverage&quot;;    public String getDescription(){        return description;    }    //价格    public abstract double cost();}</code></pre><p>我们使用枚举类定义Size：</p><ul><li>小杯+0.1元</li><li>中杯+0.15元</li><li>大杯+0.2元</li></ul><pre><code class="java">public enum Size {    SMALL(0.10)    ,MEDIUM(0.15)    ,BIG(0.20)    ,UNKNOWN(0);    private double cost;    Size(double v) {        cost = v;    }    public double getCost(){return cost;}}</code></pre><p>三个具体的咖啡类：</p><pre><code class="java">/** * 深培咖啡 */public class DarkRoast extends Beverage{    //构造时传入规格    public DarkRoast(Size size){        setSize(size);        if(this.size==Size.UNKNOWN){            throw new RuntimeException();        }        description = &quot;DarkRoast &quot;+this.size.name();    }//30.00元+规格需加的钱    public double cost() {        return 30.00+size.getCost();    }}</code></pre><pre><code class="java">/** *浓缩咖啡 */public class Espresso extends Beverage{    public Espresso(Size size){        setSize(size);        if(this.size==Size.UNKNOWN){            throw new RuntimeException();        }        description = &quot;Espresso &quot;+this.size.name();    }    public double cost() {        return 25.00+size.getCost();    }}</code></pre><pre><code class="java">/** * 混合咖啡 */public class HouseBlend extends Beverage{    public HouseBlend(Size size){        setSize(size);        if(this.size==Size.UNKNOWN){            throw new RuntimeException();        }        description = &quot;HouseBlend &quot;+this.size.name();    }    public double cost() {        return 50.00+size.getCost();    }}</code></pre><p>原料装饰者抽象类：</p><pre><code class="java">public abstract class CondimentDecorator extends Beverage {    //描述中需要有原料信息，所以需要重写该抽象方法    public abstract String getDescription();}</code></pre><p>四个原料装饰者类：</p><ul><li>牛奶、摩卡、豆浆、奶泡</li></ul><pre><code class="java">public class Milk extends CondimentDecorator{    private Beverage beverage;    //构造方法传入需要装饰的咖啡    public Milk(Beverage beverage){        this.beverage = beverage;    }    //牛奶需要多加9元    public double cost() {        return beverage.cost()+9.00;    }    //重写的描述放方法    public String getDescription() {        return beverage.getDescription()+&quot; with Milk&quot;;    }}</code></pre><pre><code class="java">public class Mocha extends CondimentDecorator{    private Beverage beverage;    public Mocha(Beverage beverage){        this.beverage = beverage;    }    public double cost() {        return beverage.cost()+7.00;    }    public String getDescription() {        return beverage.getDescription()+&quot; with Mocha&quot;;    }}</code></pre><pre><code class="java">public class Soy extends CondimentDecorator{    private Beverage beverage;    public Soy(Beverage beverage){        this.beverage = beverage;    }    public double cost() {        return beverage.cost()+5.00;    }    public String getDescription() {        return beverage.getDescription()+&quot; with Soy&quot;;    }}</code></pre><pre><code class="java">public class Whip extends CondimentDecorator{    private Beverage beverage;    public Whip(Beverage beverage){        this.beverage = beverage;    }    public double cost() {        return beverage.cost()+15.00;    }    public String getDescription() {        return beverage.getDescription()+&quot; with Whip&quot;;    }}</code></pre><p>编写测试类：</p><pre><code class="java">public class Main {    public static void main(String[] args) {        DarkRoast darkRoast = new DarkRoast(Size.BIG);        Milk mb = new Milk(darkRoast);        System.out.println(mb.getDescription()+&quot;,cost:&quot;+mb.cost());        Mocha mochab = new Mocha(new Espresso(Size.SMALL));        System.out.println(mochab.getDescription()+&quot;,cost:&quot;+mochab.cost());        Soy sb = new Soy(new HouseBlend(Size.MEDIUM));        System.out.println(sb.getDescription()+&quot;,cost:&quot;+sb.cost());        Whip wb = new Whip(new DarkRoast(Size.BIG));        System.out.println(wb.getDescription()+&quot;,cost:&quot;+sb.cost());        Milk mb2 = new Milk(mb);        System.out.println(mb2.getDescription()+&quot;,cost:&quot;+mb2.cost());        Soy soyb = new Soy(mb2);        System.out.println(soyb.getDescription()+&quot;,cost:&quot;+soyb.cost());        Whip whipb = new Whip(soyb);        System.out.println(whipb.getDescription()+&quot;,cost:&quot;+whipb.cost());    }}</code></pre><p>输出如下</p><pre><code class="java">output：DarkRoast BIG with Milk,cost:39.2Espresso SMALL with Mocha,cost:32.1HouseBlend MEDIUM with Soy,cost:55.15DarkRoast BIG with Whip,cost:55.15DarkRoast BIG with Milk with Milk,cost:48.2DarkRoast BIG with Milk with Milk with Soy,cost:53.2DarkRoast BIG with Milk with Milk with Soy with Whip,cost:68.2</code></pre><h3 id="JDK中装饰者——IO"><a href="#JDK中装饰者——IO" class="headerlink" title="JDK中装饰者——IO"></a>JDK中装饰者——IO</h3><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/8.png"><p>IO中<code>InputStream</code>和<code>OutputStream</code>就是抽象的超类，<code>Reader</code>和<code>Writer</code>也是抽象的超类。整个IO家族都是由装饰者模式构成的。</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/7.png"><p>代码地址：<a href="https://github.com/ding-zou/design_patterns/tree/master/decorator_patterns" rel="external nofollow noopener noreferrer" target="_blank">Github装饰者模式</a></p>]]></content>
    
    <summary type="html">
    
      装饰者模式：装饰者和被装饰者有相同的超类-可以用一个或者多个装饰者包装一个对象，因为装饰者和被装饰者有相同的超类，所以在任何需要原始对象（被包装的）的时候，你都可以用装饰过的对象替代，装饰者可以在被装饰者的行为前后添加自己的行为，装饰者可以如何时候被装饰，可以运行时动态地装饰对象。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式——观察者模式</title>
    <link href="https://www.dzou.top/post/261ed4ab.html"/>
    <id>https://www.dzou.top/post/261ed4ab.html</id>
    <published>2019-08-04T04:15:54.000Z</published>
    <updated>2019-08-16T13:34:39.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之观察者模式"><a href="#Java设计模式之观察者模式" class="headerlink" title="Java设计模式之观察者模式"></a>Java设计模式之观察者模式</h2><p>前面一篇文章提到了策略模式，提出了三个设计原则，这里提出第四个设计原则</p><p>设计原则：</p><ul><li>为了交互对象之间的松耦合的设计而努力。</li></ul><p>针对报社：<code>出版者</code>+<code>订阅者</code>=<code>观察者模式</code></p><p>报社是获取信息的主题对象，当报社获取到的信息更新了，报社将把信息传送给它的订阅者；当然订阅者也可以通知报社停止订阅，报社就把该对象从订阅者列表中去除，他不再能接收到报社传送的信息。</p><p><strong>观察者模式：定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时。它的所有依赖者都会收到通知并自动更新。</strong></p><p>观察者模式有两个部分：</p><ul><li>观察者</li><li>主题（也叫被观察者）</li></ul><p>一个主题对象关联了多个观察者，当主体对象有数据更新或者状态改变时，它就可以通知它所关联的观察者们；就如果狗对象、猫对象、老鼠对象已经注册成为观察者，他们就将在主体对象数据更新时接收到主题对象发送的通知（通知数据更新了，你可以通过pull或者push的方式获取），这也就是<code>java.util</code>包下的<code>Observer</code>和<code>Observable</code>实现的观察者模式</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/4.png"><p>我们通过Head FIrst 设计模式中的场景实现观察者模式</p><p><strong><em>场景：一个气象站由<code>WeatherData</code>类或者气象数据<code>温度、湿度、气压</code>，作为主题类，由多个公告板（展示效果不同，数据都是这三个）作为观察者类，当气象数据更新或者改变时，该类将通知公告板更新展示的数据。</em></strong></p><p>WeatherData该主题需要能<code>添加观察者</code>，<code>删除观察者</code>，<code>通知观察者更新数据</code>,并且要获取气象局发布的数据</p><p>我们把主体对象写一个接口如下，不同主题实现不同功能只需实现该接口</p><pre><code class="java">public interface Subject {    //添加观察者    void registerObserver(Observer o);    //删除    void removeObserver(Observer o);    //通知    void notifyObservers(List&lt;Observer&gt; o);    void setChanged();    boolean getChanged();}</code></pre><p>其中<code>setChanged方法</code>把数据是否更新的状态的标志设置为True，在更新状态或者数据时执行该方法</p><p><code>getChanged()</code>获取该标志</p><p><code>WeatherData</code>只需实现该接口，添加获取气象数据的方法即可</p><pre><code class="java">public class WeatherData implements Subject{    private WeatherArgs args = new WeatherArgs();    private List&lt;Observer&gt; obs = new ArrayList&lt;&gt;();    private boolean changed = false;    //设置数据    void setWeatherData(String template,String humidity,String pressure){        args.setTemplate(template);        args.setHumidity(humidity);        args.setPressure(pressure);        //更新完成后设置标志为true        setChanged();        //调用更新后通知观察者方法        onWeatherDataChanged();    }    //数据更新时通知观察者 push数据给观察者    private void onWeatherDataChanged(){        if(getChanged()){            notifyObservers(obs);        }    }    //观察者注册    public void registerObserver(Observer o) {        if(o==null){            throw new RuntimeException();        }        obs.add(o);    }    //观察者移除    public void removeObserver(Observer o) {        obs.remove(o);    }    //通知观察者们数据更新 发送数据给观察者们    public void notifyObservers(List&lt;Observer&gt; obs) {        obs.forEach((o)-&gt;o.update(this,args));    }    @Override    public void setChanged() {        changed = true;    }    @Override    public boolean getChanged() {        return changed;    }}</code></pre><p>其中<code>WeatherArg</code>为气象数据参数类，当我们不使用这个类时，我们需要每次更新时传入特定的值，下面这样</p><pre><code class="java">update(String template,String humidity,String pressure);update(100,200,200kpa);</code></pre><p>这样需要更改数据种类和数量时，需要修改很多代码，所以我们把它封装起来</p><pre><code class="java">@Dataclass WeatherArgs {    //温度    private String template;    //湿度    private String humidity;    //气压    private String pressure;}</code></pre><p>添加这个类是为了如果需要更改数据类型和数量时只需更改这个类就行</p><p>我们用List存放观察者，<code>onWeatherDataChanged</code>方法检测是否更新，如果更新就通知观察者</p><p>观察者有多个，其中都有<code>update</code>方法执行被通知时更新数据，通过不同的<code>display</code>方法展示不同效果的气象数据，我们编写两个接口</p><ul><li>观察者接口 （有多个观察者）Observer</li><li>展示数据接口（有不同展示方法） Displayable</li></ul><pre><code class="java">public interface Observer {    /**     * 更新数据     * @param subject 主题对象     * @param args 更新参数     */    void update(Subject subject,Object args);}</code></pre><pre><code class="java">public interface Displayable {    /**     * 数据展示方法     */    void display();}</code></pre><p>下面我们实现一个观察者</p><p>它需要实现<code>Observer和`Displayable</code>接口实现<code>update和display</code>方法</p><p>我们在构造方法传入一个主题对象，告诉他我们要订阅他</p><pre><code class="java">public class CurrentConditionDisplay implements Observer,Displayable{    //可用于观察者对主题对象取消订阅    private Subject subject;    private WeatherArgs weatherArgs;    //创建时注册    public CurrentConditionDisplay(Subject s){        s.registerObserver(this);        subject = s;    }    @Override    public void update(Subject subject, Object args) {        if(subject instanceof WeatherData){            weatherArgs = (WeatherArgs) args;            display();        }    }    @Override    public void display() {        System.out.println(&quot;template:&quot;+weatherArgs.getTemplate()+&quot;, humidity:&quot;+weatherArgs.getHumidity()+&quot;, pressure:&quot;+weatherArgs.getPressure());    }    //观察者取消订阅 通知主题对象删除我    private void removeMe(){        subject.removeObserver(this);    }}</code></pre><p>至此，观察者模式就完成了</p><p>写一个测试类：</p><pre><code class="java">public class Main {    public static void main(String[] args) {        WeatherData weatherData = new WeatherData();        CurrentConditionDisplay currentConditionDisplay = new CurrentConditionDisplay(weatherData);        weatherData.setWeatherData(&quot;100&quot;,&quot;90&quot;,&quot;100KPa&quot;);    }}</code></pre><pre><code class="java">output：template:100, humidity:90, pressure:100KPa</code></pre><blockquote><p>大家可以看一下JDK中内置的<code>Observer和Observable</code>实现的观察者模式，大体实现是一样的</p></blockquote><p>JDK内置观察者模式</p><p><code>Observable</code>被观察者</p><pre><code class="java">public class Observable {    private boolean changed = false;    private Vector&lt;Observer&gt; obs;    public Observable() {        obs = new Vector&lt;&gt;();    }    public synchronized void addObserver(Observer o) {        if (o == null)            throw new NullPointerException();        if (!obs.contains(o)) {            obs.addElement(o);        }    }    public synchronized void deleteObserver(Observer o) {        obs.removeElement(o);    }    public void notifyObservers() {        notifyObservers(null);    }    public void notifyObservers(Object arg) {        Object[] arrLocal;        synchronized (this) {            if (!changed)                return;            arrLocal = obs.toArray();            clearChanged();        }        for (int i = arrLocal.length-1; i&gt;=0; i--)            ((Observer)arrLocal[i]).update(this, arg);    }    public synchronized void deleteObservers() {        obs.removeAllElements();    }    protected synchronized void setChanged() {        changed = true;    }    protected synchronized void clearChanged() {        changed = false;    }    public synchronized boolean hasChanged() {        return changed;    }    public synchronized int countObservers() {        return obs.size();    }}</code></pre><p><code>Observer</code></p><pre><code class="java">public interface Observer {    //o为被观察者主题，args为更新的数据    void update(Observable o, Object arg);}</code></pre><p>但是我们可以看到该<code>Observable</code>是具体的实现类，不符合设计模式中的</p><ul><li>多用组合少用继承</li></ul><p>不方便我们继承其他类</p><p>有两个办法 ：</p><ul><li>使用上述我们自己实现的观察者模式</li><li>扩展Observable类</li></ul><p>代码地址：<a href="https://github.com/ding-zou/design_mode/tree/master/observer_patterns" rel="external nofollow noopener noreferrer" target="_blank">Github观察者模式</a></p>]]></content>
    
    <summary type="html">
    
      当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式——策略模式</title>
    <link href="https://www.dzou.top/post/6c84d9a1.html"/>
    <id>https://www.dzou.top/post/6c84d9a1.html</id>
    <published>2019-08-03T06:15:05.000Z</published>
    <updated>2019-08-16T13:30:28.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之策略模式"><a href="#Java设计模式之策略模式" class="headerlink" title="Java设计模式之策略模式"></a>Java设计模式之策略模式</h2><p>设计模式基础：</p><ul><li>抽象</li><li>多态</li><li>继承</li><li>组合</li></ul><p>设计原则：</p><ul><li><p>把变化的抽取出来，不要和不变化的放在一起</p></li><li><p>针对接口编程，不针对实现编程</p></li><li><p>多用组合，少用继承</p></li></ul><p>我们先把定义提出来：</p><p><strong>策略模式：定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。</strong></p><p>这个概念比较难理解，下面我们具体通过案例分析一下</p><p>场景：我们有三个不同种类的程序员，JavaWeb、大数据BigData和Ai人工智能程序员；他们都有相同的喝水和睡觉行为，但是有不同的写代码行为（写JavaWeb，写Ai，写Big data），我们想一下怎么实现？</p><p>我们首先想到的是使用<code>继承重写父类的方法</code>实现，但是这样做的缺点很多：</p><pre><code class="java">Class JavaWebProgrammer extends Programmer{    public void doSleeping(){        //重写代码    }    public void doCoding(){        //重写代码    }}</code></pre><ul><li>可以解决问题，但是代码无法复用</li><li>多一个类都要重新写它对应的实现，代码量太大</li><li>不符合三个设计原则</li><li>而且无法解决有些类没有或者不需要基类的某个功能 比如有的程序员退休了，有的没有退休</li></ul><p>此时，针对<code>某个类不需要实现基类某个功能</code>你又想到了在重写中什么都不做的方法：</p><pre><code class="java">public void retired(){    //do noting}</code></pre><p>但是这样依然没有解决上面的根本问题，所以我们又想到了<code>使用接口</code>：把不会变化的功能（睡觉行为和喝水行为依然放在基类里，会变化的行为（写代码行为）写成一个接口<code>Codeable</code>，然后通过继承基类实现不变的行为，实现Codeable接口实现不同的写代码行为</p><p>但是这么做还是不行：</p><ul><li>如果有很多子类的实现需要修改，那么我们要修改很多的代码</li></ul><p>这个时候我们就应该充分考虑<code>设计原则</code>的作用了</p><ul><li>把变化的部分封装起来</li><li>面向接口编程</li></ul><p>大家就可以想到把接口的实现独立成一个个类，把写代码行为写成一个接口，不同的实现对应不同的实现类，然后我们在使用时，想到了<code>多态</code>的奇妙之处，根据多态的动态调用</p><p>如下：</p><pre><code class="java">ProgramBehavior programBehavior = new JavaWebBehavior();programBehavior.doCoding();</code></pre><p>在此，我们大体思路已经很接近成功了</p><ul><li><p>首先基类声明为<code>抽象类</code>，里面有睡觉和喝水行为的具体实现（不变的）</p><pre><code class="java">    protected void doDrinking(){        System.out.println(&quot;I am drinking.&quot;);    }    protected void doSleeping(){        System.out.println(&quot;I am sleeping&quot;);    }</code></pre></li><li><p>在基类中声明变化的部分，使用接口的形式使得我们可以动态调用</p><pre><code class="java">ProgramBehavior programBehavior；void doCoding(){    programBehavior.doCoding();}</code></pre></li><li><p>创建写代码行为的接口</p><pre><code class="java">public interface ProgramBehavior {    void doCoding();}</code></pre></li><li><p>子类<code>AIProgrammer</code>继承抽象类<code>Programmer</code>，只需要在初始化时创建<code>AIBehavior</code>赋给我们基类的接口<code>programBehavior</code></p><pre><code class="java">public class AIProgrammer extends Programmer {    public AIProgrammer(){        programBehavior = new AIBehavior();    }}</code></pre></li><li><p>创建不同的接口实现类，实现不同的写代码行为</p><pre><code class="java">public class AIBehavior implements ProgramBehavior {    @Override    public void doCoding() {        System.out.println(&quot;I am doing AI coding.&quot;);    }}</code></pre></li><li><p>测试</p><pre><code class="java">public void testAI(){        Programmer aiProgrammer = new AIProgrammer();        aiProgrammer.doDrinking();        aiProgrammer.doCoding();        aiProgrammer.doSleeping();    }</code></pre><p>结果如下：</p></li></ul><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/1.png"><p>可见：我们使用多态动态调用了<code>doCoding()</code>方法，我们在需要修改实现的时候只需要需要修改接口对应的实现就可以了，而不需要修改子类的方法</p><p>当然，我们不应该在开发中使用初始化时创建实现类的这种方式，我们可以在<code>基类</code>中添加一个<code>setProgramBehavior</code>的方法，这样我们就可以在应用中动态的设置行为</p><pre><code class="java">void setProgramBehavior(ProgramBehavior programBehavior){        this.programBehavior = programBehavior;}</code></pre><p>我们为AIProgramer在执行完睡觉后2秒设置一个新的写代码行为（退休）并调用</p><pre><code class="java">public class RetireBehavior implements ProgramBehavior {    @Override    public void doCoding() {        System.out.println(&quot;I am retired just few days.&quot;);    }}</code></pre><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/2.png"><p>该AIProgramer类图如下</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/3.png"><blockquote><p>至此，这就是整个策略模式的设计方法，我们再来理一遍，也许你再去看策略模式的定义就没问题了（代码最后附上）</p></blockquote><p>我们把行为中（每个行为可以看成一个算法，形成了算法族）变化的部分从基类抽象类中抽取出来，使用接口定义并使用类实现接口来实现某一个行为（算法）不同的表现，再利用<code>多态</code>的神奇之处动态调用接口不同实现类的同一方法；然后我们需要改变接口实现类的实现方法（算法）时对调用该方法的客户完成不需要更改，没有任何影响。</p><p>代码地址：<a href="https://github.com/ding-zou/design_patterns/tree/master/strategy_patterns" rel="external nofollow noopener noreferrer" target="_blank">Github策略模式</a></p>]]></content>
    
    <summary type="html">
    
      Java设计模式之策略模式：定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
