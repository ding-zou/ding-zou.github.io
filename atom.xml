<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dzou&#39;s Blog</title>
  
  <subtitle>No pains,no gains.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.dzou.top/"/>
  <updated>2019-07-23T14:16:40.069Z</updated>
  <id>https://www.dzou.top/</id>
  
  <author>
    <name>dzou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>解决Deepin系统使用中dock栏消失不显示</title>
    <link href="https://www.dzou.top/2019/07/23/deepin%E4%B8%8Bdock%E6%A0%8F%E6%B6%88%E5%A4%B1/"/>
    <id>https://www.dzou.top/2019/07/23/deepin下dock栏消失/</id>
    <published>2019-07-23T12:38:32.000Z</published>
    <updated>2019-07-23T14:16:40.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解决Deepin系统使用中dock栏消失不显示"><a href="#解决Deepin系统使用中dock栏消失不显示" class="headerlink" title="解决Deepin系统使用中dock栏消失不显示"></a>解决Deepin系统使用中dock栏消失不显示</h2><p>不需要卸载重新安装<strong>dde-dock</strong></p><p>只需要把进程kill</p><p>终端中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall dde-dock</span><br></pre></td></tr></table></figure><p>dock栏就出现了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;解决Deepin系统使用中dock栏消失不显示&quot;&gt;&lt;a href=&quot;#解决Deepin系统使用中dock栏消失不显示&quot; class=&quot;headerlink&quot; title=&quot;解决Deepin系统使用中dock栏消失不显示&quot;&gt;&lt;/a&gt;解决Deepin系统使用中dock
      
    
    </summary>
    
      <category term="linux" scheme="https://www.dzou.top/categories/linux/"/>
    
    
      <category term="deepin" scheme="https://www.dzou.top/tags/deepin/"/>
    
      <category term="linux" scheme="https://www.dzou.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>牛客网算法编程题--物流中转站 解答</title>
    <link href="https://www.dzou.top/2019/07/23/%E7%89%A9%E6%B5%81%E4%B8%AD%E8%BD%AC%E7%AB%99/"/>
    <id>https://www.dzou.top/2019/07/23/物流中转站/</id>
    <published>2019-07-23T08:40:32.000Z</published>
    <updated>2019-07-23T09:57:15.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="物流中转站"><a href="#物流中转站" class="headerlink" title="物流中转站"></a>物流中转站</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Shopee物流会有很多个中转站。在选址的过程中，会选择离用户最近的地方建一个物流中转站。</p><p>假设给你一个二维平面网格，每个格子是房子则为1，或者是空地则为0。找到一个空地修建一个物流中转站，使得这个物流中转站到所有的房子的距离之和最小。 能修建，则返回最小的距离和。如果无法修建，则返回 -1。</p><p>若范围限制在100*100以内的网格，如何计算出最小的距离和？</p><p>当平面网格非常大的情况下，如何避免不必要的计算？</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">0 1 1 0</span><br><span class="line">1 1 0 1</span><br><span class="line">0 0 1 0</span><br><span class="line">0 0 0 0</span><br><span class="line"></span><br><span class="line">先输入方阵阶数，然后逐行输入房子和空地的数据，以空格分隔。</span><br></pre></td></tr></table></figure><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line"></span><br><span class="line">能修建，则返回最小的距离和。如果无法修建，则返回 -1。</span><br></pre></td></tr></table></figure><hr><blockquote><p>相信大家都会使用二维数组和循环遍历,下面我讲这道题将使用大家一些比较不熟悉或者陌生的知识</p></blockquote><h3 id="Lambda-Stream-静态内部类"><a href="#Lambda-Stream-静态内部类" class="headerlink" title="Lambda Stream+静态内部类"></a>Lambda Stream+静态内部类</h3><p>希望大家看完以后可以学会将stream和内部类应用到项目中,也可以进一步学习一下Lambda,时很有必要的</p><h4 id="步入正题"><a href="#步入正题" class="headerlink" title="步入正题"></a>步入正题</h4><p>思路</p><p>使用封装对象Point存放点的坐标,再把他们存放到集合List中(ArrayList读取效率高),编写求距离和的函数和求两点距离和的函数,最后通过stream和Lambda组合获得距离最小值</p><p><img src="/images/1.png" alt="1562076624237"></p><p>关键代码就一行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> re = noBuildings.stream()</span><br><span class="line">    .map(x-&gt;distanceSum(x.x,x.y))</span><br><span class="line">    .min(Integer::compareTo)</span><br><span class="line">    .get();</span><br></pre></td></tr></table></figure><p><strong>这段代码中stream就是获取一个流对象,map把参数x与求解距离总和的方法映射得到该方法的返回值min就是在这些返回值中获得最小的值(使用了Integer中的ComparaTo方法 最后通过get获得这个最小值)</strong></p><h3 id="如果又看不懂的可以看一下我的另外一篇关于Lambda和Stream的博客"><a href="#如果又看不懂的可以看一下我的另外一篇关于Lambda和Stream的博客" class="headerlink" title="如果又看不懂的可以看一下我的另外一篇关于Lambda和Stream的博客"></a>如果又看不懂的可以看一下我的另外一篇关于Lambda和Stream的博客</h3><p>我们在输入点的时候就把点封装add到集合中,我们只需要从没有建筑的点中查取出与空地的距离的最小值</p><p>源代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Point&gt; buildings;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    buildings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Point&gt; noBuildings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> l = scanner.nextInt();</span><br><span class="line">    <span class="keyword">int</span>[][] sites = <span class="keyword">new</span> <span class="keyword">int</span>[l][l];</span><br><span class="line">    scanner.nextLine();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">        String[] str;</span><br><span class="line">        str = scanner.nextLine().split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>;m&lt;l;m++)&#123;</span><br><span class="line">                sites[i][m] = Integer.parseInt(str[m].trim());</span><br><span class="line">                <span class="keyword">if</span>(sites[i][m]==<span class="number">0</span>)&#123;</span><br><span class="line">                    noBuildings.add(<span class="keyword">new</span> Point(i,m));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    buildings.add(<span class="keyword">new</span> Point(i,m));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(noBuildings.isEmpty())&#123;</span><br><span class="line">        System.out.println(<span class="string">"-1"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> re = noBuildings.stream().map(x-&gt;distanceSum(x.x,x.y)).min(Integer::compareTo).get();</span><br><span class="line">    System.out.println(re);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">distanceSum</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> line)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Point point : buildings) &#123;</span><br><span class="line">        sum+=twoPoint(row,line,point.x,point.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">twoPoint</span><span class="params">(<span class="keyword">int</span> row1,<span class="keyword">int</span> line1,<span class="keyword">int</span> row2,<span class="keyword">int</span> line2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(row2-row1)+Math.abs(line2-line1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    Point(<span class="keyword">int</span> row,<span class="keyword">int</span> line)&#123;</span><br><span class="line">        x=row;</span><br><span class="line">        y=line;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;物流中转站&quot;&gt;&lt;a href=&quot;#物流中转站&quot; class=&quot;headerlink&quot; title=&quot;物流中转站&quot;&gt;&lt;/a&gt;物流中转站&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;
      
    
    </summary>
    
      <category term="算法" scheme="https://www.dzou.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="算法" scheme="https://www.dzou.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="牛客" scheme="https://www.dzou.top/tags/%E7%89%9B%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>AbstractQueuedSynchronizer AQS锁原理（源码分析）及ReentrantLock非公平锁的实现并实现自定义AQS锁</title>
    <link href="https://www.dzou.top/2019/07/23/AbstractQueuedSynchronizer/"/>
    <id>https://www.dzou.top/2019/07/23/AbstractQueuedSynchronizer/</id>
    <published>2019-07-23T08:38:32.000Z</published>
    <updated>2019-07-23T11:18:57.670Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AbstractQueuedSynchronizer-AQS锁原理及ReentrantLock非公平锁的实现"><a href="#AbstractQueuedSynchronizer-AQS锁原理及ReentrantLock非公平锁的实现" class="headerlink" title="AbstractQueuedSynchronizer AQS锁原理及ReentrantLock非公平锁的实现"></a>AbstractQueuedSynchronizer AQS锁原理及ReentrantLock非公平锁的实现</h1><p>AbstractQueuedSynchronizer是基于一个FIFO双向链队列 CLH队列，用于构建锁或者同步装置的类，也称为Java同步器，ReentrantLock的公平锁与非公平锁就是由该同步器构成，链队列结构图如下。</p><p>你可以理解为银行ATM机取钱，一个人先去取，获取到了锁，在这个时间内其他线程处于阻塞状态，只有等他取完钱了，他走了，释放了锁，排在它后面的人才可以获取到释放的锁并进行取钱。</p><p><img src="http://ifeve.com/wp-content/uploads/2013/10/21.png" alt="img"></p><p>该同步器利用一个int值表示状态，实现方式是==使用内部类继承该同步器的方式==实现它的tryRelease、tryAcquire等方法管理状态，管理状态使用以下三个方法：</p><ul><li>getState()  获取状态</li><li>setState()  基本设置状态</li><li>compareAndSetSate(int,int) 基于CAS实现的原子性设置状态</li></ul><h3 id="AQS节点"><a href="#AQS节点" class="headerlink" title="AQS节点"></a>AQS节点</h3><p>节点包含的状态有：</p><ol><li>CANCELLED，值为1，表示当前的线程被取消；</li><li>SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark；</li><li>CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中；</li><li>PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行；</li><li>值为0，表示当前节点在sync队列中，等待着获取锁。</li></ol><p>节点其他信息：</p><table><thead><tr><th><strong>Node prev</strong></th><th>前驱节点</th></tr></thead><tbody><tr><td><strong>Node next</strong></td><td><strong>后继节点</strong></td></tr><tr><td><strong>Node nextWaiter</strong></td><td><strong>存储condition队列中的后继节点</strong></td></tr><tr><td><strong>Thread thread</strong></td><td><strong>入队列时的当前线程</strong></td></tr></tbody></table><h2 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h2><p>锁在一个时间点只能被一个线程锁占有，AQS实现的ReentrantLock，又分为公平锁和非公平锁</p><ul><li><p>公平锁</p><p>保障了多线程下各线程获取锁的顺序，先到的线程优先获取锁</p></li><li><p>非公平锁</p><p>加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待</p></li></ul><h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><p>锁在一个时间点可以被多个线程同时获取，AQS实现的CountDownLatch、ReadWriteLock</p><h2 id="一、AQS实现ReentrantLock非公平锁"><a href="#一、AQS实现ReentrantLock非公平锁" class="headerlink" title="一、AQS实现ReentrantLock非公平锁"></a>一、AQS实现ReentrantLock非公平锁</h2><h3 id="ReentrantLock非公平锁获取锁"><a href="#ReentrantLock非公平锁获取锁" class="headerlink" title="ReentrantLock非公平锁获取锁"></a>ReentrantLock非公平锁获取锁</h3><h4 id="1、lock"><a href="#1、lock" class="headerlink" title="1、lock()"></a>1、lock()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="2、acquire"><a href="#2、acquire" class="headerlink" title="2、acquire()"></a>2、acquire()</h4><blockquote><p>根据指定状态获取，能获取到 执行compareAndSetState方法设置新状态</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="comment">//tryAcquire成功的话 acquire结束；</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            <span class="comment">//AcquireQueued方法进行阻塞等待,直到获取锁为止</span></span><br><span class="line">            <span class="comment">//addWaiter把当前线程添加到队列尾部</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            <span class="comment">//tryAcquire失败并且acquiredQueued成功的话把当前线程中断</span></span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>尝试获取锁；</li><li>如果获取不到，将当前线程构造成节点Node并加入队列；<br>addWaiter方法把节点加入队列，每个线程都是一个节点Node，从而形成了一个双向队列，类似CLH队列。</li><li>再次尝试获取，如果没有获取到那么将当前线程从线程调度器上摘下，进入等待状态。</li></ol><h4 id="3、tryAcquire"><a href="#3、tryAcquire" class="headerlink" title="3、tryAcquire()"></a>3、tryAcquire()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取状态</span></span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//如果该锁未被任何线程占有，该锁能被当前线程获取</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="comment">//若被获取到 查看是否被当前线程</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="comment">//是当前线程的话再次获取，计数+1</span></span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在tryAcquire方法中使用了同步器提供的对state操作的方法，利用CAS原理保证只有一个线程能够对状态进行成功修改，而没有成功修改的线程将进入队列排队。</p><h4 id="4、acquireQueued"><a href="#4、acquireQueued" class="headerlink" title="4、acquireQueued()"></a>4、acquireQueued()</h4><p>AcquireQueued方法进行阻塞等待,直到获取锁为止</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//node为null，排他方式阻塞等待</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//p为当前节点的前一个节点</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">//如果p为头结点并且获取成功就把当前线节点设置为头结点</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果线程需要被阻塞 则interrputr为true</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>获取当前节点的前驱节点；</li><li>当前驱节点是头结点并且能够获取状态，代表该当前节点占有锁；</li><li>否则进入等待状态。</li></ol><h4 id="5、shouldParkAfterFailedAcquire"><a href="#5、shouldParkAfterFailedAcquire" class="headerlink" title="5、shouldParkAfterFailedAcquire()"></a>5、shouldParkAfterFailedAcquire()</h4><p>判断线程是否需要阻塞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">        <span class="comment">//线程需要运行</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="comment">//ws&gt;0 处于CANCEL状态的线程</span></span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//把这些线程从队列中清除</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//把等待的设置为运行状态</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>先判断线程是否处于运行状态</li><li>如果处于CANCEL状态则把他们都从队列中清除</li><li>把当前节点下一个节点等待状态设置为准备运行</li></ol><h4 id="6、parkAndCheckInterrupt"><a href="#6、parkAndCheckInterrupt" class="headerlink" title="6、parkAndCheckInterrupt()"></a>6、parkAndCheckInterrupt()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// park方法让其他线程处于等待状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>调用阻塞线程本地方法park</li><li>返回线程是否被阻塞</li></ol><h3 id="ReentrantLock非公平锁释放锁"><a href="#ReentrantLock非公平锁释放锁" class="headerlink" title="ReentrantLock非公平锁释放锁"></a>ReentrantLock非公平锁释放锁</h3><h4 id="1、unlock"><a href="#1、unlock" class="headerlink" title="1、unlock()"></a>1、unlock()</h4><p>调用release释放一个锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//释放一个锁</span></span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2、release"><a href="#2、release" class="headerlink" title="2、release()"></a>2、release()</h4><blockquote><p>释放锁</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="comment">//调用tryRelease尝试释放一个锁 </span></span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="comment">//释放成功后</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>调用tryRelease方法尝试释放锁，失败返回false</li><li>释放成功判断头结点不为null并且状态不为等待获取锁状态</li><li>满足条件则唤醒线程并返回true</li></ol><h4 id="3、tryRelease"><a href="#3、tryRelease" class="headerlink" title="3、tryRelease()"></a>3、tryRelease()</h4><blockquote><p>尝试释放当前锁</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="keyword">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ol><li>释放锁必需是当前线程，如果不是当前线程抛出异常</li><li>如果获取锁的线程为当前线程则判断释放后的状态是否为0，即释放前为CANCEL状态，如果是，则设置独占模式线程为null，并设置状态为0，返回true。</li></ol><h4 id="4、unparkSuccessor"><a href="#4、unparkSuccessor" class="headerlink" title="4、unparkSuccessor()"></a>4、unparkSuccessor()</h4><blockquote><p>锁释放后唤醒线程，一同竞争CPU资源</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前节点状态</span></span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">        <span class="comment">//把状态设置为等待获取锁状态</span></span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//如果没有下一个节点或者下一个节点状态为CANCEL，则把它们清除</span></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则调用LockSupport中unpark方法，唤醒后一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>获取当前节点状态</li><li>判断如果状态&lt;0，即不为等待获取锁状态，则把状态设置为等待获取锁状态</li><li>如果没有下一个节点或者下一个节点状态为CANCEL，则把它们清除</li><li>当当前节点下一个节点不为null时，调用LockSupport中unpark方法，唤醒后一个节点</li></ol><h4 id="5、unpark"><a href="#5、unpark" class="headerlink" title="5、unpark()"></a>5、unpark()</h4><blockquote><p>调用UNSAFE的本地方法unpark唤醒线程</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">            UNSAFE.unpark(thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="二、AQS实现ReentrantLock公平锁"><a href="#二、AQS实现ReentrantLock公平锁" class="headerlink" title="二、AQS实现ReentrantLock公平锁"></a>二、AQS实现ReentrantLock公平锁</h2><p>AQS实现ReentrantLock公平锁与非公平锁最大的区别在下面这段代码：</p><p><img src="/images/2.png" alt="1563697815749"></p><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">        <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">        <span class="comment">// thread is first in queue.</span></span><br><span class="line">        Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>判断”当前线程”是不是在CLH队列的队首，来实现公平性。</p></blockquote><h2 id="三、AQS实现的自定义锁"><a href="#三、AQS实现的自定义锁" class="headerlink" title="三、AQS实现的自定义锁"></a>三、AQS实现的自定义锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAQSLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAQSLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> Sync();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>,unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把lock、unlock实现使用AQS构建为内部类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span>&#123;</span><br><span class="line">        <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//第一个线程进来拿到锁</span></span><br><span class="line">            <span class="keyword">int</span> state = getState();</span><br><span class="line">            <span class="comment">//用于重入锁判断</span></span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">if</span>(state==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>,arg))&#123;</span><br><span class="line">                    setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//重入锁判断 当前线程和独占锁线程相同，则再次获取</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(current==getExclusiveOwnerThread())&#123;</span><br><span class="line">                <span class="keyword">int</span> next = state+arg;</span><br><span class="line">                <span class="keyword">if</span>(next&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">                &#125;</span><br><span class="line">                setState(next);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 可重入释放锁</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> arg</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread()!=getExclusiveOwnerThread())&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> state = getState()-arg;</span><br><span class="line">            <span class="keyword">if</span>(state==<span class="number">0</span>)&#123;</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">                setState(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试（可重入锁）"><a href="#测试（可重入锁）" class="headerlink" title="测试（可重入锁）"></a>测试（可重入锁）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAQSLock2</span> </span>&#123;</span><br><span class="line">    MyAQSLock myLock = <span class="keyword">new</span> MyAQSLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        myLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            b();</span><br><span class="line">            <span class="keyword">return</span> value++;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            myLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">        myLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(++value2);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            myLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestAQSLock2 myLock = <span class="keyword">new</span> TestAQSLock2();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + myLock.a());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AbstractQueuedSynchronizer-AQS锁原理及ReentrantLock非公平锁的实现&quot;&gt;&lt;a href=&quot;#AbstractQueuedSynchronizer-AQS锁原理及ReentrantLock非公平锁的实现&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="Java并发编程" scheme="https://www.dzou.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="后端" scheme="https://www.dzou.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="并发编程" scheme="https://www.dzou.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="AQS" scheme="https://www.dzou.top/tags/AQS/"/>
    
      <category term="同步器" scheme="https://www.dzou.top/tags/%E5%90%8C%E6%AD%A5%E5%99%A8/"/>
    
      <category term="锁" scheme="https://www.dzou.top/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>使用宝塔面板+Nginx添加反向代理+SSL实现https 部署网站并绑定域名</title>
    <link href="https://www.dzou.top/2019/07/23/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2/"/>
    <id>https://www.dzou.top/2019/07/23/网站部署/</id>
    <published>2019-07-23T08:35:32.000Z</published>
    <updated>2019-07-23T09:42:19.733Z</updated>
    
    <content type="html"><![CDATA[<h2 id="icp备案"><a href="#icp备案" class="headerlink" title="icp备案"></a>icp备案</h2><p>各个服务器提供商备案</p><h2 id="公安备案"><a href="#公安备案" class="headerlink" title="公安备案"></a>公安备案</h2><p>公安网备案</p><h2 id="Springboot项目部署到服务器并绑定域名"><a href="#Springboot项目部署到服务器并绑定域名" class="headerlink" title="Springboot项目部署到服务器并绑定域名"></a>Springboot项目部署到服务器并绑定域名</h2><ol><li><p>Springboot打jar包</p></li><li><p>通过宝塔或者ftp软件上传到服务器</p></li><li><p>阿里云（腾讯云）域名解析到服务器IP ，@代表直接访问域名，www代表访问www.+域名</p></li><li><p>宝塔面板添加站点 （设置数据库、tomcat：springboot无需、ftp）</p></li><li><p>如需使用https 需添加SSL证书  并给域名添加一条txt记录进行DNS解析</p></li></ol><ol start="6"><li><p>给nginx添加反向代理conf配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include /www/server/panel/vhost/nginx/*.conf;</span><br></pre></td></tr></table></figure><p>服务器该目录新建一个应用程序的conf文件，配置以下 形成反向代理（通过域名访问ip+端口）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen <span class="number">80</span>;</span><br><span class="line">server_name api.51carry.com;</span><br><span class="line">#access_log /data/wwwlogs/api.51carry.com_nginx.log combined;</span><br><span class="line">   </span><br><span class="line">location / &#123;</span><br><span class="line">    proxy_pass http:<span class="comment">//127.0.0.1:9090; #这里的端口记得改成项目对应的哦</span></span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">    proxy_set_header X-Forwarded-Port $server_port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>服务器后台运行jar包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar lol.jar &amp; #后台部署</span><br><span class="line">ps aux|grep xxx.jar   #kill关闭进程</span><br><span class="line">cat nohup.out #查看应用日志</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;icp备案&quot;&gt;&lt;a href=&quot;#icp备案&quot; class=&quot;headerlink&quot; title=&quot;icp备案&quot;&gt;&lt;/a&gt;icp备案&lt;/h2&gt;&lt;p&gt;各个服务器提供商备案&lt;/p&gt;
&lt;h2 id=&quot;公安备案&quot;&gt;&lt;a href=&quot;#公安备案&quot; class=&quot;header
      
    
    </summary>
    
      <category term="网站部署" scheme="https://www.dzou.top/categories/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="后端" scheme="https://www.dzou.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="网站部署" scheme="https://www.dzou.top/tags/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2/"/>
    
      <category term="Nginx" scheme="https://www.dzou.top/tags/Nginx/"/>
    
      <category term="Https" scheme="https://www.dzou.top/tags/Https/"/>
    
      <category term="域名" scheme="https://www.dzou.top/tags/%E5%9F%9F%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>Docker基础知识以及使用Docker部署Springboot项目</title>
    <link href="https://www.dzou.top/2019/07/23/Docker%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2Springboot%E9%A1%B9%E7%9B%AE/"/>
    <id>https://www.dzou.top/2019/07/23/Docker基础知识以及使用Docker部署Springboot项目/</id>
    <published>2019-07-23T08:29:32.000Z</published>
    <updated>2019-07-23T09:42:16.089Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>将应用程序自动部署到容器</p><p>GO语言开发</p><p><img src="http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20170425-1493117446353024350.jpg" alt="Docker架构"></p><h3 id="Docker使用"><a href="#Docker使用" class="headerlink" title="Docker使用"></a>Docker使用</h3><ul><li>开发、测试、部署服务</li></ul><h3 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h3><p>直接运行在操作系统之上，一直虚拟化方案</p><h3 id="虚拟机和Linux容器"><a href="#虚拟机和Linux容器" class="headerlink" title="虚拟机和Linux容器"></a>虚拟机和Linux容器</h3><p>虚拟机还需要操作系统，占用太多的内存</p><h3 id="DockerFile-构建镜像"><a href="#DockerFile-构建镜像" class="headerlink" title="DockerFile 构建镜像"></a>DockerFile 构建镜像</h3><p>Dockerfile 是一个文本文件，其内包含了一条条的 <strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><blockquote><p>docker build</p></blockquote><ol><li><p>新建一个目录并创建一个Dockfile文件</p></li><li><p>编写dockerfile配置镜像文件 （docker执行的一些命令）</p></li><li><p>使用docker build命令创建镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t nginx_test .</span><br><span class="line">.表示当前目录下</span><br></pre></td></tr></table></figure></li><li><p>执行完可以查看镜像，并运行镜像</p></li></ol><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><p>DockerHub是Docker官方提供的镜像仓库，你可以把你写的项目打包成镜像上传到Dockerhub，别人也就可以使用Docker命令运行你的镜像；当然各个官方镜像都可以在DockerHub获取并有详细使用方法。</p><h4 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h4><ul><li>docker images 镜像</li><li>docker search  搜索镜像</li><li>docker pull  下载镜像</li><li>docker rmi 镜像id 删除镜像</li></ul><h4 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h4><ul><li>docker run –name name -d image-name   -p 端口映射-d后台</li><li>docker ps 查看运行中的容器 -a</li><li>docker stop containerid 停止容器</li><li>docker rm conatinerid 删除容器</li><li>docker start containerid 启动容器</li><li>docker logs containerid 运行日志</li><li>docker exec -it containerid /bin/bash 进入容器</li></ul><h2 id="Springboot部署项目到Docker"><a href="#Springboot部署项目到Docker" class="headerlink" title="Springboot部署项目到Docker"></a>Springboot部署项目到Docker</h2><blockquote><p>使用可执行jar包构建成docker镜像</p></blockquote><ol><li><p>将jar包上传到服务器目录</p></li><li><p>同目录下编写Dockerfile文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#基于哪个镜像</span><br><span class="line">from java</span><br><span class="line">#将本地文件夹挂载到当前容器</span><br><span class="line">volume /tmp</span><br><span class="line">#复制文件到</span><br><span class="line">add jar包文件名 重命名文件名</span><br><span class="line">#声明需要暴露的端口</span><br><span class="line">expose 端口号</span><br><span class="line">#配置容器启动后执行命令</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/jar包重命名文件名&quot;]</span><br></pre></td></tr></table></figure><blockquote><p>VOLUME 指向了一个<code>/tmp</code>的目录，由于 Spring Boot 使用内置的Tomcat容器，Tomcat 默认使用<code>/tmp</code>作为工作目录。这个命令的效果是：在宿主机的<code>/var/lib/docker</code>目录下创建一个临时文件并把它链接到容器中的<code>/tmp</code>目录</p></blockquote></li><li><p>使用docker build命令构建镜像</p><blockquote><p>docker build  -t 镜像名</p></blockquote></li><li><p>使用docker run运行</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Docker&quot;&gt;&lt;a href=&quot;#Docker&quot; class=&quot;headerlink&quot; title=&quot;Docker&quot;&gt;&lt;/a&gt;Docker&lt;/h2&gt;&lt;p&gt;将应用程序自动部署到容器&lt;/p&gt;
&lt;p&gt;GO语言开发&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xo
      
    
    </summary>
    
      <category term="网站部署" scheme="https://www.dzou.top/categories/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="后端" scheme="https://www.dzou.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Docker" scheme="https://www.dzou.top/tags/Docker/"/>
    
      <category term="分布式" scheme="https://www.dzou.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="SpringBoot" scheme="https://www.dzou.top/tags/SpringBoot/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程学习笔记-更新中</title>
    <link href="https://www.dzou.top/2019/07/23/Java%E5%B9%B6%E5%8F%91/"/>
    <id>https://www.dzou.top/2019/07/23/Java并发/</id>
    <published>2019-07-23T08:29:32.000Z</published>
    <updated>2019-07-23T10:00:59.562Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-创建线程方式"><a href="#一-创建线程方式" class="headerlink" title="一.创建线程方式"></a>一.创建线程方式</h2><ol><li>Thread</li><li>Runnable 面向接口编程，函数式接口（其实就是一个任务，最终由Thread构造函数传入）</li><li>Callable 带返回值线程</li><li>定时器 Timer</li><li>Lambda表达式</li><li>线程池 ThreadExecutorPool</li><li>内部类 </li><li>Spring 中 注解＠Aysnc</li></ol><blockquote><p>CPU分给每个线程一个时间片，很短，所以看起来是一起执行，切换过程就是==上下文切换==，会消耗一定的资源</p></blockquote><h2 id="二-线程问题"><a href="#二-线程问题" class="headerlink" title="二.线程问题"></a>二.线程问题</h2><h3 id="1-活跃性问题"><a href="#1-活跃性问题" class="headerlink" title="1.活跃性问题"></a>1.活跃性问题</h3><ul><li><p>死锁 ：互相等待 两个线程互相持有对方需要的资源并都不释放</p></li><li><p>饥饿：资源不足，线程优先级使得优先级低的得不到资源执行，高优先级吞噬低优先级时间片或者线程堵塞在同一个同步代码块</p><blockquote><p>避免饥饿：设置合理优先级；使用锁代替synchronized</p></blockquote></li><li><p>活锁：是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源。</p></li></ul><h3 id="2-线程安全性"><a href="#2-线程安全性" class="headerlink" title="2.线程安全性"></a>2.线程安全性</h3><ul><li>数据竞争：多线程下多个线程共享变量，对资源进行了非原子型操作</li></ul><h2 id="三-Synchronized"><a href="#三-Synchronized" class="headerlink" title="三.Synchronized"></a>三.Synchronized</h2><blockquote><p>锁是互斥的：你能执行我就不能执行</p></blockquote><ul><li>synchronized放在方法上：该方法为同步方法（静态、普通） 锁的对象时当前类实例</li><li>放在方法内部修饰代码块：该代码块为同步代码块</li></ul><h2 id="四-锁的类型"><a href="#四-锁的类型" class="headerlink" title="四.锁的类型"></a>四.锁的类型</h2><h3 id="1-重入锁"><a href="#1-重入锁" class="headerlink" title="1.重入锁"></a>1.重入锁</h3><blockquote><p>重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁</p></blockquote><ul><li>synchronized</li><li>ReentrantLock</li></ul><p>例：当a、b方法都被synchronized修饰时，在a方法中调用b方法是可以在一个线程进入的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+<span class="string">"a"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        b();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+<span class="string">"b"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo3 d = <span class="keyword">new</span> Demo3();</span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">30</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;i++)&#123;</span><br><span class="line">            threadPool.execute(d::a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-自旋锁"><a href="#2-自旋锁" class="headerlink" title="2.自旋锁"></a>2.自旋锁</h3><blockquote><p>当一个线程要获取锁时，该锁已经被其他线程获取了，那么它会一直等待该线程释放锁，不但判断所能否被成功获取，直到成功</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(Thread.activeCount()!=)&#123;</span><br><span class="line">            <span class="comment">//自旋</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程执行完毕！"</span>);</span><br></pre></td></tr></table></figure><p>没有执行任何有效的任务，会造成 busy-waiting</p><h3 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3.死锁"></a>3.死锁</h3><blockquote><p>互相等待 两个线程互相持有对方需要的资源并都不释放</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o2)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+<span class="string">"a"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (o2)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+<span class="string">"b"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo d = <span class="keyword">new</span> Demo();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                d.a();</span><br><span class="line">                d.b();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="五-volatile"><a href="#五-volatile" class="headerlink" title="五.volatile"></a>五.volatile</h2><blockquote><p>volatile是一种轻量级锁，被volatile修饰的变量在线程中是可见的，一个线程修改了变量的值，两一个变量可以读取</p></blockquote><p>生成汇编代码时会在volatile修饰的共享变量进行写操作的时候会多出<strong>Lock前缀的指令</strong></p><ul><li>把当前处理器缓存的内容写回到内存</li><li>这个写回内存的操作会使得CPU中缓存该内存地址的数据无效（保证数据一致性）</li></ul><h4 id="volatile-与-synchronized比较"><a href="#volatile-与-synchronized比较" class="headerlink" title="volatile 与 synchronized比较"></a>volatile 与 synchronized比较</h4><ul><li>volatile更加轻量，保证数据可见性，不保证原子性</li><li>synchronized重量级锁，保证数据原子性操作，可替代volatile</li></ul><h2 id="六-JDK-原子类"><a href="#六-JDK-原子类" class="headerlink" title="六.JDK 原子类"></a>六.JDK 原子类</h2><h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由JVM从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。实际上是借助硬件的相关指令来实现的，不会阻塞线程(或者说只是在硬件级别上阻塞了)。</p><ul><li>AtomicInteger、AtomicLong、AtomicBoolean</li><li>AtomicIntegerArray，AtomicLongArray</li><li>AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater</li><li>AtomicMarkableReference，AtomicStampedReference，AtomicReferenceArray</li></ul><blockquote><p>我们举AtomicInteger为例，当它执行==getAndIncrement()==自增时，它调用源码如下</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;   var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">        <span class="keyword">return</span> var5;</span><br></pre></td></tr></table></figure><p>自增是一个非原子操作，包括取值，自增，和赋值三个步骤。在进行写数据时，会在内存中保留一份原来的旧值，写的时候判断当前要写的值和旧值是否相等，不相等就继续等待，直到相等才执行写操作。</p><blockquote><p>当调用getAndAddInt时，调用源码如下</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">            var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">        <span class="keyword">return</span> var5;</span><br></pre></td></tr></table></figure><p>拿到内存最新值，使用CAS尝试将内存位置的值修改为目标值var5 + var4，如果修改失败，则获取该内存位置的新值v，然后继续尝试，直至修改成功。</p><p>compareAndSet方法调用了compareAndSwap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>核心：原子类的方法进行操作都是使用unsafe调用了compareAndSwap CAS 这个本地方法实现</p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p><strong>CompareAndSwap</strong> 比较并交换 根本是一个本地方法，有三个参数：内存地址、旧的值、即将更新的值</p><p>如果旧的值与将要更新的值相等，则把内存地址的值改为更新的值</p><p>利用CPU执行指令实现CAS</p><ul><li>总线加锁</li><li>缓存加锁</li></ul><p>CAS存在问题：</p><ol><li>循环时间长开销很大。</li><li>只能保证一个共享变量的原子操作。</li><li>ABA问题（AtomicStampedReference可以通过版本控制解决==但是==使用互斥同步更高效）</li></ol><h2 id="七-Lock"><a href="#七-Lock" class="headerlink" title="七.Lock"></a>七.Lock</h2><h3 id="Lock接口方法"><a href="#Lock接口方法" class="headerlink" title="Lock接口方法"></a>Lock接口方法</h3><ul><li><p>void lock()  </p><p>获取锁</p></li><li><p>void unlock()</p><p>释放锁</p></li><li><p>Boolean tryLock()</p><p>尝试去获取锁，立刻返回获取结果</p></li><li><p>boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</p><p>与tryLock不同点是在获取不到锁后会等待一段时间，还获取不到的话就返回false</p></li><li><p>void lockInterruptibly() throws InterruptedException;</p></li></ul><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法，是一个可重入锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line">         <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//处理任务</span></span><br><span class="line">         &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">             <span class="comment">//finally防止死锁</span></span><br><span class="line">             lock.unlock();</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><h3 id="lock与synchronized比较"><a href="#lock与synchronized比较" class="headerlink" title="lock与synchronized比较"></a>lock与synchronized比较</h3><p>lock需要自行获取和释放，synchronized不需要</p><p>lock可以提高读操作的效率，也可以知道是否获取到锁</p><h3 id="自定义锁"><a href="#自定义锁" class="headerlink" title="自定义锁"></a>自定义锁</h3><blockquote><p>实现Lock接口，实现其中方法</p></blockquote><ul><li>不可重入自定义锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果锁被获取到则等待释放</span></span><br><span class="line">        <span class="keyword">while</span> (isLocked)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等到unlock释放锁后 获取锁</span></span><br><span class="line">        isLocked = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......................</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置获取锁的标志为未获取</span></span><br><span class="line">        isLocked = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//通知其他线程获取锁</span></span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>可重入自定义锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Thread lockThread = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> lockCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第二个条件判断被锁的线程与当前贤臣过是否为同一个`，同一个的话可重入</span></span><br><span class="line">        <span class="keyword">while</span>(isLocked&amp;&amp;Thread.currentThread()!=lockThread)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        isLocked = <span class="keyword">true</span>;</span><br><span class="line">        lockCount++;</span><br><span class="line">        lockThread = Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line">    ..........................</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Thread.currentThread()==lockThread)&#123;</span><br><span class="line">            lockCount--;</span><br><span class="line">            <span class="keyword">if</span>(lockCount==<span class="number">0</span>)&#123;</span><br><span class="line">                isLocked = <span class="keyword">false</span>;</span><br><span class="line">                notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="八-AbstractQueuedSynchronizer-AQS"><a href="#八-AbstractQueuedSynchronizer-AQS" class="headerlink" title="八.AbstractQueuedSynchronizer(AQS)"></a>八.AbstractQueuedSynchronizer(AQS)</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-创建线程方式&quot;&gt;&lt;a href=&quot;#一-创建线程方式&quot; class=&quot;headerlink&quot; title=&quot;一.创建线程方式&quot;&gt;&lt;/a&gt;一.创建线程方式&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Thread&lt;/li&gt;
&lt;li&gt;Runnable 面向接口编程，函数式接口（其实
      
    
    </summary>
    
      <category term="Java并发编程" scheme="https://www.dzou.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="并发编程" scheme="https://www.dzou.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="锁" scheme="https://www.dzou.top/tags/%E9%94%81/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="学习笔记" scheme="https://www.dzou.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="同步" scheme="https://www.dzou.top/tags/%E5%90%8C%E6%AD%A5/"/>
    
      <category term="多线程" scheme="https://www.dzou.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程安全性" scheme="https://www.dzou.top/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    
      <category term="Synchronized" scheme="https://www.dzou.top/tags/Synchronized/"/>
    
      <category term="volatile" scheme="https://www.dzou.top/tags/volatile/"/>
    
      <category term="原子类" scheme="https://www.dzou.top/tags/%E5%8E%9F%E5%AD%90%E7%B1%BB/"/>
    
      <category term="CAS" scheme="https://www.dzou.top/tags/CAS/"/>
    
      <category term="ReentrantLoc" scheme="https://www.dzou.top/tags/ReentrantLoc/"/>
    
      <category term="线程池" scheme="https://www.dzou.top/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>牛客网算法编程题--办公室路径走法 解答</title>
    <link href="https://www.dzou.top/2019/07/23/%E5%8A%9E%E5%85%AC%E5%AE%A4%E8%B7%AF%E5%BE%84/"/>
    <id>https://www.dzou.top/2019/07/23/办公室路径/</id>
    <published>2019-07-23T08:29:32.000Z</published>
    <updated>2019-07-23T09:55:59.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="办公室路径走法"><a href="#办公室路径走法" class="headerlink" title="办公室路径走法"></a>办公室路径走法</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>shopee的办公室非常大，小虾同学的位置坐落在右上角，而大门却在左下角，可以把所有位置抽象为一个网格（门口的坐标为0，0），小虾同学很聪明，每次只向上，或者向右走，因为这样最容易接近目的地，但是小虾同学不想让自己的boss们看到自己经常在他们面前出没，或者迟到被发现。他决定研究一下如果他不通过boss们的位置，他可以有多少种走法？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">第一行 x,y,n (0&lt;x&lt;=30, 0&lt;y&lt;=30, 0&lt;=n&lt;= 20) 表示x,y小虾的座位坐标,n 表示boss的数量（ n &lt;= 20）</span><br><span class="line"></span><br><span class="line">接下来有n行, 表示boss们的坐标(0&lt;xi&lt;= x, 0&lt;yi&lt;=y，不会和小虾位置重合)</span><br><span class="line"></span><br><span class="line">x1, y1</span><br><span class="line"></span><br><span class="line">x2, y2</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">xn, yn</span><br></pre></td></tr></table></figure><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3 3 2</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="方法一-递归遍历-时间复杂度太高-很多点走了多次-sub-problem"><a href="#方法一-递归遍历-时间复杂度太高-很多点走了多次-sub-problem" class="headerlink" title="方法一:递归遍历(时间复杂度太高,很多点走了多次,sub-problem)"></a>方法一:递归遍历(时间复杂度太高,很多点走了多次,sub-problem)</h3><p>思路:使用自己编写的Point或者awt包下的把点封装成对象,对起始点进行递归,递归的出口为现在所在的点nowPoint为终点或者上面和右边同时存在boss,否则如果右边为空上面不为空,nowPoint往右遍历;如果右边不为空,上边为空则遍历nowPoint上边,如果都为空,对上边和右边同时遍历,最后进行计数并输出.</p><blockquote><p>但是递归时间复杂度太高,可达O(2^n^) 所以牛客网没有通过,它应该是想让我们使用dp(动态规划法)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Point endPoint;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Point&gt; bossList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String[] s = scanner.nextLine().split(<span class="string">" "</span>);</span><br><span class="line">        endPoint =  <span class="keyword">new</span> Point(Integer.parseInt(s[<span class="number">0</span>]),Integer.parseInt(s[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">int</span> numberBoss = Integer.parseInt(s[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numberBoss;i++)&#123;</span><br><span class="line">            String[] boss = scanner.nextLine().split(<span class="string">" "</span>);</span><br><span class="line">            bossList.add(<span class="keyword">new</span> Point(Integer.parseInt(boss[<span class="number">0</span>]),Integer.parseInt(boss[<span class="number">1</span>])));</span><br><span class="line">        &#125;</span><br><span class="line">        Point nowPoint = <span class="keyword">new</span> Point(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        walk(nowPoint);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">(Point nowPoint)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((nowPoint.x&lt;=endPoint.x&amp;&amp;nowPoint.y&lt;=endPoint.y)</span><br><span class="line">                &amp;&amp;!(nowPoint.x==endPoint.x&amp;&amp;nowPoint.y==endPoint.y)</span><br><span class="line">                &amp;&amp;!(existRight(nowPoint)&amp;&amp;existTop(nowPoint)))&#123;</span><br><span class="line">            <span class="keyword">if</span>(existRight(nowPoint)&amp;&amp;!existTop(nowPoint))&#123;</span><br><span class="line">                nowPoint.translate(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">                walk(nowPoint);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(existTop(nowPoint)&amp;&amp;!existRight(nowPoint))&#123;</span><br><span class="line">                nowPoint.translate(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">                walk(nowPoint);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!existRight(nowPoint)&amp;&amp;!existTop(nowPoint))&#123;</span><br><span class="line">                walk(<span class="keyword">new</span> Point(nowPoint.x+<span class="number">1</span>,nowPoint.y));</span><br><span class="line">                walk(<span class="keyword">new</span> Point(nowPoint.x,nowPoint.y+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arrive(nowPoint))&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">existRight</span><span class="params">(Point nowPoint)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bossList.contains(<span class="keyword">new</span> Point(nowPoint.x+<span class="number">1</span>,nowPoint.y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">existTop</span><span class="params">(Point nowPoint)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bossList.contains(<span class="keyword">new</span> Point(nowPoint.x,nowPoint.y+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">arrive</span><span class="params">(Point nowPoint)</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (nowPoint.x==endPoint.x&amp;&amp;nowPoint.y==endPoint.y-<span class="number">1</span>)||(nowPoint.x==endPoint.x-<span class="number">1</span>&amp;&amp;nowPoint.y==endPoint.y);</span><br><span class="line">        <span class="comment">//return nowPoint.x==endPoint.x&amp;&amp;nowPoint.y==endPoint.y;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="方法二-动态规划-把已经走过的点的值保存在数组里"><a href="#方法二-动态规划-把已经走过的点的值保存在数组里" class="headerlink" title="方法二:动态规划(把已经走过的点的值保存在数组里)"></a>方法二:动态规划(把已经走过的点的值保存在数组里)</h3><p>思路:</p><p>使用二维数组保存各点的走法,把有boss的格子赋值为-1,代表走不了,把起始位置的行和列(第0行,第0列)中没有boss的格子赋值为1,代表这些位置可以由初始位置通过一条路径到达(boss后面的除外),这里当然也可以把第一个boss前面的赋值为1;</p><p>然后遍历并计算每个格子的值(即为达到该点有几条路径),在进行路径相加时,由于我们把boss设置为了-1,所以应该在检查到boss要被加上时,把它去掉,也就是加上0(不能通过boss这个格子到达),最后得到终点的值也就是最后我们的总路径数.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String[] s = scanner.nextLine().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">long</span>[][] dp = <span class="keyword">new</span> <span class="keyword">long</span>[Integer.parseInt(s[<span class="number">0</span>])+<span class="number">1</span>][Integer.parseInt(s[<span class="number">1</span>])+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> numberBoss = Integer.parseInt(s[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numberBoss;i++)&#123;</span><br><span class="line">            String[] boss = scanner.nextLine().split(<span class="string">" "</span>);</span><br><span class="line">            dp[Integer.parseInt(boss[<span class="number">0</span>])][Integer.parseInt(boss[<span class="number">1</span>])] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(count(dp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">count</span><span class="params">(<span class="keyword">long</span>[][] dp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = dp.length;</span><br><span class="line">        <span class="keyword">int</span> j = dp[<span class="number">0</span>].length;</span><br><span class="line">       <span class="comment">// System.out.println("rows:"+i+" lines:"+j);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>;n&lt;i;n++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[n][<span class="number">0</span>]!=-<span class="number">1</span>)&#123;</span><br><span class="line">                dp[n][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>;m&lt;j;m++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[<span class="number">0</span>][m]!=-<span class="number">1</span>)&#123;</span><br><span class="line">                dp[<span class="number">0</span>][m] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">1</span>;m&lt;=i-<span class="number">1</span>;m++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">1</span>;n&lt;=j-<span class="number">1</span>;n++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[m][n]!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[m-<span class="number">1</span>][n]==-<span class="number">1</span>)&#123;</span><br><span class="line">                        dp[m][n] = dp[m][n - <span class="number">1</span>];</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[m][n-<span class="number">1</span>]==-<span class="number">1</span>)&#123;</span><br><span class="line">                        dp[m][n] = dp[m - <span class="number">1</span>][n];</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[m][n] = dp[m - <span class="number">1</span>][n] + dp[m][n - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="大家有想法和意见都可以交流-我之后还会定期更新牛客和LeetCode的算法题解法-同学们可以关注一下"><a href="#大家有想法和意见都可以交流-我之后还会定期更新牛客和LeetCode的算法题解法-同学们可以关注一下" class="headerlink" title="大家有想法和意见都可以交流,我之后还会定期更新牛客和LeetCode的算法题解法,同学们可以关注一下"></a>大家有想法和意见都可以交流,我之后还会定期更新牛客和LeetCode的算法题解法,同学们可以关注一下</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;办公室路径走法&quot;&gt;&lt;a href=&quot;#办公室路径走法&quot; class=&quot;headerlink&quot; title=&quot;办公室路径走法&quot;&gt;&lt;/a&gt;办公室路径走法&lt;/h2&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="算法" scheme="https://www.dzou.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="算法" scheme="https://www.dzou.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="牛客" scheme="https://www.dzou.top/tags/%E7%89%9B%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>动态规划算法基本案例</title>
    <link href="https://www.dzou.top/2019/07/23/Dynamic%20Programing/"/>
    <id>https://www.dzou.top/2019/07/23/Dynamic Programing/</id>
    <published>2019-07-23T06:29:32.000Z</published>
    <updated>2019-07-23T09:59:53.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dynamic-Programing"><a href="#Dynamic-Programing" class="headerlink" title="Dynamic Programing"></a>Dynamic Programing</h2><p>递归算法复杂度太高 可达O(2^n^) 动态规划可达O(n)</p><p>使用数组存放已经遍历过的值 下一次可以直接使用而不需要再次进行遍历</p><h3 id="exam1"><a href="#exam1" class="headerlink" title="exam1:"></a>exam1:</h3><p>找出给定整数数组不相邻最大和</p><p>思路:</p><p>每个值对应一个最优解,每个值对应两种情况,一种是选,则结果是它前面两个数的最优解加上它本身,另外一种是不选,结果是它前面一个元素的最优解.</p><p><img src="/images/3.png" alt="1562071409803"></p><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(opt(array,<span class="number">0</span>,array.length-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">opt</span><span class="params">(<span class="keyword">int</span>[] diguiArray,<span class="keyword">int</span> s,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s+diguiArray[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(diguiArray[<span class="number">0</span>]&gt;diguiArray[<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> opt(diguiArray,s,<span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> s+diguiArray[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> a = opt(diguiArray,s+diguiArray[i],i-<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">int</span> b = opt(diguiArray,s,i-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> Math.max(a,b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="动态规划法"><a href="#动态规划法" class="headerlink" title="动态规划法"></a>动态规划法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(dp(array,array.length-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                dp[i] = array[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i-<span class="number">1</span>]&gt;dp[i])&#123;</span><br><span class="line">                    dp[i] = dp[i-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> a = dp[i-<span class="number">2</span>]+array[i];</span><br><span class="line">                <span class="keyword">int</span> b = dp[i-<span class="number">1</span>];</span><br><span class="line">                dp[i] = Math.max(a,b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Dynamic-Programing&quot;&gt;&lt;a href=&quot;#Dynamic-Programing&quot; class=&quot;headerlink&quot; title=&quot;Dynamic Programing&quot;&gt;&lt;/a&gt;Dynamic Programing&lt;/h2&gt;&lt;p&gt;递归算法复杂
      
    
    </summary>
    
      <category term="算法" scheme="https://www.dzou.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="算法" scheme="https://www.dzou.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="牛客" scheme="https://www.dzou.top/tags/%E7%89%9B%E5%AE%A2/"/>
    
      <category term="动态规划" scheme="https://www.dzou.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>JDK8新特性-流Stream，Lambda表达式以及Comparator和Comparable使用</title>
    <link href="https://www.dzou.top/2019/06/23/Stream%E5%92%8CCollection/"/>
    <id>https://www.dzou.top/2019/06/23/Stream和Collection/</id>
    <published>2019-06-23T08:35:32.000Z</published>
    <updated>2019-07-23T10:01:58.988Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lambda-Jdk8"><a href="#Lambda-Jdk8" class="headerlink" title="Lambda Jdk8"></a>Lambda Jdk8</h2><p> Lambda 是一个匿名函数，只关注参数列表和方法体,我们可以把 Lambda表达式理解为是一段可以传递的代码（将代码像数据一样进行传递)</p><p>类型推断:省略参数类型</p><h3 id="与内部类比较"><a href="#与内部类比较" class="headerlink" title="与内部类比较"></a>与内部类比较</h3><p>内部类this关键字指向内部类本身,Lambda中this指向lambda所处在的类</p><p>Java编译器将lambda表达式编译成类的私有方法。使用了Java 7的 <strong>invokedynamic</strong> 字节码指令来动态绑定这个方法。</p><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>引入了-&gt;新操作符:参数表加操作体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Parameters)-&gt;&#123;expressions&#125;</span><br></pre></td></tr></table></figure><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>类名 :: 方法名</p><h3 id="功能接口-使用要求"><a href="#功能接口-使用要求" class="headerlink" title="功能接口(使用要求)"></a>功能接口(使用要求)</h3><p>使用@FunctionalInterface注解</p><p>接口中的抽象方法只能是一个(函数式接口)</p><h4 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a><strong>Predicate</strong></h4><p>java.util.function.Predicate函数式接口,向API方法添加逻辑,非常适合做过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    List&lt;String&gt; names=Arrays.asList(<span class="string">"dx"</span>,<span class="string">"wdt"</span>,<span class="string">"zfb"</span>,<span class="string">"wuguangyao"</span>,<span class="string">"nihaoshiw"</span>));</span><br><span class="line">    Predicate&lt;String&gt; filter1 = str-&gt;str.length()&gt;<span class="number">5</span>;</span><br><span class="line">    Predicate&lt;String&gt; filter2 = str-&gt;str.endsWith(<span class="string">"yao"</span>);</span><br><span class="line">   <span class="comment">// filter(names,(n)-&gt;((String)n).startsWith("d"));</span></span><br><span class="line">    filter(names,filter2);</span><br><span class="line">    names.stream().filter(filter1.and(filter2))</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(List&lt;String&gt; list, Predicate condition)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(String str:list)&#123;</span><br><span class="line">        <span class="keyword">if</span>(condition.test(str))&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runnable t = ()-&gt; System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">        t.run();</span><br></pre></td></tr></table></figure><p>s</p><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>根接口</p><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><h4 id="implements-Comparable"><a href="#implements-Comparable" class="headerlink" title="implements Comparable"></a>implements Comparable</h4><p>实体类实现Comparable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">~~~~</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stuId.compareTo(o.getStuId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Collections-sort-List-lt-gt-new-Comparator"><a href="#Collections-sort-List-lt-gt-new-Comparator" class="headerlink" title="Collections.sort(List&lt;?&gt;,new Comparator())"></a>Collections.sort(List&lt;?&gt;,new Comparator())</h4><p>创建一个比较器实现Comparator接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;StudentNoSort&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(StudentNoSort o1, StudentNoSort o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getStuId().compareTo(o2.getStuId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p>使用Jdk8 Stream更加简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;StudentNoSort&gt; streamList = list.stream()</span><br><span class="line">                .filter(w -&gt; w.getClass()==StudentNoSort.class)</span><br><span class="line">                .sorted(((o1, o2) -&gt; o1.getStuId().compareTo(o2.getStuId())))</span><br><span class="line">                .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><hr><h2 id="Stream-1"><a href="#Stream-1" class="headerlink" title="Stream"></a>Stream</h2><p>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。</p><h3 id="Stream构成"><a href="#Stream构成" class="headerlink" title="Stream构成"></a>Stream构成</h3><p>获取一个数据源（source）→ 数据转换→执行操作(返回新的Stream对象)，这就允许对其操作可以像链条一样排列，变成一个管道</p><p><img src="/images/4.png" alt="1561548534995"></p><h4 id="Stream-Source"><a href="#Stream-Source" class="headerlink" title="Stream Source"></a>Stream Source</h4><p>集合，数组，I/O channel， 产生器generator 等</p><h4 id="Stream-Operation"><a href="#Stream-Operation" class="headerlink" title="Stream Operation"></a>Stream Operation</h4><h5 id="Intermediate"><a href="#Intermediate" class="headerlink" title="Intermediate"></a>Intermediate</h5><p>一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。</p><h6 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h6><p>创建一个List</p><h6 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h6><p>过滤器:集合进行过滤操作</p><h6 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h6><p>集合元素去重</p><h6 id="map"><a href="#map" class="headerlink" title="map"></a>map</h6><p>对函数进行操作</p><h6 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h6><p>组合元素</p><h6 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h6><p>遍历元素</p><h6 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h6><p>限定流中数据的数量</p><h6 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h6><p>排序 使用Comparator接口</p><h6 id="march-allMatch-noneMatch-anyMatch"><a href="#march-allMatch-noneMatch-anyMatch" class="headerlink" title="march,allMatch,noneMatch,anyMatch"></a>march,allMatch,noneMatch,anyMatch</h6><p>符合元素传入predicate,返回boolean</p><h6 id="还有以下"><a href="#还有以下" class="headerlink" title="还有以下"></a>还有以下</h6><p>mapToInt (转换为int), summaryStatistics(int型变量统计) ,sum(int型求和)</p><h5 id="Terminal"><a href="#Terminal" class="headerlink" title="Terminal"></a>Terminal</h5><p>一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。</p><h4 id="构造Stream"><a href="#构造Stream" class="headerlink" title="构造Stream"></a>构造Stream</h4><p>Collections</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collections</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(strArray);</span><br><span class="line">stream = list.stream();</span><br></pre></td></tr></table></figure><h3 id="example"><a href="#example" class="headerlink" title="example:"></a>example:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 12, 1, 1, 2, 3, 2, 432, 4, 32, 54, 3, 3));</span><br><span class="line">        int sum = list.stream().map(x -&gt; x * x)</span><br><span class="line">                .reduce((x, y) -&gt; x + y)</span><br><span class="line">                .get();</span><br></pre></td></tr></table></figure><h4 id="遍历文件-nio-lambda"><a href="#遍历文件-nio-lambda" class="headerlink" title="遍历文件(nio+lambda)"></a>遍历文件(nio+lambda)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Path start = FileSystems.getDefault().getPath(&quot;/home/dzou/报告/模电&quot;);</span><br><span class="line">        Files.walk(start)</span><br><span class="line">                .filter(path -&gt; path.toFile().isFile())</span><br><span class="line">                .filter(path -&gt; path.toString().endsWith(&quot;.jpg&quot;))</span><br><span class="line">                .forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数</p><h2 id="并行parallelStream"><a href="#并行parallelStream" class="headerlink" title="并行parallelStream"></a>并行parallelStream</h2><p>我们看这个代码,输出不是顺序的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">        numbers.parallelStream()</span><br><span class="line">                .forEach(out::println);</span><br></pre></td></tr></table></figure><p>底层使用ForkJoinPool,相比于ThreadPoolExecutor,可以让线程创建新的任务,并挂起当前任务,此时线程可以在队列中选择子任务执行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Lambda-Jdk8&quot;&gt;&lt;a href=&quot;#Lambda-Jdk8&quot; class=&quot;headerlink&quot; title=&quot;Lambda Jdk8&quot;&gt;&lt;/a&gt;Lambda Jdk8&lt;/h2&gt;&lt;p&gt; Lambda 是一个匿名函数，只关注参数列表和方法体,我们可以把 
      
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="后端" scheme="https://www.dzou.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Lambda" scheme="https://www.dzou.top/tags/Lambda/"/>
    
      <category term="stream" scheme="https://www.dzou.top/tags/stream/"/>
    
  </entry>
  
  <entry>
    <title>Java异常处理机制-Java编程思想</title>
    <link href="https://www.dzou.top/2019/04/23/thinking%20java%E5%BC%82%E5%B8%B8/"/>
    <id>https://www.dzou.top/2019/04/23/thinking java异常/</id>
    <published>2019-04-23T08:35:32.000Z</published>
    <updated>2019-07-23T10:02:32.705Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>不是所有的错误都可以在编译时获得，有些错误只能在运行时获得，Java使用异常报告错误，传递给某个接受者来处理，使得你的应用更加可靠</p><p>执行到异常时不能往下继续执行，要从当前环境跳出（抛出异常），给==异常处理程序==处理</p><p>异常使得我们可以把一件事当做一个事务</p><p><strong>构造器：</strong></p><ul><li><p>默认构造器</p></li><li><p>字符串参数构造器 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointException（“t=<span class="keyword">null</span>”）；</span><br></pre></td></tr></table></figure><p>返回一个异常对象并退出当前作用域，交给异常处理程序，可能距离异常抛出地很远，跨越方法调用栈的很多层次</p></li></ul><p><strong>try，catch</strong></p><p>如果不希望产生异常的时候结束可以使用try块，并通过catch语句来处理（异常处理程序）</p><p>只有匹配的catch语句才能被执行，匹配到不在查找其他cathc块</p><blockquote><p>把越宽的异常类放在catch块最下面，防止范围过宽的基类被抢先执行，Exception</p></blockquote><p><strong>终止与恢复</strong></p><p>终止：异常一旦被抛出，无法回来继续执行，错误已无法挽回</p><p>恢复：异常处理程序的工作是修正错误，会重新尝试调用出问题的方法（放到While块中）</p><h2 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h2><p>分为Error和Exception，一般我们只关心Exception</p><p>==printStackTrace方法==输出==堆栈跟踪信息==：</p><ul><li>void printStackTrace()</li><li>void printStackTrace(PrintStream)</li><li>void printStackTrace(PrintWriter)</li></ul><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>继承Exception类</p><h3 id="日志记录异常"><a href="#日志记录异常" class="headerlink" title="日志记录异常"></a>日志记录异常</h3><p>在catch块调用如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.error(e.getMessage(), e);</span><br></pre></td></tr></table></figure><p><strong>getMessage()</strong></p><p>类似于toString()</p><h3 id="异常说明"><a href="#异常说明" class="headerlink" title="异常说明"></a>异常说明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">throws</span> TooBig, TooSmall</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><em>这是一个规范写法，使得调用该方法的程序员知道该方法会捕获的异常</em></p><h3 id="RuntimeException-不受检查异常"><a href="#RuntimeException-不受检查异常" class="headerlink" title="RuntimeException 不受检查异常"></a>RuntimeException 不受检查异常</h3><p>JVM自动捕获，运行时异常 ==无需异常说明==</p><h3 id="使用finally清洗"><a href="#使用finally清洗" class="headerlink" title="使用finally清洗"></a>使用finally清洗</h3><p>对于Java有内存回收机制，需要它有什么用？</p><p>开关：把某个资源恢复到初始状态 ex：已打开的连接，文件，画的图形</p><p>没有异常捕获也会执行</p><p>###　构造器异常</p><p>当一个对象在执行构造函数时出现异常，那么它没有构造成功，我们无需close，所以我们可以使用==嵌套try-catch==来实现在需要的时候close</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cleanup</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      InputFile in = <span class="keyword">new</span> InputFile( <span class="string">"Cleanup.java"</span> );</span><br><span class="line">      <span class="keyword">try</span> &#123; <span class="comment">// 上面InputFile构造完成以后立即进入该try-finally子句！</span></span><br><span class="line">        String s = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>( (s = in.getLine()) != <span class="keyword">null</span> )</span><br><span class="line">          System.out.println(<span class="string">""</span>+ i++ + <span class="string">": "</span> + s);</span><br><span class="line">      &#125; <span class="keyword">catch</span>( Exception e ) &#123;</span><br><span class="line">        e.printStackTrace( System.out );</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;  <span class="comment">// 该finally一定确保in能正常cleanup()！</span></span><br><span class="line">        in.cleanup();</span><br><span class="line">      &#125; </span><br><span class="line">    &#125; <span class="keyword">catch</span>( Exception e ) &#123;</span><br><span class="line">      System.out.println( <span class="string">"InputFile ctor failed!"</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="comment">// end main()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重抛异常"><a href="#重抛异常" class="headerlink" title="重抛异常"></a>重抛异常</h3><p>在一个异常被捕获了在catch块中把它再次抛出</p><h3 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h3><p>常常想要在捕获一个异常后抛出另一个异常</p><h3 id="缺陷：异常丢失"><a href="#缺陷：异常丢失" class="headerlink" title="缺陷：异常丢失"></a>缺陷：异常丢失</h3><ul><li>从finally中return</li><li>从finally中抛出其他异常捕获</li></ul><h3 id="异常的限制"><a href="#异常的限制" class="headerlink" title="异常的限制"></a>异常的限制</h3><p>覆盖基类的方法时，只能抛出基类方法中声明的异常</p><h3 id="把被检查的异常转换成不被检查的异常"><a href="#把被检查的异常转换成不被检查的异常" class="headerlink" title="把被检查的异常转换成不被检查的异常"></a>把被检查的异常转换成不被检查的异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;  </span><br><span class="line">     <span class="comment">//。。。to do somthing useful  </span></span><br><span class="line">&#125;<span class="keyword">catch</span>(CheckedException e)&#123;  </span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法不用“吞下”异常，也不必把它放到方法的异常说明里面，而异常链还能保证你不会丢失任何原始的异常信息。6</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;异常&quot;&gt;&lt;a href=&quot;#异常&quot; class=&quot;headerlink&quot; title=&quot;异常&quot;&gt;&lt;/a&gt;异常&lt;/h2&gt;&lt;p&gt;不是所有的错误都可以在编译时获得，有些错误只能在运行时获得，Java使用异常报告错误，传递给某个接受者来处理，使得你的应用更加可靠&lt;/p&gt;

      
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="后端" scheme="https://www.dzou.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="异常" scheme="https://www.dzou.top/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="Java编程思想" scheme="https://www.dzou.top/tags/Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
</feed>
