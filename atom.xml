<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dzou&#39;s Blog</title>
  
  <subtitle>No pains,no gains.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.dzou.top/"/>
  <updated>2019-08-02T11:42:53.122Z</updated>
  <id>https://www.dzou.top/</id>
  
  <author>
    <name>dzou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot自动配置源码分析及详解</title>
    <link href="https://www.dzou.top/post/366ffd58.html"/>
    <id>https://www.dzou.top/post/366ffd58.html</id>
    <published>2019-08-02T11:32:01.000Z</published>
    <updated>2019-08-02T11:42:53.122Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringBoot自动配置"><a href="#SpringBoot自动配置" class="headerlink" title="SpringBoot自动配置"></a>SpringBoot自动配置</h2><p>我们都知道一个SpringBoot主配置类只要标注上<u>@SpringBootApplication</u>的注解，Spring就会帮我们自动配置各个组件和实例化Bean，我们来通过源码分析一下SpringBoot自动配置原理。</p><p>首先我们要知道，SpringBoot将符合条件的@Configuration类都加载到Spring容器中，就像一只八爪鱼，我们的启动类就是一个典型的@Configuration类。</p><h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>包括下面两个关键的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br></pre></td></tr></table></figure><p>其中@SpringBootConfiguration 就是get主配置类添加上@Configuration 注解让主配置类的自动配置能被扫描到</p><p>下面我们主要分析一下@EnableAutoConfiguration 注解</p><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>其中也包含两个关键注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;AutoConfigurationImportSelector.class&#125;)</span><br></pre></td></tr></table></figure><ul><li>第一个用作包扫描自动配置</li><li>第二个导入AutoConfigurationImportSelector类用作SpringBoot提供的其他组件的自动配置选择器</li></ul><p>我们先看一下第一个</p><h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h4><p>这个注解导入了SpringBoot中的Registrar类 用作包路径下的Bean扫描并注册到BeanFactory中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(&#123;Registrar.class&#125;)</span><br></pre></td></tr></table></figure><p>详细看一下这个类</p><h4 id="Registrar注册类"><a href="#Registrar注册类" class="headerlink" title="Registrar注册类"></a>Registrar注册类</h4><p>其中主要的方法是registerBeanDefinitions</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Registrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">DeterminableImports</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取到元信息的包名传入注册器</span></span><br><span class="line">        AutoConfigurationPackages.register(registry, (<span class="keyword">new</span> AutoConfigurationPackages.PackageImport(metadata)).getPackageName());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>传入两个参数：</p><ul><li>metadata 启动类元信息</li><li>registry 用作注册的Bean注册器</li></ul><p>目录结构如下：</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/autoconfig/9.png"><p>元信息如下：</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/autoconfig/2.png"><p>new AutoConfigurationPackages.PackageImport(metadata)).getPackageName()获取到该启动类所在路径的包名，传如register方法注册该包名下的所有需要注册并实例化的Bean（包括@Component @Service @Mapper @Repository等）</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/autoconfig/3.png"><h5 id="AutoConfigurationPackages中register方法"><a href="#AutoConfigurationPackages中register方法" class="headerlink" title="AutoConfigurationPackages中register方法"></a>AutoConfigurationPackages中register方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(BeanDefinitionRegistry registry, String... packageNames)</span></span></span><br></pre></td></tr></table></figure><p>根据传入的register和包名packageName注册该包名下的所有需要注册并实例化的Bean</p><p>其中我们要关注的是下面这段代码：</p><ul><li>GenericBeanDefinition 创建Bean的一站式组件，包括Bean的参数、属性、类的信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新建一个GenericBeanDefinition描述Bean的实例</span></span><br><span class="line">GenericBeanDefinition beanDefinition = <span class="keyword">new</span> GenericBeanDefinition();       <span class="comment">//设置bean的类名称</span></span><br><span class="line">beanDefinition.setBeanClass(AutoConfigurationPackages.BasePackages.class);</span><br><span class="line"><span class="comment">//获取构造器参数并保存</span></span><br><span class="line">beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(<span class="number">0</span>, packageNames);</span><br><span class="line"><span class="comment">//Bean的角色 感兴趣的可以去了解一下，有0,1,2对应三种不同角色</span></span><br><span class="line">beanDefinition.setRole(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//参数设置完调用registerBeanDefinition注册并实例化Bean</span></span><br><span class="line">registry.registerBeanDefinition(BEAN, beanDefinition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="getConstructorArgumentValues"><a href="#getConstructorArgumentValues" class="headerlink" title="getConstructorArgumentValues"></a>getConstructorArgumentValues</h6><p>这个方法用于获取构造器参数并保存</p><ul><li>ConstructorArgumentValues 是一个构造器参数保存器，保存Bean的构造方法的参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConstructorArgumentValues <span class="title">getConstructorArgumentValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.constructorArgumentValues == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//创建一个新的构造器参数保存器</span></span><br><span class="line">        <span class="keyword">this</span>.constructorArgumentValues = <span class="keyword">new</span> ConstructorArgumentValues();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.constructorArgumentValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="DefaultListableBeanFactory中实现的registerBeanDefinition方法"><a href="#DefaultListableBeanFactory中实现的registerBeanDefinition方法" class="headerlink" title="DefaultListableBeanFactory中实现的registerBeanDefinition方法"></a>DefaultListableBeanFactory中实现的registerBeanDefinition方法</h6><p>该方法对GenericBeanDefinition创建的Bean进行注册到BeanFactory</p><p>传入beanName和beanDefinition</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br></pre></td></tr></table></figure><ul><li>检查完Bean是否合法后先判断是否存在相同Bean的注册，存在抛出异常，不存在执行如下</li></ul><p>其中主要代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始注册Bean</span></span><br><span class="line"><span class="comment">//如果已启动注册状态则要加锁注册单例singleton</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.hasBeanCreationStarted()) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">        <span class="comment">//把Bean存入beanDefinitionMap</span></span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">        List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//把需要注册的Bean添加到map中</span></span><br><span class="line">        updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">        updatedDefinitions.add(beanName);</span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">        <span class="comment">//默认为单例</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">            Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">            updatedSingletons.remove(beanName);</span><br><span class="line">            <span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果未启动直接注册无需加锁</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">    <span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图就是beanDefinitionMap返回的值，里面除了Spring框架提供的一些必要的Bean需要注册外，就是我们主启动类所在包下的所有需要扫描的Bean，我只有一个主启动类和一个controller 下面标出</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/autoconfig/4.png"><p>当我尝试把写的HelloWorldController的@RestController注解注释掉以后，SpringBoot没有扫描到这个Controller，也就没有把它注册到BeanFactory中</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/autoconfig/10.png"><h4 id="AutoConfigurationImportSelector"><a href="#AutoConfigurationImportSelector" class="headerlink" title="AutoConfigurationImportSelector"></a>AutoConfigurationImportSelector</h4><p>看完@AutoConfigurationPackage 注解我们看一下 @EnableAutoConfiguration另一个注解@Import({AutoConfigurationImportSelector.class}) 该注解导入了SpringBoot中AutoConfigurationImportSelector类（自动配置选择器）用作选择SpringBoot提供的所需组件Bean的选择并自动配置</p><p>主要是下面的方法</p><h5 id="getAutoConfigurationEntry方法"><a href="#getAutoConfigurationEntry方法" class="headerlink" title="getAutoConfigurationEntry方法"></a>getAutoConfigurationEntry方法</h5><p>传入两个参数</p><ul><li>autoConfigurationMetadata自顶配置元信息</li><li>annotationMetadata注解元信息</li></ul><p>注解元信息的参数（配置类上添加的@ComponentScan(Exclude)）：</p><p>excludeName和exclude表示需要排除扫描自动配置的类，String[0]表示了没有需要排除的</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/autoconfig/8.png"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取注解元信息参数</span></span><br><span class="line">AnnotationAttributes attributes = <span class="keyword">this</span>.getAttributes(annotationMetadata);</span><br><span class="line"><span class="comment">//调用getCandidateConfigurations获取需要自动配置的类或者功能</span></span><br><span class="line">List&lt;String&gt; configurations = <span class="keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line"><span class="comment">//去重</span></span><br><span class="line">configurations = <span class="keyword">this</span>.removeDuplicates(configurations);</span><br><span class="line"><span class="comment">//检查并排除exclude类</span></span><br><span class="line">Set&lt;String&gt; exclusions = <span class="keyword">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line"><span class="keyword">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">configurations.removeAll(exclusions);</span><br><span class="line">configurations = <span class="keyword">this</span>.filter(configurations, autoConfigurationMetadata);</span><br><span class="line"><span class="keyword">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);</span><br></pre></td></tr></table></figure><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/autoconfig/7.png"><h5 id="getCandidateConfigurations"><a href="#getCandidateConfigurations" class="headerlink" title="getCandidateConfigurations"></a>getCandidateConfigurations</h5><p>负责加载META-INF/spring.factories中的配置的类，这些类就是SpringBoot提供的所需要加载的那些*AutoConfiguration类，也就是要注册的Bean或功能，获取到候选类的BeanName返回一个List</p><p>借助SpringFactoriesLoader类实现加载自动配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//加载类路径下META-INF/spring.factories中的自动配置类</span></span><br><span class="line">        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(<span class="keyword">this</span>.getSpringFactoriesLoaderFactoryClass(), <span class="keyword">this</span>.getBeanClassLoader());</span><br><span class="line">        Assert.notEmpty(configurations, <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line">        <span class="keyword">return</span> configurations;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>返回结果如下:</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/autoconfig/1.1.png"><h6 id="loadFactoryNames"><a href="#loadFactoryNames" class="headerlink" title="loadFactoryNames"></a>loadFactoryNames</h6><p>SpringBoot使用ClassLoader类加载机制加载META-INF/spring.factories</p><p>将根据EnableAutoConfiguration类名称去加载需要的类或者功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        String factoryClassName = factoryClass.getName();</span><br><span class="line">        <span class="keyword">return</span> (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>SpringFactoriesLoader的实现机制跟util包下的 ServiceLoader（SPL）实现机制类似，是一种服务查找机制，为接口查找服务实现类，感兴趣的可以去了解一下</p></blockquote>]]></content>
    
    <summary type="html">
    
      我们都知道一个SpringBoot主配置类只要标注上&lt;u&gt;@SpringBootApplication&lt;/u&gt;的注解，Spring就会帮我们自动配置各个组件和实例化Bean，我们来通过源码分析一下SpringBoot自动配置原理。
    
    </summary>
    
      <category term="Java Web" scheme="https://www.dzou.top/categories/Java-Web/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="分布式" scheme="https://www.dzou.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="SpringBoot" scheme="https://www.dzou.top/tags/SpringBoot/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="后端" scheme="https://www.dzou.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Spring" scheme="https://www.dzou.top/tags/Spring/"/>
    
      <category term="微服务" scheme="https://www.dzou.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>java序列化Serializable和反序列化状态修饰符transient</title>
    <link href="https://www.dzou.top/post/616dc7a4.html"/>
    <id>https://www.dzou.top/post/616dc7a4.html</id>
    <published>2019-07-24T02:46:21.000Z</published>
    <updated>2019-08-02T11:49:15.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Serializable序列化接口"><a href="#Serializable序列化接口" class="headerlink" title="Serializable序列化接口"></a>Serializable序列化接口</h2><p>使用序列化接口最重要的两个原因是：</p><p>1、将对象的状态保存在存储媒体中以便可以在以后重新创建出完全相同的副本；</p><p>2、按值将对象从一个应用程序域发送至另一个应用程序域。</p><p>实现serializable接口的作用是就是可以把对象存到字节流，然后可以恢复。所以你想如果你的对象没实现序列化怎么才能进行网络传输呢，要网络传输就得转为字节流，所以在分布式应用中，你就得实现序列化，如果你不需要分布式应用，那就没那个必要实现序列化。</p><h2 id="tranisent"><a href="#tranisent" class="headerlink" title="tranisent"></a>tranisent</h2><p>“不可序列化状态”。<br>打个比方，如果一个用户有一些敏感信息（譬如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输。这些信息对应的变量就可以被定义为transient类型。换句话说，这个字段的生命周期仅存于调用者的内存中。<br>如定义类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8294180014912103005L</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 用户名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 密码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>密码字段为transient，这时候如果对该对象进行序列化，这个密码字段是不会被保存的。</p>]]></content>
    
    <summary type="html">
    
      实现serializable接口的作用是就是可以把对象存到字节流，然后可以恢复。所以你想如果你的对象没实现序列化怎么才能进行网络传输呢，要网络传输就得转为字节流，所以在分布式应用中，你就得实现序列化，如果你不需要分布式应用，那就没那个必要实现序列化。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="序列化" scheme="https://www.dzou.top/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>转发和重定向的区别</title>
    <link href="https://www.dzou.top/post/67d1f796.html"/>
    <id>https://www.dzou.top/post/67d1f796.html</id>
    <published>2019-07-24T02:42:22.000Z</published>
    <updated>2019-08-02T11:45:45.740Z</updated>
    
    <content type="html"><![CDATA[<h2 id="转发和重定向区别"><a href="#转发和重定向区别" class="headerlink" title="转发和重定向区别"></a>转发和重定向区别</h2><h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>forward，由服务器发出，把request、response处理权转交给其他客户端，并不会失效<br>客户首先发送一个请求到服务器端，服务器端发现匹配的servlet，并指定它去执行，当这个servlet执行完之后，它要调用getRequestDispacther()方法，把请求转发给指定的页面，在一个请求里完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转发,转发是在服务器端转发的，客户端是不知道的</span></span><br><span class="line">request.getRequestDispatcher(<span class="string">"/index.jsp"</span>).forward(request, response);</span><br></pre></td></tr></table></figure><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>sendRedirect，由客户端发出，请求servlet，request会失效<br> 客户发送一个请求到服务器，服务器匹配servlet，这都和请求转发一样，servlet处理完之后调用了sendRedirect()这个方法，这个方法是response的方法，所以，当这个servlet处理完之后，看到response.senRedirect()方法，立即向客户端返回这个响应，响应行告诉客户端你必须要再发送一个请求，去访问新页面，紧接着客户端受到这个请求后，立刻发出一个新的请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重定向，不会共享request</span></span><br><span class="line">response.sendRedirect(<span class="string">"/student_list.jsp"</span>);</span><br><span class="line">response.sendRedirect(request.getContextPath() + <span class="string">"/student_list.jsp"</span>);</span><br></pre></td></tr></table></figure><ul><li><p>转发在服务器端完成的；重定向是在客户端完成的<br>转发的速度快；重定向速度慢</p></li><li><p>转发的是同一次请求；重定向是两次不同请求</p></li><li><p>转发不会执行转发后的代码；重定向会执行重定向之后的代码</p></li><li><p>转发地址栏没有变化；重定向地址栏有变化</p></li><li><p>转发必须是在同一台服务器下完成；重定向可以在不同的服务器下完成</p></li></ul>]]></content>
    
    <summary type="html">
    
      转发和重定向区别,forward，由服务器发出，把request、response处理权转交给其他客户端，并不会失效;sendRedirect，由客户端发出，请求servlet，request会失效 客户发送一个请求到服务器，服务器匹配servlet
    
    </summary>
    
      <category term="Java Web" scheme="https://www.dzou.top/categories/Java-Web/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>cookie和session</title>
    <link href="https://www.dzou.top/post/319bf02d.html"/>
    <id>https://www.dzou.top/post/319bf02d.html</id>
    <published>2019-07-24T02:26:22.000Z</published>
    <updated>2019-08-02T11:46:58.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="session-and-cookie"><a href="#session-and-cookie" class="headerlink" title="session and cookie"></a>session and cookie</h2><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>属性：</p><ul><li>Max-Age有效期  ：正表示相对创建时间，负表示使用默认（关闭浏览器销毁），零表示销毁</li><li>Path在url那个路径下有效（“/”）表示整个web项目下</li><li>secure：设置了属性secure，cookie只有在https协议加密情况下才会发送给服务端</li></ul><p>服务端创建cookie：<br>1.new Cookie<br>2.response.addCookie<br>3.Cookie[] cookies = request.getCookies;<br>前端：ajax获取cookie</p><p>由于http是无状态的协议，一旦客户端和服务器的数据交换完毕，就会断开连接，再次请求，会重新连接，这就说明服务器单从网络连接上是没有办法知道用户身份的。怎么办呢？那就给每次新的用户请求时，给它颁发一个身份证（独一无二）吧，下次访问，必须带上身份证，这样服务器就会知道是谁来访问了，针对不同用户，做出不同的响应。，这就是Cookie的原理。</p><p>其实cookie是一个很小的文本文件，是浏览器储存在用户的机器上的。Cookie是纯文本，没有可执行代码。储存一些服务器需要的信息，每次请求站点，会发送相应的cookie，这些cookie可以用来辨别用户身份信息等作用。</p><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p> session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。<br>session id就是session的标识符<br>除非程序通知服务器删除一个session，否则服务器会一直保留。大部分session机制都使用会话cookie来保存session id，而关闭浏览器后这个session id就消失了，再次连接服务器时也就无法找到原来的session。<br>恰恰是由于关闭浏览器不会导致session被删除，迫使服务器为seesion设置了一个失效时间，当距离客户端上一次使用session的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把session删除以节省存储空间<br>调用 session.invalidate 使得session失效</p>]]></content>
    
    <summary type="html">
    
      其实cookie是一个很小的文本文件，是浏览器储存在用户的机器上的。Cookie是纯文本，没有可执行代码。储存一些服务器需要的信息，每次请求站点，会发送相应的cookie，这些cookie可以用来辨别用户身份信息等作用。 session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。
    
    </summary>
    
      <category term="Java Web" scheme="https://www.dzou.top/categories/Java-Web/"/>
    
    
      <category term="网络编程" scheme="https://www.dzou.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="session" scheme="https://www.dzou.top/tags/session/"/>
    
      <category term="cookie" scheme="https://www.dzou.top/tags/cookie/"/>
    
  </entry>
  
  <entry>
    <title>NIO学习笔记（IO、AIO、BIO）--更新中</title>
    <link href="https://www.dzou.top/post/e571ec33.html"/>
    <id>https://www.dzou.top/post/e571ec33.html</id>
    <published>2019-07-24T02:13:10.000Z</published>
    <updated>2019-08-02T11:50:57.603Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p>I/O ? 或者输入/输出 ? 指的是计算机与外部世界或者一个程序与计算机的其余部分的之间的接口。它对于任何计算机系统都非常关键，因而所有 I/O 的主体实际上是内置在操作系统中的。单独的程序一般是让系统为它们完成大部分的工作。</p><p>在 Java 编程中，直到最近一直使用 流 的方式完成 I/O。所有 I/O 都被视为单个的字节的移动，通过一个称为 Stream 的对象一次移动一个字节。流 I/O 用于与外部世界接触。它也在内部使用，用于将对象转换为字节，然后再转换回对象。</p><p>传统流IO的好处是使用简单，将底层的机制都抽象成流，但缺点就是性能不足。而且IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。</p><h2 id="传统BIO（blocking-IO）"><a href="#传统BIO（blocking-IO）" class="headerlink" title="传统BIO（blocking IO）"></a>传统BIO（blocking IO）</h2><p>阻塞：accept方法，除非有socket返回，读写不能同时进行<br>当对Socket的输入流进行读取操作的时候，它会一直阻塞下去。<br>一个场景，由于网络延迟，导致数据发送缓慢。而由于使用的是阻塞IO，那么read方法一直处于阻塞状态，要等到数据传送完成才结束（返回-1）。那么这种场景下，在高并发。直接导致线程暴增、服务器宕机。<br><img src="https://img-blog.csdnimg.cn/20190604092946420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>在bio基础上，把传统多线程改为使用一定muxnum的线程池，形成伪异步IO模型，<br>实现一个或多个线程处理n个客户端，但是底层还是同步阻塞IO</strong></p><p><img src="https://img-blog.csdnimg.cn/20190604093325953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程池 懒汉式的单例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">60</span>);</span><br></pre></td></tr></table></figure><p>CachedThreadPool线程池</p><p><strong>根本上无法解决高并发：因为限制了线程数量，如果发生大量并发请求，超过最大数量的线程就只能等待，直到线程池中的有空闲的线程可以被复用。</strong></p><h3 id="bio问题："><a href="#bio问题：" class="headerlink" title="bio问题："></a>bio问题：</h3><ul><li>1.没有一个socket，服务端都会开启一个线程处理</li><li>2.每一个处理操作完后，线程都会被销毁</li></ul><h2 id="NIO（new-io，Non-blocking-io）"><a href="#NIO（new-io，Non-blocking-io）" class="headerlink" title="NIO（new io，Non-blocking io）"></a>NIO（new io，Non-blocking io）</h2><p>netty框架中实现了NIO的封装</p><p>同步非阻塞IO</p><h3 id="缓冲区（Buffer）：存储写入或者读出的数据"><a href="#缓冲区（Buffer）：存储写入或者读出的数据" class="headerlink" title="缓冲区（Buffer）：存储写入或者读出的数据"></a><strong>缓冲区（Buffer）：存储写入或者读出的数据</strong></h3><p>  官方写到：<br>a Thread can ask channel to read data into a buffer ,While the channel reads data into buffer,the Thread can do else things.<br>所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的；在写入数据时，也是写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。</p><h3 id="通道（Channel）：同时读写-双向的"><a href="#通道（Channel）：同时读写-双向的" class="headerlink" title="通道（Channel）：同时读写 双向的"></a><strong>通道（Channel）：同时读写 双向的</strong></h3><p>  Channel主要分两大类：</p><pre><code>- SelectableChannel：用户网络读写- FileChannel：用于文件操作- ServerSocketChannel服务器tcp数据传输- SocketChannel客户端tcp数据传输</code></pre><h3 id="多路复用器（Selector）：提供选择已经就绪的任务的能力"><a href="#多路复用器（Selector）：提供选择已经就绪的任务的能力" class="headerlink" title="多路复用器（Selector）：提供选择已经就绪的任务的能力"></a><strong>多路复用器（Selector）：提供选择已经就绪的任务的能力</strong></h3><p>  官方写道：<br>A selector can use a thread to monitor multiple channels for even’s.<br>Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的I/O操作。</p><h3 id="服务端："><a href="#服务端：" class="headerlink" title="服务端："></a><strong>服务端：</strong></h3><ul><li>1.打开ServerSocketChannel</li><li>2.设置为非阻塞</li><li>3.监听客户端端口，绑定监听端口</li><li>4.创建selector 把channel注册到selector上，监听我感兴趣的accept请求</li><li>5.开始listen：<br>   （1）轮询selector访问准备就绪的SelectionKey</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">//selector轮询准备就绪的key</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">                SelectionKey selectionKey = iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                handlekey(selectionKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><pre><code>（2）监听到新的客户端接入，处理新的接入请求，将读写数据放在Buffer中</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(selectionKey.isAcceptable())&#123;</span><br><span class="line">            serverSocketChannel = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">            client = serverSocketChannel.accept();</span><br><span class="line">            client.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            client.register(selector,SelectionKey.OP_READ);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(selectionKey.isReadable())&#123;</span><br><span class="line">            client = (SocketChannel) selectionKey.channel();</span><br><span class="line">            receiveBuffer.clear();</span><br><span class="line">            -------------------------</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(selectionKey.isWritable())&#123;</span><br><span class="line">            sendBuffer.clear();</span><br><span class="line">            <span class="comment">//服务端向客户端发送数据</span></span><br><span class="line">            client = (SocketChannel) selectionKey.channel();</span><br><span class="line">            sendText = <span class="string">"message from server:"</span>+flag++;</span><br><span class="line">            sendBuffer.put(sendText.getBytes());</span><br><span class="line">            sendBuffer.flip();</span><br><span class="line">            client.write(sendBuffer)；</span><br><span class="line">            client.register(selector,SelectionKey.OP_READ);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="客户端："><a href="#客户端：" class="headerlink" title="客户端："></a><strong>客户端：</strong></h3><ul><li>1.打开socket通道</li><li>2.设置非阻塞</li><li>3.创建选择器selector 注册通道 SelectionKey.connect</li><li>4.socket连接服务器ip和端口</li><li>5.轮询selector已就绪的通道</li><li>6.处理通道请求的数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            selectionKeys = selector.selectedKeys();</span><br><span class="line">            iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                selectionKey = iterator.next();</span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isConnectable()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"client connect"</span>);</span><br><span class="line">                    client = (SocketChannel) selectionKey.channel();</span><br><span class="line">                    <span class="comment">// 判断此通道上是否正在进行连接操作。</span></span><br><span class="line">                    <span class="comment">// 完成套接字通道的连接过程。</span></span><br><span class="line">                    <span class="keyword">if</span> (client.isConnectionPending()) &#123;</span><br><span class="line">                        client.finishConnect();</span><br><span class="line">                        System.out.println(<span class="string">"完成连接!"</span>);</span><br><span class="line">                        sendBuffer.clear();</span><br><span class="line">                        sendBuffer.put(<span class="string">"Hello,Server"</span>.getBytes());</span><br><span class="line">                        sendBuffer.flip();</span><br><span class="line">                        client.write(sendBuffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                    client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">                    client = (SocketChannel) selectionKey.channel();</span><br><span class="line">                    <span class="comment">//将缓冲区清空以备下次读取</span></span><br><span class="line">                    receiveBuffer.clear();</span><br><span class="line">                    <span class="comment">//读取服务器发送来的数据到缓冲区中</span></span><br><span class="line">                    count = client.read(receiveBuffer);</span><br><span class="line">                    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        receiveText = <span class="keyword">new</span> String(receiveBuffer.array(), <span class="number">0</span>, count);</span><br><span class="line">                        System.out.println(<span class="string">"客户端接受服务器端数据--:"</span> + receiveText);</span><br><span class="line">                        client.register(selector, SelectionKey.OP_WRITE);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isWritable()) &#123;</span><br><span class="line">                    sendBuffer.clear();</span><br><span class="line">                    client = (SocketChannel) selectionKey.channel();</span><br><span class="line">                    sendText = <span class="string">"message from client--"</span> + (flag++);</span><br><span class="line">                    sendBuffer.put(sendText.getBytes());</span><br><span class="line">                    <span class="comment">//将缓冲区各标志复位,因为向里面put了数据标志被改变要想从中读取数据发向服务器,就要复位</span></span><br><span class="line">                    sendBuffer.flip();</span><br><span class="line">                    client.write(sendBuffer);</span><br><span class="line">                    System.out.println(<span class="string">"客户端向服务器端发送数据--："</span> + sendText);</span><br><span class="line">                    client.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            selectionKeys.clear();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190604203114930.png" alt="在这里插入图片描述"></p><h2 id="AIO、BIO、NIO理解"><a href="#AIO、BIO、NIO理解" class="headerlink" title="AIO、BIO、NIO理解"></a>AIO、BIO、NIO理解</h2><ul><li><p>AIO的做法是，每个水壶上装一个开关，当水开了以后会提醒对应的线程去处理。</p></li><li><p>NIO的做法是，叫一个线程不停的循环观察每一个水壶，根据每个水壶当前的状态去处理。</p></li><li><p>BIO的做法是，叫一个线程停留在一个水壶那，直到这个水壶烧开，才去处理下一个水壶。</p></li></ul>]]></content>
    
    <summary type="html">
    
      NIO/IO/New IO/非阻塞IO
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="网络编程" scheme="https://www.dzou.top/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="IO" scheme="https://www.dzou.top/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Shiro Java安全框架 （认证、授权）--更新中</title>
    <link href="https://www.dzou.top/post/712f837.html"/>
    <id>https://www.dzou.top/post/712f837.html</id>
    <published>2019-07-24T01:55:55.000Z</published>
    <updated>2019-08-02T11:52:20.304Z</updated>
    
    <content type="html"><![CDATA[<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><p>权限管理实现对用户访问系统的控制，按照安全规则或者安全策略控制用户可以访问而且只能访问自己被授权的资源。<br><img src="https://img-blog.csdnimg.cn/20190607230804827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>用户认证</li><li>用户授权</li></ul><p>Authentication：身份认证 / 登录，验证用户是不是拥有相应的身份；</p><p>Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；</p><hr><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><h3 id="用户认证的流程"><a href="#用户认证的流程" class="headerlink" title="用户认证的流程"></a>用户认证的流程</h3><ul><li>判断该资源能否不认证就能访问</li><li>如果该资源需要认证才能访问，那判断该访问者是否认证</li><li>如果还没有认证，那么需要进行认证</li><li>认证通过后才能访问资源</li></ul><p>调用流程：</p><ul><li><p>首先通过 new IniSecurityManagerFactory 并指定一个 ini 配置文件来创建一个 SecurityManager 工厂；</p></li><li><p>接着获取 SecurityManager 并绑定到 SecurityUtils，这是一个全局设置，设置一次即可；</p></li><li><p>通过 SecurityUtils 得到 Subject，其会自动绑定到当前线程；如果在 web 环境在请求结束时需要解除绑定；然后获取身份验证的 Token，如用户名 / 密码；</p></li><li><p>调用 subject.login 方法进行登录，其会自动委托给 SecurityManager.login 方法进行登录；</p></li><li><p>如果身份验证失败请捕获 AuthenticationException 或其子类，常见的如： </p><ul><li>DisabledAccountException（禁用的帐号）、</li><li>LockedAccountException（锁定的帐号）、</li><li>UnknownAccountException（错误的帐号）、</li><li>ExcessiveAttemptsException（登录失败次数过多）、</li><li>IncorrectCredentialsException （错误的凭证）、</li><li>ExpiredCredentialsException（过期的凭证）等<br>具体请查看其继承关系；对于页面的错误消息展示，最好使用如 “用户名 / 密码错误” 而不是 “用户名错误”/“密码错误”，防止一些恶意用户非法扫描帐号库；</li></ul></li><li><p>最后可以调用 subject.logout 退出，其会自动委托给 SecurityManager.logout 方法退出。</p></li></ul><hr><h3 id="SecurityUtils-getSubject"><a href="#SecurityUtils-getSubject" class="headerlink" title="SecurityUtils.getSubject()"></a><strong>SecurityUtils.getSubject()</strong></h3><p>SecurityUtils.getSubject()是每个请求创建一个Subject, 并保存到ThreadContext的resources（ThreadLocal&lt;Map&lt;Object, Object&gt;&gt;）变量中，也就是一个http请求一个subject,并绑定到当前线程。</p><p><img src="https://easydoc-1255322048.image.myqcloud.com/cover/jwymt1ro" alt="image.png"></p><h4 id="controller接受请求后"><a href="#controller接受请求后" class="headerlink" title="controller接受请求后"></a>controller接受请求后</h4><p><img src="https://easydoc-1255322048.image.myqcloud.com/cover/jwyp9q88" alt="image.png"></p><h3 id="URL拦截"><a href="#URL拦截" class="headerlink" title="URL拦截"></a>URL拦截</h3><p><img src="https://easydoc-1255322048.image.myqcloud.com/cover/jwyn6ggs" alt="image.png"></p><h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>用户授权的流程</p><ul><li>到达了用户授权环节，需要用户认证之后</li><li>用户访问资源，系统判断该用户是否有权限去操作该资源</li><li>如果该用户有权限才能够访问，如果没有权限就不能访问了<br><img src="https://easydoc-1255322048.image.myqcloud.com/cover/jwymojcq" alt="image.png"></li></ul><h3 id="获取角色和权限"><a href="#获取角色和权限" class="headerlink" title="获取角色和权限"></a>获取角色和权限</h3><p>一个角色role对应多个权限，一个用户user对应多个角色<br>我们通过getSysUserRoleList和getPermissions分别获取角色列表和用户权限。</p><p>然后通过<br><code>user.hasRole(&quot;&quot;)或者role.hasPermission(&quot;&quot;)</code><br>检查用户是否有对某个操作的权限</p><h3 id="密码加密和匹配"><a href="#密码加密和匹配" class="headerlink" title="密码加密和匹配"></a>密码加密和匹配</h3><p><img src="https://easydoc-1255322048.image.myqcloud.com/cover/jwyq0gjy" alt="image.png"></p><ul><li><strong>Subject</strong>：</li></ul><p><strong>主体，代表了当前 “用户”</strong><br>这个用户不一定是一个具体的人，与当前应用交互的任何东西都是 Subject，如网络爬虫，机器人等；即一个抽象概念；所有 Subject 都绑定到 SecurityManager，与 Subject 的所有交互都会委托给 SecurityManager；可以把 Subject 认为是一个门面；SecurityManager 才是实际的执行者；</p><ul><li><strong>SecurityManager</strong>：</li></ul><p><strong>安全管理器</strong><br>即所有与安全有关的操作都会与 SecurityManager 交互；且它管理着所有 Subject；可以看出它是 Shiro 的核心，它负责与后边介绍的其他组件进行交互，如果学习过 SpringMVC，你可以把它看成 DispatcherServlet 前端控制器；</p><ul><li><strong>Realm</strong>：</li></ul><p><strong>域，Shiro 从从 Realm 获取安全数据（如用户、角色、权限）</strong><br>就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色 / 权限进行验证用户是否能进行操作；可以把 Realm 看成 DataSource，即安全数据源。</p><hr><h3 id="1-ShiroConfig配置类"><a href="#1-ShiroConfig配置类" class="headerlink" title="1.ShiroConfig配置类"></a><strong>1.ShiroConfig配置类</strong></h3><p>添加@Configuration和@Bean</p><ul><li>（1）创建ShiroFilterFactoryBean<ul><li>1.设置安全管理器SecurityManager </li><li>2.创建Shiro内置过滤器，实现相关url拦截，使用LinkedHashMap添加 </li><li>3.设置调整页面 </li><li>4.设置过滤器</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * anon:所有url都都可以匿名访问</span></span><br><span class="line"><span class="comment">         * authc: 需要认证才能进行访问</span></span><br><span class="line"><span class="comment">         * user: 如果使用 rememberme 可以直接访问</span></span><br><span class="line"><span class="comment">         * perms：该资源必须得到资源权限才可以访问</span></span><br><span class="line"><span class="comment">         * role：该资源必须得到角色权限才可以访问</span></span><br><span class="line"><span class="comment">         */</span></span><br></pre></td></tr></table></figure><ul><li>（2）创建DefaultWebSecurityManager（主要关联自定义realm）</li><li>（3）创建自定义Realm</li><li>（4 可选）配置ShiroDialect,配合thymeleaf使用</li></ul><h3 id="2-自定义Realm类"><a href="#2-自定义Realm类" class="headerlink" title="2.自定义Realm类"></a><strong>2.自定义Realm类</strong></h3><ul><li><p>（1）可实现自定义的Credentials匹配类（实现自定义密码验证，通过添加到PostContruct作为类初始化执行）</p></li><li><p>（2）实现用户授权添加过程</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> AuthorizationInfo doGetAuthorizationInfo</span><br></pre></td></tr></table></figure></li><li><p>（3）实现用户认证过程</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> AuthenticationInfo doGetAuthenticationInfo</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="自定义密码验证和加密（双MD5加盐salt-随机数）"><a href="#自定义密码验证和加密（双MD5加盐salt-随机数）" class="headerlink" title="自定义密码验证和加密（双MD5加盐salt 随机数）"></a><strong>自定义密码验证和加密（双MD5加盐salt 随机数）</strong></h4><p>Realm在验证用户身份的时候，要进行密码匹配。最简单的情况就是明文直接匹配，然后就是加密匹配，这里的匹配工作则就是交给CredentialsMatcher来完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CredentialsMatcher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">doCredentialsMatch</span><span class="params">(AuthenticationToken token, AuthenticationInfo info)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在涉及到密码存储问题上，应该加密 / 生成密码摘要存储，而不是存储明文密码。比如之前的 600w csdn 账号泄露对用户可能造成很大损失，因此应加密 / 生成不可逆的摘要方式存储。<br><strong>这时就需要自定义一个CustomCredentialsMatcher 继承SimpleCredentialsMatcher 实现密码验证</strong></p><hr><h2 id="RememberMe"><a href="#RememberMe" class="headerlink" title="RememberMe"></a>RememberMe</h2><ul><li>cookie</li><li>rememberMeCookieManager</li></ul><h3 id="配置RememberMeManager"><a href="#配置RememberMeManager" class="headerlink" title="配置RememberMeManager"></a>配置RememberMeManager</h3><p><img src="https://easydoc-1255322048.image.myqcloud.com/cover/jwyqazu7" alt="image.png"></p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul><li><p><strong>使用缓存存储session（单服务器使用EhCacheManager）</strong></p></li><li><p><strong>但是在分布式系统中，服务器集群情况下，EhCacheManager无法解决数据共享（会多次查询数据库），则选择使用redis作为缓存</strong></p></li></ul><h3 id="Redis实现shiro缓存"><a href="#Redis实现shiro缓存" class="headerlink" title="Redis实现shiro缓存"></a>Redis实现shiro缓存</h3><ul><li><p><strong>分布式共享session和授权信息需要把session和授权持久化到数据库或者缓存 shiro集群为了防止多次插查询数据库</strong></p></li><li><p><strong>自定义实现类:或者使用crazycake开源shiro-redis实现好的工具</strong></p><ul><li><strong><em>RedisSessionDAO</em></strong>  可以继承EnterpriseCacheSessionDAO实现session控制</li><li><strong><em>RedisCache</em></strong>  继承Cache类实现具体redis操作缓存（remove、get、set、keys</li><li><strong><em>RedisCacheManager</em></strong> 实现接口CacheManager的getCache获得RedisCache交给securityManager管理</li></ul><p> <strong>使用了ConcurrentMap管理数据和缓存，更加高效</strong></p></li></ul><h3 id="缓存session和授权信息"><a href="#缓存session和授权信息" class="headerlink" title="缓存session和授权信息"></a>缓存session和授权信息</h3><h4 id="１．基于EhCache缓存（效率不高，无法解决分布式问题）"><a href="#１．基于EhCache缓存（效率不高，无法解决分布式问题）" class="headerlink" title="１．基于EhCache缓存（效率不高，无法解决分布式问题）"></a>１．基于EhCache缓存（效率不高，无法解决分布式问题）</h4><p><img src="https://easydoc-1255322048.image.myqcloud.com/cover/jwyrqhze" alt="image.png"></p><h4 id="２．基于Redis缓存-CrazyCake-shiro-redis开源插件，效率高，可实现集群共享）"><a href="#２．基于Redis缓存-CrazyCake-shiro-redis开源插件，效率高，可实现集群共享）" class="headerlink" title="２．基于Redis缓存(CrazyCake　shiro-redis开源插件，效率高，可实现集群共享）"></a>２．基于Redis缓存(CrazyCake　shiro-redis开源插件，效率高，可实现集群共享）</h4><p>RedisConfig加载配置类<br><img src="https://easydoc-1255322048.image.myqcloud.com/cover/jwyrlnmn" alt="image.png"><br>sessionManager管理session<br><img src="https://easydoc-1255322048.image.myqcloud.com/cover/jwyqgt4c" alt="image.png"><br>创建cookie集群共享sessionid<br><img src="https://easydoc-1255322048.image.myqcloud.com/cover/jwyqib1o" alt="image.png"></p><h2 id="Shiro配置类"><a href="#Shiro配置类" class="headerlink" title="Shiro配置类"></a>Shiro配置类</h2><h3 id="ShiroFilterFactoryBean"><a href="#ShiroFilterFactoryBean" class="headerlink" title="ShiroFilterFactoryBean"></a>ShiroFilterFactoryBean</h3><p>一个工厂Bean，将ShiroFilter实例对象注入到Spring容器中去，这样Shiro基于url的方式进行请求过滤处理，把安全管理器添加到该bean中。</p><h3 id="SecurityManager-管理认证和授权"><a href="#SecurityManager-管理认证和授权" class="headerlink" title="SecurityManager 管理认证和授权"></a>SecurityManager 管理认证和授权</h3><h4 id="1-SessionManager-（管理session"><a href="#1-SessionManager-（管理session" class="headerlink" title="1.SessionManager　（管理session)"></a>1.SessionManager　（管理session)</h4><h5 id="（1）SessionDao-（自定义或者crazycake）"><a href="#（1）SessionDao-（自定义或者crazycake）" class="headerlink" title="（1）SessionDao （自定义或者crazycake）"></a>（1）SessionDao （自定义或者crazycake）</h5><h5 id="（2）cookie-（存放JESSIONID）"><a href="#（2）cookie-（存放JESSIONID）" class="headerlink" title="（2）cookie　（存放JESSIONID）"></a>（2）cookie　（存放JESSIONID）</h5><h5 id="（3）redisManager-（管理redis）"><a href="#（3）redisManager-（管理redis）" class="headerlink" title="（3）redisManager　（管理redis）"></a>（3）redisManager　（管理redis）</h5><h4 id="2-CacheManager-保存用户信息和授权信息"><a href="#2-CacheManager-保存用户信息和授权信息" class="headerlink" title="2.CacheManager　保存用户信息和授权信息"></a>2.CacheManager　保存用户信息和授权信息</h4><h5 id="方式一：EhCache实现缓存管理器-编写自定义缓存方式配置文件shiro-ehcache-xml"><a href="#方式一：EhCache实现缓存管理器-编写自定义缓存方式配置文件shiro-ehcache-xml" class="headerlink" title="方式一：EhCache实现缓存管理器,编写自定义缓存方式配置文件shiro-ehcache.xml"></a>方式一：EhCache实现缓存管理器,编写自定义缓存方式配置文件shiro-ehcache.xml</h5><h5 id="方式二：redis-做缓存"><a href="#方式二：redis-做缓存" class="headerlink" title="方式二：redis 做缓存"></a>方式二：redis 做缓存</h5><h5 id="3-RememberMeManager"><a href="#3-RememberMeManager" class="headerlink" title="3.RememberMeManager"></a>3.RememberMeManager</h5><p>添加SimpleCookie作为RememberMeCookie</p><h4 id="4-MyShiroRealm（自定义认证授权实现Realm类）"><a href="#4-MyShiroRealm（自定义认证授权实现Realm类）" class="headerlink" title="4.MyShiroRealm（自定义认证授权实现Realm类）"></a>4.MyShiroRealm（自定义认证授权实现Realm类）</h4><ul><li>doGetAuthorizationInfo　授权</li><li>doGetAuthenticationInfo　认证</li><li>credentialsMatcher　配置凭证匹配器，双md5加盐加密</li></ul>]]></content>
    
    <summary type="html">
    
      Shiro JavaWeb 安全框架，实现权限管理和用户认证
    
    </summary>
    
      <category term="Web安全" scheme="https://www.dzou.top/categories/Web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="安全" scheme="https://www.dzou.top/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="记住我" scheme="https://www.dzou.top/tags/%E8%AE%B0%E4%BD%8F%E6%88%91/"/>
    
      <category term="单点登录" scheme="https://www.dzou.top/tags/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    
      <category term="Redis" scheme="https://www.dzou.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式--单例模式(7种)</title>
    <link href="https://www.dzou.top/post/f90c55c.html"/>
    <id>https://www.dzou.top/post/f90c55c.html</id>
    <published>2019-07-24T01:50:57.000Z</published>
    <updated>2019-08-02T11:48:53.574Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式（七种）"><a href="#单例模式（七种）" class="headerlink" title="单例模式（七种）"></a>单例模式（七种）</h2><h3 id="1-饿汉模式"><a href="#1-饿汉模式" class="headerlink" title="1. 饿汉模式"></a><strong>1. 饿汉模式</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">return</span> instance;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这种方式在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快。 这种方式基于类加载机制避免了多线程的同步问题，但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到懒加载的效果。</p><hr><h3 id="2-懒汉模式（线程不安全）"><a href="#2-懒汉模式（线程不安全）" class="headerlink" title="2. 懒汉模式（线程不安全）"></a><strong>2. 懒汉模式（线程不安全）</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line">      &#125;   </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">          instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">return</span> instance;  </span><br><span class="line">      &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>懒汉模式申明了一个静态对象，在用户第一次调用时初始化，虽然节约了资源，但第一次加载时需要实例化，反映稍慢一些，而且在多线程不能正常工作。</p><hr><h3 id="3-懒汉模式（线程安全）"><a href="#3-懒汉模式（线程安全）" class="headerlink" title="3. 懒汉模式（线程安全）"></a><strong>3. 懒汉模式（线程安全）</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">          instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">return</span> instance;  </span><br><span class="line">      &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这种写法能够在多线程中很好的工作，但是每次调用getInstance方法时都需要进行同步，造成不必要的同步开销，而且大部分时候我们是用不到同步的，所以不建议用这种模式。</p><hr><h3 id="4-双重检查模式-（DCL）"><a href="#4-双重检查模式-（DCL）" class="headerlink" title="4. 双重检查模式 （DCL）"></a><strong>4. 双重检查模式 （DCL）</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line">      &#125;   </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">if</span> (instance== <span class="keyword">null</span>) &#123;  </span><br><span class="line">          <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">          <span class="keyword">if</span> (instance== <span class="keyword">null</span>) &#123;  </span><br><span class="line">              instance= <span class="keyword">new</span> Singleton();  </span><br><span class="line">          &#125;  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> singleton;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这种写法在getSingleton方法中对singleton进行了两次判空，第一次是为了不必要的同步，第二次是在singleton等于null的情况下才创建实例。在这里用到了volatile关键字这里使用volatile会或多或少的影响性能，<br>但考虑到程序的正确性，牺牲这点性能还是值得的。 DCL优点是资源利用率高，第一次执行getInstance时单例对象才被实例化，效率高。缺点是第一次加载时反应稍慢一些，在高并发环境下也有一定的缺陷，虽然发生的概率很小。DCL虽然在一定程度解决了资源的消耗和多余的同步，线程安全等问题，但是他还是在某些情况会出现失效的问题，也就是DCL失效，在《java并发编程实践》一书建议用静态内部类单例模式来替代DCL。</p><hr><h3 id="5-静态内部类单例模式"><a href="#5-静态内部类单例模式" class="headerlink" title="5. 静态内部类单例模式"></a><strong>5. 静态内部类单例模式</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.sInstance;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton sInstance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次加载Singleton类时并不会初始化sInstance，只有第一次调用getInstance方法时虚拟机加载SingletonHolder 并初始化sInstance ，这样不仅能确保线程安全也能保证Singleton类的唯一性，所以推荐使用静态内部类单例模式。</p><hr><h3 id="6-枚举单例"><a href="#6-枚举单例" class="headerlink" title="6. 枚举单例"></a><strong>6. 枚举单例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;  </span><br><span class="line">     INSTANCE;  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>枚举单例的优点就是简单，但是大部分应用开发很少用枚举，可读性并不是很高，不建议用。</p><hr><p>述讲的几种单例模式实现中，有一种情况下他们会重新创建对象，那就是反序列化，将一个单例实例对象写到磁盘再读回来，从而获得了一个实例。反序列化操作提供了readResolve方法，这个方法可以让开发人员控制对象的反序列化。在上述的几个方法示例中如果要杜绝单例对象被反序列化是重新生成对象，就必须加入如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</span><br><span class="line"><span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-使用容器实现单例模式"><a href="#7-使用容器实现单例模式" class="headerlink" title="7.使用容器实现单例模式"></a><strong>7.使用容器实现单例模式</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonManager</span> </span>&#123; </span><br><span class="line">　　<span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; objMap = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">　　<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; </span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String key, Objectinstance)</span> </span>&#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (!objMap.containsKey(key) ) &#123;</span><br><span class="line">　　　　　　objMap.put(key, instance) ;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">ObjectgetService</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">　　　　<span class="keyword">return</span> objMap.get(key) ;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用SingletonManager 将多种的单例类统一管理，在使用时根据key获取对象对应类型的对象。这种方式使得我们可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合度。</p>]]></content>
    
    <summary type="html">
    
      单例模式
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="单例模式" scheme="https://www.dzou.top/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记--更新中</title>
    <link href="https://www.dzou.top/post/cfc248db.html"/>
    <id>https://www.dzou.top/post/cfc248db.html</id>
    <published>2019-07-24T01:45:28.000Z</published>
    <updated>2019-08-02T11:53:39.829Z</updated>
    
    <content type="html"><![CDATA[<p>##SpringBoot<br>Spring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>无需配置xml，无代码生成</li><li>无需打包war，而是jar</li></ul><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p>一组小型服务，通过http进行沟通<br>每个单元度</p><h3 id="单体应用"><a href="#单体应用" class="headerlink" title="单体应用"></a>单体应用</h3><p>传统web应用,所有功能和模块全部部署在一个应用里</p><h3 id="jar包运行"><a href="#jar包运行" class="headerlink" title="jar包运行"></a>jar包运行</h3><p>Spring-boot-maven-plugin可以用maven把springboot应用打jar</p><h3 id="pom文件探究"><a href="#pom文件探究" class="headerlink" title="pom文件探究"></a>pom文件探究</h3><ul><li><p>springboot-starter-dependencies：版本仲裁中心，以后导入依赖不需要写版本，在父pom中声明</p></li><li><p>springboot-starter-web：场景启动器 帮我们导入运行需要的组件：tomcat springweb、webmvc</p></li></ul><h3 id="主程序类"><a href="#主程序类" class="headerlink" title="主程序类"></a>主程序类</h3><ul><li>@SprignbootAppliction 标志类（Springboot主配置类）</li><li>@SpringbootConfiguration 类（Springboot一个配置类） 底层使用Configuration实现</li><li>@EnableAutoConfiguration 类（开启自动配置） springboot帮我们自动配置    </li><li>@AutoConfigurationPackage自动配置包（主配置类所在包下类扫描）</li></ul><blockquote><p>@EnableAutoConfiguration(exclude = {DataSourceAutoConfiguration.class})<br>@Configuration<br>@ComponentScan<br>这三个等同于@SpringBootApplication</p></blockquote><blockquote><p>@RestController等同于 @ResponseBody和@Controller</p></blockquote><p>自动配置很强大<br>springboot下autoconfiguration包内存储我们需要的类，sringboot帮我们配置</p><h3 id="创建SpringBoot项目"><a href="#创建SpringBoot项目" class="headerlink" title="创建SpringBoot项目"></a>创建SpringBoot项目</h3><p>Spring Initialize可以帮助我们创建SpringBoot项目</p><h3 id="Springboot配置文件"><a href="#Springboot配置文件" class="headerlink" title="Springboot配置文件"></a>Springboot配置文件</h3><h4 id="全局配置文件"><a href="#全局配置文件" class="headerlink" title="全局配置文件"></a>全局配置文件</h4><p>命名固定</p><ul><li>application.properties</li><li>application.yml<br>yaml： 以数据为中心，比xml和json更适合</li></ul><h4 id="配置文件注入值"><a href="#配置文件注入值" class="headerlink" title="配置文件注入值"></a>配置文件注入值</h4><ul><li>1.@ConfigurationProperties（prefix=“”）支持jsr303数据校验</li><li>2.属性上添加 @Value（￥{user.username}）复杂类型不能封装，只能使用基本数据类型</li></ul><h4 id="PropertySource使用路径下的配置文件"><a href="#PropertySource使用路径下的配置文件" class="headerlink" title="@PropertySource使用路径下的配置文件"></a>@PropertySource使用路径下的配置文件</h4><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource</span>(value = <span class="string">"&#123;classpath:user.properties&#125;"</span>)</span><br></pre></td></tr></table></figure><h4 id="加入我们编写的配置文件"><a href="#加入我们编写的配置文件" class="headerlink" title="加入我们编写的配置文件"></a>加入我们编写的配置文件</h4><p>1.@ImportResource 标注在配置类上（不推荐）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportResource</span>(value = &#123;<span class="string">"classpath:bean.xml"</span>&#125;)</span><br></pre></td></tr></table></figure><p>2.推荐使用注解给容器中添加组件（编写配置类）<br>@Bean 标注方法上 返回值为该组件 方法名为该组件id</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#YAML格式</span></span><br><span class="line"><span class="attr">environments:</span></span><br><span class="line"><span class="attr">    dev:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">http://dev.bar.com</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">Developer</span> <span class="string">Setup</span></span><br><span class="line"><span class="attr">    prod:</span></span><br><span class="line"><span class="attr">        url:</span> <span class="attr">http://foo.bar.com</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">My</span> <span class="string">Cool</span> <span class="string">App</span></span><br><span class="line"><span class="attr">my:</span></span><br><span class="line"><span class="attr">    servers:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">dev.bar.com</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">foo.bar.com</span></span><br></pre></td></tr></table></figure><blockquote><p>处理器：写配置文件有提示<br>我们可以添加下面依赖</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="SpringBoot占位符"><a href="#SpringBoot占位符" class="headerlink" title="SpringBoot占位符"></a>SpringBoot占位符</h3><ul><li>随机数：可以在配置文件中使用#{random.uuif}等</li><li>占位符获取之前设置的值，如果没有，可以使用默认值#{userAge：默认值}</li></ul><h3 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h3><p><strong>Spring对不同环境提供不同的配置功能的支持（发布、生产、测试等环境）</strong><br>例：</p><ul><li>application_dev.yml</li><li>application_prod.yml</li></ul><p>yml、properties<br>可以使用spring.profiles.active=dev,prod也可以在命令行使用–spring.profiles.active=dev,prod参数</p><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>springboot能自动适应所有的日志框架 底层使用slf4j和logback</p><p><img src="https://img-blog.csdnimg.cn/2019060510505348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h4><p>springboot默认级别是info级别（只输出info和以后级别）</p><ul><li>trace</li><li>debug</li><li>info</li><li>warn</li><li>error</li></ul><h4 id="调整级别"><a href="#调整级别" class="headerlink" title="调整级别"></a>调整级别</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#com.dingxiang下的日志都以trace级别输出</span></span><br><span class="line"><span class="string">logging.level.com.dingxiang=trace</span></span><br></pre></td></tr></table></figure><p>springboot指定路径生成日志文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logging.path=/spring/log</span><br><span class="line">logging.file=springboot_logging</span><br></pre></td></tr></table></figure><blockquote><p>设置自定义日志格式 logging.pattern.console</p></blockquote><h4 id="日志指定配置"><a href="#日志指定配置" class="headerlink" title="日志指定配置"></a>日志指定配置</h4><p>在指定路径下放置对应的日志文件 ex：在根目录下放置logback.xml<br>logback-spring.xm可以使用springboot的高级功能可以设置多profile环境配置</p><h4 id="切换日志框架"><a href="#切换日志框架" class="headerlink" title="切换日志框架"></a>切换日志框架</h4><p>所有的日志都统一到slf4j的解决方案： </p><ol><li>将系统中其他日志框架先排除出去； </li><li>用中间包来替换原有的日志框架； </li><li>导入slf4j其他的实现。</li></ol><h2 id="SpringBoot-Web-开发"><a href="#SpringBoot-Web-开发" class="headerlink" title="SpringBoot Web 开发"></a>SpringBoot Web 开发</h2><h3 id="pom资源引入：webjars"><a href="#pom资源引入：webjars" class="headerlink" title="pom资源引入：webjars"></a>pom资源引入：webjars</h3><p><a href="https://www.webjars.org/" rel="external nofollow noopener noreferrer" target="_blank"><br>webjars maven</a></p><h4 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h4><p>默认情况下，Spring Boot 将在 classpath 或者 ServletContext 根目录下从名为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/static </span><br><span class="line">/public</span><br><span class="line">/resources </span><br><span class="line">/META-INF/resources</span><br></pre></td></tr></table></figure><p>目录中服务静态内容。它使用了 Spring MVC 的 ResourceHttpRequestHandler</p><h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><blockquote><p>模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。</p></blockquote><p>springboot 使用的thymeleaf<br>放在classpath：src/main/resources/templates</p><p><img src="https://img-blog.csdnimg.cn/20190605170117401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>(1)th任意html元素<br>th:text 文本  th:class th:id<br>(2)方法调用<br>语法案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>成功<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:text</span>=<span class="string">"$&#123;hello&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="扩展SpringMVC"><a href="#扩展SpringMVC" class="headerlink" title="扩展SpringMVC"></a>扩展SpringMVC</h3><p>编写配置类继承WebMvcConfigurerAdapter 实现对应的方法<br>使得springboot既可以使用自动配置，也可以使用我们的扩展配置</p><p>eg 扩展controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        super.addViewControllers(registry);</span></span><br><span class="line">registry.addViewController(<span class="string">"/"</span>).setViewName(<span class="string">"success"</span>);</span><br></pre></td></tr></table></figure><h2 id="Springboot-整合Mybatis"><a href="#Springboot-整合Mybatis" class="headerlink" title="Springboot 整合Mybatis"></a>Springboot 整合Mybatis</h2><h3 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 最重要的是这个POM配置，MyBatis相关操作都在这个包中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- MySql数据库连接包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>(1)application.yml或者properties配置datasource（Springboot自动帮你配置sqlsessionfactory 默认使用的是HikariDataSource）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/springboot?serverTimezone=GMT&amp;autoReconnect=true</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysql</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://localhost:3306/springboot?serverTimezone=GMT&amp;autoReconnect=true</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    password:</span> <span class="number">52</span><span class="string">zoufubo</span></span><br><span class="line"><span class="attr">    driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure><p>（2）配置mybatis扫描包别名和Mapper.xml文件路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mybatis.typeAliasesPackage=com.dingxiang.springboot_web_01.entities</span><br><span class="line">mybatis.mapperLocations=classpath:mapper/*.xml</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line"><span class="attr">  type-aliases-package:</span> <span class="string">com.dingxiang.springboot_web_01.entities</span></span><br><span class="line"><span class="attr">  mapper-locations:</span> <span class="attr">classpath:mapper/*Mapper.xml</span></span><br></pre></td></tr></table></figure><p>（3）在Springboot启动类中添加Mapper接口扫描注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapperScan</span>(basePackages = &#123;<span class="string">"com.dingxiang.springboot_web_01.mapper"</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="一些工具使用"><a href="#一些工具使用" class="headerlink" title="一些工具使用"></a>一些工具使用</h3><p><strong>dto转entity</strong>:使用spring中的BeanUtils</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BeanUtils.copyProperties(userInputDTO,user);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      SpringBoot，Spring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。
    
    </summary>
    
      <category term="Java Web" scheme="https://www.dzou.top/categories/Java-Web/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="分布式" scheme="https://www.dzou.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="SpringBoot" scheme="https://www.dzou.top/tags/SpringBoot/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="后端" scheme="https://www.dzou.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Spring" scheme="https://www.dzou.top/tags/Spring/"/>
    
      <category term="微服务" scheme="https://www.dzou.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>linux学习笔记--更新中 基本知识和常用命令教程 Java程序员必备 较为详细 从基础开始(值得收藏)</title>
    <link href="https://www.dzou.top/post/19e1cc75.html"/>
    <id>https://www.dzou.top/post/19e1cc75.html</id>
    <published>2019-07-24T01:36:09.000Z</published>
    <updated>2019-08-02T11:50:04.535Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux-Ubuntu-deepin"><a href="#Linux-Ubuntu-deepin" class="headerlink" title="Linux(Ubuntu/deepin)"></a>Linux(Ubuntu/deepin)</h2><p>特点：没有磁盘的概念，每个用户只能操作根目录下的一个用户文件夹/home<br>/ 代表根目录<br>.代表当前目录或者隐藏文件文件夹<br>..代表上一级目录<br>*代表任意字符<br>文件名和文件数据分开存储的</p><h2 id="终端命令"><a href="#终端命令" class="headerlink" title="终端命令"></a>终端命令</h2><p><strong>pwd</strong><br>print work directory  输出当前目录</p><p><strong>mkdir</strong><br>make directory 创建文件夹<br>mldir -p a/b/c/d 创建多个文件夹 在a下创建b，b下创建c，c下常见d</p><p><strong>ls</strong><br>列出当前目录下的文件夹和文件<br>-lh 列出文件和文件夹的具体信息<br>-a 包括隐藏文件和文件夹<br>[]包含括号里的项（类似正则表达式）<br>？任意一个字符<br>*任意多个字符</p><p><strong>clear</strong><br>清屏</p><p><strong>cd</strong><br>change directory 变换目录<br>cd .       cd  ..      cd /<br>使用tab自动补全</p><p><strong>touch</strong><br>当前目录下创建文件</p><p><strong>–help</strong><br>命令的相关信息</p><p><strong>rm</strong><br>rm使用须谨慎，删除的东西找不到，不要在根目录里使用rm<br>rm -r 删除文件夹和目录<br>rm 只能删除文件<br>rm -f删除文件夹和目录</p><p><strong>cp</strong><br>cp -r<br>复制文件文件夹</p><p><strong>mv</strong><br>重命名文件文件夹</p><p><strong>grep</strong><br>查找文本中有某单词<br>grep -i忽略大小写<br>grep -n显示匹配行和行号<br>grep -v显示不包含文本的所有行（取反）<br>^匹配文本头<br>￥匹配文本尾</p><p><strong>cat、more</strong><br>显示文本中内容<br>-b空行无序号<br>-n所有行有序号</p><p><strong>ehco</strong><br>在终端显示输入的文本<br>与重定向联合使用（重定向&gt; or &gt;&gt;：把终端的文本追加或输出到文件中）<br>大于&gt; 输出到文本中<br>远大于&gt;&gt;追加到文本中</p><p><strong>|（管道）</strong><br>一个命令的输出通过管道可以通过另一个命令输入<br>ls -lha | more<br>ls -lha | grep 文本</p><p><strong>shutdown</strong><br>关机<br>-c取消</p><h2 id="ssh（windows安装putty或者shellx）"><a href="#ssh（windows安装putty或者shellx）" class="headerlink" title="ssh（windows安装putty或者shellx）"></a>ssh（windows安装putty或者shellx）</h2><p>使用secure shell协议（数据传输是加密的，数据传输是压缩的）连接到远程计算机的软件程序（linux默认安装，win需要手动）<br>ip：找到该计算机<br>端口号：找到计算机（服务器）上运行的应用程序   ip：端口号<br>域名：ip地址别名，方便记忆<br>免密登录：<br>①ssh-keygen 生成ssh密匙<br>②上传公匙到服务器，让服务器记住 ssh-copy-id -p port user@remote<br>id_rsa是私钥，需要放在自己电脑上用来登陆,对数据加密，特别重要！！！<br>id_rsa.pub是公钥，部署在服务器上用来校验<br>非对称加密：<br><img src="https://img-blog.csdnimg.cn/2019050810380247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>配置别名：<br>无需使用ssh -p port user@remote 只需使用ssh name</p><p><strong>ifconfig、ping ip地址</strong><br>ipconfig：查看计算机网卡信息<br>ping IP地址：查看与目标ip是否连接<br>ctrl+c终止终端命令</p><p><strong>scp</strong>（mac、windows使用ftp文件传输FileZilla）<br>在linux下远程拷贝文件<br>-p指定端口<br>scp -P port user/@remote:Desktop/01.txt<br>-r传送文件夹<br>scp -r demo user@remote:Desktop</p><h2 id="用户和权限"><a href="#用户和权限" class="headerlink" title="用户和权限"></a>用户和权限</h2><p><strong>用户管理包括用户和组管理，linux系统中必需拥有一个账号，不同的用户有不同的权限管理文件</strong><br><strong>组：对相同权限的用户放在一个组里</strong><br>r可读，w可写，x可执行<br>文件拥有者、文件的组、其他用户（r–、r-x）</p><p><strong>硬连接数：可通过几种方式访问文件</strong></p><p><strong>chmod</strong><br>chmod +/- rwx 文件名或者文件夹<br>ex：chmod -rw 123.txt 给123.txt减少可读可写权限<br>数字模式：<br>chmod -R 755 文件名或者目录 （三个数字分别对应拥有者、组、其他用户）<br>r-4 w-2 x-1<br><img src="https://img-blog.csdnimg.cn/20190507171143420.png" alt="在这里插入图片描述"></p><p><strong>su、sudo</strong><br>su：substitute user<br>sudo使用超级权限来执行</p><p><strong>组管理</strong><br>groupadd、groupdel、cat/etc/group 确认组信息<br>chgrp -P 组名 文件名或者目录 修改文件或者目录组</p><p><strong>用户（创建用户、设置密码、删除用户）</strong><br>useradd -m -g (m自动创建家目录 -g指定所属组）<br>passwd 设置密码<br>userdel （-f强制 -p）<br>who、whoami（查看哪些用户登录、该用户是谁）</p><p><strong>usermod</strong><br>-p 修改主组<br>-G 修改附加组<br>usermod -s /bin/bash 用户名    修改shell模式</p><p><strong>chown</strong><br>修改拥有者<br>chown 用户名 文件名或者目录</p><p><strong>Bash(GNU Bourne-Again Shell)是许多Linux平台的内定Shell<br>鉴于 bash 过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash (Debian Almquist Shell)，并建议将 /bin/sh 指向它，以获得更快的脚本执行速度。</strong></p><p><strong>/etc/passwd 用户保存用户信息的文件<br>/usr/bin/passwd 修改用户密码的程序</strong></p><p><strong>which：查看命令所在位置</strong></p><p><strong>/bin  二进制可执行文件<br>/sbin  系统管理员专用二进制管理文件<br>/usr/bin 后期安装的一些程序<br>usr/sbin  超级用户的一些管理程序</strong></p><h2 id="与系统有关的终端命令"><a href="#与系统有关的终端命令" class="headerlink" title="与系统有关的终端命令"></a>与系统有关的终端命令</h2><p><strong>date：当前系统时间<br>cal：查看当前月的日历<br>df -h：diskfree 显示磁盘剩余空间<br>du -h目录：diskusage目录占有空间</strong></p><p><strong>进程：当前正在运行的一个程序就一个进程</strong><br> ps aux显示详细进程信息<br> top 动态显示运行中的程序并排序（q退出）<br> kill  [-9] 进程代号  终止指定代号的进程 -9表示强行终止</p><p><strong>查找文件</strong><br> find [路径] -name “*.py” 查找.py结尾的文件 -name后面跟指定条件</p><p><strong>软链接、硬链接</strong><br>软链接：ln -s 被链接的源文件 链接文件 （类似windows下快捷方式，使用绝对路径）<br>硬链接：ln 被链接的源文件 链接文件 （硬链接即是一个文件的另一个文件名，只有硬链接数为0，文件才被删除）</p><p><strong>打包压缩</strong><br>打包：tar -cvf 打包文件名.tar 被打包文件 （被打包文件空格隔开）<br>解包：tar -xvf 打包文件<br>压缩：（1）gzip  （生成.tar.gz结尾文件）-z（2）bzip2（生成tar.bz2结尾文件）-j<br>    tar -zcvf 打包文件名.tar.gz 被压缩文件    tar -jcvf 打包文件名.tar.bz2 被压缩文件<br>解压缩：-C 路径 表示解压缩到指定路径<br>    tar -zxvf 打包文件名.tar.gz                        tar -jxvf 打包文件名.tar.bz2</p><p><strong>安装卸载软件</strong><br>apt（advanced packing tool）在终端中方便的安装/卸载/更新软件包<br>（1）安装： sudo apt install<br>（2）安装： sudo apt remove<br>（3）安装： sudo aptupgrade<br><img src="https://img-blog.csdnimg.cn/20190508103816882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="Vim、Vi"><a href="#Vim、Vi" class="headerlink" title="Vim、Vi"></a>Vim、Vi</h2><p>三个模式：一般模式、命令模式、编辑模式<br>一般模式：只能上下左右移动（按a键进入编辑模式，shift+：进入命令模式）<br>命令模式：保存、退出等命令<br>编辑模式：增删改查（esc退出到一半模式）</p><h2 id="curl、wget下载文件"><a href="#curl、wget下载文件" class="headerlink" title="curl、wget下载文件"></a>curl、wget下载文件</h2><p><strong>curl</strong><br>curl命令是个功能强大的网络工具，支持通过http、ftp等方式下载文件、上传文件。还可以用来抓取网页、网络监控等方面的开发<br>GET请求<br>curl <a href="http://www.baidu.com，回车之后，HTML内容打印在屏幕上；如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地。" rel="external nofollow noopener noreferrer" target="_blank">http://www.baidu.com，回车之后，HTML内容打印在屏幕上；如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地。</a><br>curl -i “<a href="http://www.baidu.com&quot;" rel="external nofollow noopener noreferrer" target="_blank">http://www.baidu.com&quot;</a>  显示全部信息<br>curl -l “<a href="http://www.baidu.com&quot;" rel="external nofollow noopener noreferrer" target="_blank">http://www.baidu.com&quot;</a> 只显示头部信息</p><ul><li>-v/–verbose 小写的v参数，用于打印更多信息，包括发送的请求信息，这在调试脚本是特别有用。</li><li>-m/–max-time <seconds> 指定处理的最大时长</seconds></li><li>-H/–header <header> 指定请求头参数</header></li><li>-s/–slient 减少输出的信息，比如进度</li><li>–connect-timeout <seconds> 指定尝试连接的最大时长</seconds></li><li>-x/–proxy &lt;proxyhost[:port]&gt; 指定代理服务器地址和端口，端口默认为1080</li><li>-T/–upload-file <file> 指定上传文件路径</file></li><li>-o/–output <file> 指定输出文件名称</file></li><li>-d/–data/–data-ascii <data> 指定POST的内容</data></li><li>–retry <num> 指定重试次数</num></li><li>-e/–referer <url> 指定引用地址</url></li><li>-I/–head 仅返回头部信息，使用HEAD请求</li></ul><p><strong>wget</strong><br>用于从网络上下载资源，没有指定目录，下载资源回默认为当前目录</p><p>启动参数：</p><ul><li><p>-V, –version 显示wget的版本后退出</p></li><li><p>-h, –help 打印语法帮助</p></li><li><p>-b, –background 启动后转入后台执行</p></li><li><p>-e, –execute=COMMAND 执行`.wgetrc’格式的命令，wgetrc格式参见/etc/wgetrc或~/.wgetrc</p></li></ul><p>实例：使用wget下载单个文件</p><p>wget <a href="http://www.minjieren.com/wordpress-3.1-zh_CN.zip" rel="external nofollow noopener noreferrer" target="_blank">http://www.minjieren.com/wordpress-3.1-zh_CN.zip</a></p>]]></content>
    
    <summary type="html">
    
      Linux基础命令
    
    </summary>
    
      <category term="linux" scheme="https://www.dzou.top/categories/linux/"/>
    
    
      <category term="deepin" scheme="https://www.dzou.top/tags/deepin/"/>
    
      <category term="linux" scheme="https://www.dzou.top/tags/linux/"/>
    
      <category term="Ubuntu" scheme="https://www.dzou.top/tags/Ubuntu/"/>
    
      <category term="ssh" scheme="https://www.dzou.top/tags/ssh/"/>
    
      <category term="服务器" scheme="https://www.dzou.top/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Spring框架学习笔记--更新中(SSM第一部分) 从介绍Spring以及理解实现方法到Spring核心知识 教你上手使用Spring(适合收藏)</title>
    <link href="https://www.dzou.top/post/c519ea2a.html"/>
    <id>https://www.dzou.top/post/c519ea2a.html</id>
    <published>2019-07-24T01:26:12.000Z</published>
    <updated>2019-08-02T11:52:37.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Srping"><a href="#Srping" class="headerlink" title="Srping"></a>Srping</h2><p>一个轻量级java开发框架，为解决应用开发的业务逻辑层和其他层耦合问题，full-stack一站式框架专注于应用程序的开发</p><p><strong>Spring不取代框架，而是把他们无缝连接</strong><br><strong>新的编程思想</strong>：</p><ul><li>IOC反转：由我们自己执行反转给Spring帮我们执行</li><li>IOC控制：由Spring帮我们创建、掌控对象周期，在我们需要的时候向Spring申请即可</li><li>DI：依赖注入</li></ul><h3 id="DI依赖注入"><a href="#DI依赖注入" class="headerlink" title="DI依赖注入"></a>DI依赖注入</h3><p>理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：</p><ul><li>　　谁依赖于谁：当然是应用程序依赖于IoC容器；</li><li>　　为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源；</li><li>　　谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；</li><li>　　注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。</li></ul><h3 id="ApplicationContext接口"><a href="#ApplicationContext接口" class="headerlink" title="ApplicationContext接口"></a>ApplicationContext接口</h3><p>每次容器启动时就会创建容器中配置的所有对象，除此之外，还提供了更多丰富的功能。<br>典型的实现类：</p><ul><li>从类路径下加载配置文件（常用）：ClassPathXmlApplicationContext</li><li>从硬盘绝对路径下加载配置文件：FileSystemXmlApplicationContext</li></ul><h2 id="bean标签"><a href="#bean标签" class="headerlink" title="bean标签"></a>bean标签</h2><p>：配置bean对象（需要容器管理的对象）</p><ul><li><p>通过set、构造方法、复杂类型注入给bean对象幅值，即把对象交给spring管理，value为基本类型 ref引用调用对象 type指定参数类型来调用对应的构造方法</p></li><li><p>name属性起一个名字，是获取bean对象的参数getbean（name）</p></li><li><p>class属性是一个包名，spring通过这个包名创建对象</p></li></ul><p>1.set方法注入 property</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=<span class="string">"basketball"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.bean.Player"</span>&gt;</span><br><span class="line">       &lt;property name=<span class="string">"player_name"</span> value=<span class="string">"kobe_bryant"</span>/&gt;</span><br><span class="line">       &lt;property name=<span class="string">"player_type"</span> value=<span class="string">"basketball"</span>/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>2.构造方法注入 constructor-arg</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=<span class="string">"user1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.bean.User"</span>&gt;</span><br><span class="line">       &lt;constructor-arg name=<span class="string">"u_username"</span> value=<span class="string">"zoufubo"</span>/&gt;</span><br><span class="line">       &lt;constructor-arg name=<span class="string">"player"</span> ref=<span class="string">"basketball"</span>/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>3.复杂类型注入（Array、List、Map、Set、Properties、Object[]）</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=<span class="string">"array"</span>&gt;</span><br><span class="line">          &lt;array&gt;</span><br><span class="line">              &lt;value&gt;0110&lt;/value&gt;</span><br><span class="line">              &lt;ref bean=<span class="string">"basketball"</span>/&gt;</span><br><span class="line">          &lt;/array&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line">      &lt;property name=<span class="string">"list"</span>&gt;</span><br><span class="line">          &lt;list&gt;</span><br><span class="line">              &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">              &lt;value&gt;2&lt;/value&gt;</span><br><span class="line">              &lt;ref bean=<span class="string">"user1"</span>/&gt;</span><br><span class="line">          &lt;/list&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line">      &lt;property name=<span class="string">"map"</span>&gt;</span><br><span class="line">          &lt;map&gt;</span><br><span class="line">              &lt;entry key="username" value="dx"&gt;&lt;/entry&gt;</span><br><span class="line">              &lt;entry key="passwd" value="zoufubo"&gt;&lt;/entry&gt;</span><br><span class="line">              &lt;entry key-ref=<span class="string">"basketball"</span> value-ref=<span class="string">"user1"</span>/&gt;</span><br><span class="line">          &lt;/map&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line">      &lt;property name=<span class="string">"properties"</span>&gt;</span><br><span class="line">          &lt;props&gt;</span><br><span class="line">              &lt;prop key="age"&gt;25&lt;/prop&gt;</span><br><span class="line">              &lt;prop key="name"&gt;dx&lt;/prop&gt;</span><br><span class="line">          &lt;/props&gt;</span><br><span class="line">      &lt;/property&gt;</span><br></pre></td></tr></table></figure><ul><li>空参构造：spring创建bean对象使用空参数构造方法<br>ApplicationContext配置的bean会在容器创建时全部创建出来，bean较多时，内存过大。</li><li>使用延迟加载： lazy-init=”true” 创建容器时不加载对象，获取bean实例时才加载</li><li>scope=”singleton” 单例模式 容器只能创建一个bean对象 </li><li>scope=”prototyped”多例，会创建新的对象 scope=”request”在web环境下，创建的对象生命周期与request请求生命周期一致</li><li>init-method=”user_init（init函数）” </li><li>destroy-method=”destroy（销毁函数）”初始化和销毁方法，分别在bean对象创建和容器关闭时调用</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=<span class="string">"user"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.bean.User"</span> lazy-init=<span class="string">"true"</span> scope=<span class="string">"singleton"</span> init-method=<span class="string">"user_init"</span> destroy-method=<span class="string">"destroy"</span>&gt;</span><br><span class="line">       &lt;property name=<span class="string">"u_id"</span> value=<span class="string">"2"</span>/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br></pre></td></tr></table></figure><h2 id="Spring注解配置"><a href="#Spring注解配置" class="headerlink" title="Spring注解配置"></a>Spring注解配置</h2><p>需要aop包、导入约束</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">       http://www.springframework.org/schema/context/spring-context-3.0.xsd"</span>&gt;</span><br><span class="line">       &lt;!--把bean类作为组件扫描--&gt;</span><br><span class="line">    &lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"com.bean"</span>/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><blockquote><p>使用@Component注解，下面这短代码等价</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"user"</span>)</span><br><span class="line">&lt;bean name=<span class="string">"user"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.bean.User"</span>&gt;</span><br></pre></td></tr></table></figure><ul><li>@Controller  对应Web层</li><li>@Service 对应Service层</li><li>@Repository  对应Dao层</li><li>@PostConstruct()</li><li>@PreDestroy()**</li></ul><blockquote><p>利用注解幅值</p><ul><li>@Value（value=“”）加在字段上</li><li>@Value（“1”）加在set上</li><li>@Autowired自动装配：直接在要注入的引用前加上注解@Autowired，程序会自动从容器中找同类型对象为其注入，但当对象在容器中注册多个时，无法选择注入哪个对象。</li><li>@Recource（name=“”）在要注入的引用前加上注解@Resource，name值为要注入的对象的名称，该对象已注入在容器中。这种注入方式是手动注入，指定注入哪一个名称的对象，常用。</li></ul></blockquote><h3 id="单元测试与Spring整合"><a href="#单元测试与Spring整合" class="headerlink" title="单元测试与Spring整合"></a>单元测试与Spring整合</h3><p><strong>@Runwith（SpringJUnit4ClassRunner.class）使用junit进行测试，创建容器<br>@ContextConfiguration（“classpath：配置文件名”）读取配置文件</strong></p><h3 id="分包配置：导入其他配置文件"><a href="#分包配置：导入其他配置文件" class="headerlink" title="分包配置：导入其他配置文件"></a>分包配置：导入其他配置文件</h3><blockquote><p>&lt;import resource=””/</p></blockquote><h2 id="Spring常用约束"><a href="#Spring常用约束" class="headerlink" title="Spring常用约束"></a>Spring常用约束</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx/spring-tx.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><p><strong>面向切面的编程思想：将纵向重复的代码横向冲去解决 例如：过滤器（纵向重复的身份验证横向抽取解决）</strong><br>Spring中aop：无需我们自己写动态代理的代码，容器可以管理生成动态代理对象</p><ul><li>（a）Proxy动态代理：被代理的对象必须实现接口</li><li>（b）Cglib动态代理：被代理对象不能被final修饰</li></ul><p><img src="https://img-blog.csdnimg.cn/201905141958557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190514200142990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="`在这里插入图片描述`"></p><blockquote><p>关于定义通知的语法：首先通知有5种类型分别如下：</p><ul><li>before 目标方法执行前执行，前置通知</li><li>after 目标方法执行后执行，后置通知</li><li>after returning 目标方法返回时执行 ，后置返回通知</li><li>after throwing 目标方法抛出异常时执行 异常通知</li><li>around 在目标函数执行中执行，可控制目标函数是否执行，环绕通知</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">around_logprint</span><span class="params">(ProceedingJoinPoint pjp)</span></span>&#123;</span><br><span class="line">        Object rtVaule=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] args=pjp.getArgs();</span><br><span class="line">            rtVaule=pjp.proceed(args);</span><br><span class="line">            pjp.proceed();</span><br><span class="line">            <span class="keyword">return</span> rtVaule;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//增强代码</span></span><br><span class="line">            System.out.println(<span class="string">"around记录日志"</span>);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rtVaule;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>public void service.UserServiceImpl.save()     service包下UserServiceImpl类的无参无返回值的save()方法</li><li>void service.UserServiceImpl.save()     service包下UserServiceImpl类的无参无返回值的save()方法</li><li>service.UserServiceImpl.save()         service包下UserServiceImpl类的无参的save()方法</li><li>service.UserServiceImpl.save(..)     service包下UserServiceImpl类的save()方法</li><li>service.UserServiceImpl.*(..)     service包下UserServiceImpl类的所有方法</li><li>service.<em>ServiceImpl.</em>(..)    service包下所有以ServiceImpl结尾的类的所有方法，最常用</li><li>service..<em>ServiceImpl.</em>(..)    service包及其后代包下所有以ServiceImpl结尾的类的所有方法</li></ul><p><strong>注解配置aop需要用到的:</strong></p><ul><li>（1）扫描注解的包</li><li>（2）配置注解支持切面</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">context:component-scan base-package="com"/&gt;</span><br><span class="line">    <span class="comment">&lt;!--配置spring支持注解切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Spring中的JdbcTemplate"><a href="#Spring中的JdbcTemplate" class="headerlink" title="Spring中的JdbcTemplate"></a>Spring中的JdbcTemplate</h2><p><strong>Spring提供了一个操作数据库（CRUD）的对象JdbcTemplate（类似Dbutils）</strong></p><ul><li><p>spring整合JDBC的第一种方式，是将dao接口的实现类的对象放到spring容器中，这个对象依赖JDBCTemplate模板对象，所以要把JDBCTemplate模板对象放到spring容器中，再注入到实现类的对象，JDBCTemplate模板对象依赖连接池，所以要把连接池放到spring容器中，再注入到JDBCTemplate模板对象。在配置的时候要从依赖关系的最底层向上配置，所以配置的顺序依次是连接池对象、JDBCTemplate模板对象、实现类的对象。<strong>适用于xml配置</strong></p></li><li><p>第二种方式，如果dao接口的实现类先继承JdbcDaoSupport类再实现dao接口，就会根据连接池自动创建JDBC模板对象，不用手动创建JDBC模板对象，因为父类JdbcDaoSupport里面封装了创建JDBC模板的代码直接获得即可。这样在spring容器中就少一层依赖关系，dao接口实现类的对象直接依赖连接池对象。<strong>适用于注解配置</strong></p></li></ul><p><strong>提供统一的模板方法使对数据库的操作更加方便、友好，效率也不错。但是功能还是不够强大（比如不支持级联属性）</strong></p><p><strong>（1）</strong><br>JdbcTemplate 执行sql方法（常用之一），还有queryForObject获得单个对象，类似DButils<br>其中RowMapper使用BeanPropertyMapper用反射接收结果集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> BeanPropertyRowMapper&lt;Account&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Account <span class="title">mapRow</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> i)</span></span>&#123;&#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">query(String sql, <span class="meta">@NotNull</span> org.springframework.jdbc.core.RowMapper&lt;T&gt; rowMapper,</span><br><span class="line">                                  Object... args)</span><br></pre></td></tr></table></figure><blockquote><p>datasource配置数据库 jdbcTemplate配置该模板 accountDao配置接口实现类</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"dataSource"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"driverClassName"</span> value=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">"username"</span> value=<span class="string">"root"</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">"url"</span> value=<span class="string">"jdbc:mysql://localhost:3306/spring?serverTimezone=GMT"</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">"password"</span> value=<span class="string">"52zoufubo"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"jdbcTemplate"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"dataSource"</span> ref=<span class="string">"dataSource"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"accountDao"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.dingxiang.dao.AccountDaoImpl"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"jt"</span> ref=<span class="string">"jdbcTemplate"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><strong>接口类实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">getJt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJt</span><span class="params">(JdbcTemplate jt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jt = jt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findByid</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        List&lt;Account&gt; list=jt.query(<span class="string">"select * from jdbctemplatedemo where id=?"</span>,<span class="keyword">new</span> BeanPropertyRowMapper&lt;Account&gt;(Account.class),id);</span><br><span class="line">        <span class="keyword">return</span> list.isEmpty()?<span class="keyword">null</span>:list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findByname</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        List&lt;Account&gt; list=jt.query(<span class="string">"select * from jdbctemplatedemo where username=?"</span>,<span class="keyword">new</span> BeanPropertyRowMapper&lt;Account&gt;(Account.class),username);</span><br><span class="line">        <span class="keyword">return</span> list.isEmpty()?<span class="keyword">null</span>:list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateAccount</span><span class="params">(Account account,String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jt.update(<span class="string">"update jdbctemplatedemo set username=? and money=? where username=?"</span>,account.getName(),account.getMoney(),username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AccountDao accountDao= (AccountDao) ac.getBean(<span class="string">"accountDao"</span>);</span><br></pre></td></tr></table></figure><h2 id="Spring中的事务控制"><a href="#Spring中的事务控制" class="headerlink" title="Spring中的事务控制"></a>Spring中的事务控制</h2><ul><li>（1）Spring声明式事务（基于Aop的实现）：本质是对目标方法前后进行拦截，并在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</li></ul><p>声明式事务得益于 Spring IoC容器 和 Spring AOP 机制的支持：IoC容器为声明式事务管理提供了基础设施，使得 Bean 对于 Spring 框架而言是可管理的；而由于事务管理本身就是一个典型的横切逻辑（正是 AOP 的用武之地），因此 Spring AOP 机制是声明式事务管理的直接实现者</p><p><img src="https://img-blog.csdnimg.cn/2019051713311677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>事务是一个不可分割操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。</p></blockquote><ul><li>1.所谓事务的隔离级别是指若干个并发的事务之间的隔离程度TransactionDefinition.ISOLATION_DEFAULT</li><li>2.事务的只读属性是指，对事务性资源进行只读操作或者是读写操作</li><li>3.事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务</li><li>4.事务中抛出了未检查异常（继承自 RuntimeException 的异常），则默认将回滚事务。如果没有抛出任何异常，或者抛出了已检查异常，则仍然提交事务</li></ul><p><strong>jdbc、myabtis平台实现类：DataSourceTransactionManager</strong></p><ul><li>isolation=”DEFAULT”</li><li>PROPAGATION_REQUIRED  支持当前事务，如果不存在 就新建一个(默认)</li><li>read-only=”false” 表示该方法可以修改数据库</li></ul><p><strong>xml配置事务</strong><br>基于 <tx> 命名空间的实现</tx></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="number">1</span>)将mybatis核心事务管理器DataSourceTransactionManager配置到spring容器，依赖连接池。</span><br><span class="line">&lt;bean name=<span class="string">"transaction"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"dataSource"</span> ref=<span class="string">"dataSource"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">（<span class="number">2</span>）由txAdvice切面定义事务增强处理</span><br><span class="line">    &lt;tx:advice id=<span class="string">"txAdvice"</span> transaction-manager=<span class="string">"transaction"</span>&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;tx:method name=<span class="string">"transfer"</span> isolation=<span class="string">"DEFAULT"</span> propagation=<span class="string">"REQUIRED"</span> read-only=<span class="string">"false"</span>/&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line">（<span class="number">3</span>）配置事务增强处理的切入点，以保证其被恰当的织入</span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;aop:pointcut id=<span class="string">"myadvice"</span> expression=<span class="string">"execution(* com.dingxiang.service.impl.IAccountServiceImpl.*(..))"</span>/&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref=<span class="string">"txAdvice"</span> pointcut-ref=<span class="string">"myadvice"</span>/&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br></pre></td></tr></table></figure><p><strong>注解配置事务：</strong><br>基于 @Transactional 的实现<br>为需要加强的方法添加注解</p><ul><li>@Transactional(isolation = Isolation.DEFAULT,propagation = Propagation.REQUIRED,readOnly = false)</li></ul><p><strong>主配置文件打开注解配置事务</strong><code>&lt;tx:annotation-driven/&gt;</code></p><h2 id="Spring和Mybatis整合"><a href="#Spring和Mybatis整合" class="headerlink" title="Spring和Mybatis整合"></a>Spring和Mybatis整合</h2><p><strong>（1）由DriverManagerDataSource把数据库连接交给spring管理</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/spring?serverTimezone=GMT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"52zoufubo"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>（2）SqlSessionFactoryBean</strong></p><blockquote><p>配置mybatis的SqlSessionFactory，需要注入全局配置文件和由spring管理的连接池</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactory"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"sqlMapConfig.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>（3）MapperScannerConfigurer</strong></p><blockquote><p>使用一个 MapperScannerConfigurer , 它 将 会 查 找 类 路 径 下 的 映 射 器 并 自 动 将 它 们 创 建 成 MapperFactoryBean<br>basePackage 属性是让你为映射器接口文件设置基本的包路径。 你可以使用分号或逗号 作为分隔符设置多于一个的包路径。每个映射器将会在指定的包路径中递归地被搜索到。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span> <span class="attr">name</span>=<span class="string">"configurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.dingxiang.mapper"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>或者可以使用MapperFactoryBean配置Mapper，通过id名获得mapper对象</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountMapper"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperFactoryBean"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperInterface"</span> <span class="attr">value</span>=<span class="string">"com.mapper.AccountMapper"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactoryId"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Srping,一个轻量级java开发框架，为解决应用开发的业务逻辑层和其他层耦合问题，full-stack一站式框架专注于应用程序的开发
    
    </summary>
    
      <category term="Java Web" scheme="https://www.dzou.top/categories/Java-Web/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="后端" scheme="https://www.dzou.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Spring" scheme="https://www.dzou.top/tags/Spring/"/>
    
      <category term="SSM" scheme="https://www.dzou.top/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>Redis非关系型数据库学习笔记--更新中</title>
    <link href="https://www.dzou.top/post/7c806d9b.html"/>
    <id>https://www.dzou.top/post/7c806d9b.html</id>
    <published>2019-07-24T01:20:27.000Z</published>
    <updated>2019-08-02T11:51:47.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NoSql（Not-Only-Sql）非关系型数据库"><a href="#NoSql（Not-Only-Sql）非关系型数据库" class="headerlink" title="NoSql（Not Only Sql）非关系型数据库"></a>NoSql（Not Only Sql）非关系型数据库</h2><p>这类型数据存储不需要<strong>固定</strong>的模式，<strong>key-value cache persistent存储</strong><br><strong>易扩展</strong><br><strong>把反复查询的数据放到缓存里，减少过多查询数据库</strong><br><strong>读写分离</strong>：写（主数据库），读（副数据库）<br><strong>表锁，行锁</strong>（高并发下使用时把数据锁起来，一次只能一个使用）<br><strong>分表分库</strong>：减小数据库压力<br>无需<strong>事先创建对应字段</strong>，灵活性高</p><p><strong>出现原因：关系型数据库无法解决过于复杂的关系</strong>（例如亲戚）<br>高并发、高可扩、高性能</p><p><strong>BSON</strong>Binary JSON</p><p><strong>聚合模型：</strong></p><ol><li>KV键值（Redis）</li><li>文档型数据库 BSON（CacheDb、MongoDB）</li><li>列族</li><li>图形（朋友圈社交网络、广告推荐系统）</li></ol><p><strong>CAP:（三进二）</strong></p><ul><li>C:Consistency 强一致性</li><li>A：可用性</li><li>P：分区容忍性</li></ul><hr><p><strong>Redis(很高效)</strong><br>一个基于内存的单线程高性能key-value型数据库（NoSql），读写性能优越，支持多种数据类型（list、set、zset、hash），master-slaver数据备份<br>epoll（linux内核），多路io复用，读写快<br><strong>内存储存和持久化</strong>：异步将内存数据写到硬盘上<br>CONFIG命令获取和设置所有的Redis配置。</p><hr><p><strong>命令：</strong><br>select 获取数据库（0-15）<br>get key 获取key<br>set key value 设置键值<br>DSBSIZE 当前表容量<br>FLUSHDB、FLUSHALL清空当前库和所有库<br>exists key 存在key（1） 没有（0）<br>ttl 过期时间（-1永不过期 -2 已经过期）<br>expire key time（设置过期时间）</p><hr><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><strong>哈希（hash）</strong>：<br>String类型的field和value的映射表，hash特别适合用于存储对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; HMSET user:1 username</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; HGETALL user:1</span><br><span class="line">1) &quot;username&quot;</span><br></pre></td></tr></table></figure><p><strong>列表（list）</strong><br>列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; lpush redis.net.cn redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange redis.net.cn 0 10</span><br></pre></td></tr></table></figure><p><strong>集合（set）</strong><br>Set是string类型的无序无重复集合。<br>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; sadd redis.net.cn redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; smembers redis.net.cn</span><br></pre></td></tr></table></figure><p><strong>有序集合（zset）：sorted set</strong><br>通过分数来为集合中的成员进行从小到大的排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; zadd redis.net.cn 0 redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; zadd redis.net.cn 0 rabitmq</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; zadd redis.net.cn 0 rabitmq</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; ZRANGEBYSCORE redis.net.cn 0 1000</span><br></pre></td></tr></table></figure><hr><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p><strong>1.rdb：redis Database</strong><br>将redis存储的数据生成<strong>快照snapshot并存储到磁盘</strong>等介质上<br>对于RDB方式，redis会单独创建（<strong>fork</strong>）一个子进程来进行持久化，而主进程是不会进行任何IO操作的，这样就确保了redis极高的性能。<br>redis在进行数据持久化的过程中，会先将数据写入到一个临时文件中，待持久化过程都结束了，才会用这个临时文件替换上次持久化好的文件。<br>保存dump.rdb（备份）</p><p><strong>2.aof：append only file</strong><br>以日志记录形式写操作，只能<strong>追不能改写</strong><br>AOF方式是将执行过的写指令记录下来，在数据恢复时按照<strong>从前到后</strong>的顺序再将指令都执行一遍，就这么简单。</p><p>AOF方式的另一个好处，我们通过一个“场景再现”来说明。某同学在操作redis时，不小心执行了FLUSHALL，导致redis内存中的数据全部被清空了，这是很悲剧的事情。不过这也不是世界末日，只要redis配置了AOF持久化方式，且AOF文件还没有被重写（rewrite），我们就可以用最快的速度暂停redis并编辑AOF文件，将最后一行的FLUSHALL命令删除，然后重启redis，就可以恢复redis的所有数据到FLUSHALL之前的状态了。是不是很神奇，这就是AOF持久化方式的好处之一。但是如果AOF文件已经被重写了，那就无法通过这种方法来恢复数据了。</p><p><strong><em>aof重写</em></strong><br>因为采用了追加方式，如果不做任何处理的话，AOF文件会变得<strong>越来越大</strong>，为此，redis提供了AOF文件重写（rewrite）机制，即当AOF文件的大小超过所设定的阈值时，redis就会启动AOF文件的<strong>内容压缩</strong>，只保留可以<strong>恢复数据的最小指令集</strong>。<br>2、在重写即将开始之际，redis会创建（fork）一个“重写子进程”，这个子进程会首先读取现有的AOF文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。</p><p>3、与此同时，主工作进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的AOF文件中，这样做是保证原有的AOF文件的可用性，避免在重写过程中出现意外。</p><p>4、当“重写子进程”完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新AOF文件中。</p><p>5、当追加结束后，redis就会用新AOF文件来代替旧AOF文件，之后再有新的写指令，就都会追加到新的AOF文件中了。</p><hr><p><strong>aof和rdb比较</strong><br>官方的建议是两个同时使用。这样可以提供更可靠的持久化方案<br>RDB需要定时持久化，风险是可能会丢两次持久之间的数据，量可能很大。<br>在同样数据规模的情况下，AOF文件要比RDB文件的体积大。而且，AOF方式的恢复速度也要慢于RDB方式。</p><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>一次执行多个命令，批处理（一起成功、一起失败）<br><img src="https://img-blog.csdnimg.cn/20190612152347346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; MULTI </span><br><span class="line">OK </span><br><span class="line">redis 127.0.0.1:6379&gt; SET mykey &quot;redis&quot; </span><br><span class="line">QUEUED </span><br><span class="line">redis 127.0.0.1:6379&gt; GET mykey </span><br><span class="line">QUEUED </span><br><span class="line">redis 127.0.0.1:6379&gt; INCR visitors </span><br><span class="line">QUEUED </span><br><span class="line">redis 127.0.0.1:6379&gt; EXEC  </span><br><span class="line">1) OK </span><br><span class="line">2) &quot;redis&quot; </span><br><span class="line">3) (integer) 1</span><br></pre></td></tr></table></figure><p><strong>watch类似乐观锁</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//balance100 debt 20</span><br><span class="line">127.0.0.1:6379&gt; watch balance</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY balance 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY debt 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) (integer) 80</span><br><span class="line">2) (integer) 40</span><br></pre></td></tr></table></figure><hr><h2 id="Redis发布和订阅（少用）-有专门的消息中间件"><a href="#Redis发布和订阅（少用）-有专门的消息中间件" class="headerlink" title="Redis发布和订阅（少用） 有专门的消息中间件"></a><del>Redis发布和订阅</del>（少用） 有专门的消息中间件</h2><p>Redis 发布订阅(pub/sub)实现了消息系统，发送者(在redis术语中称为发布者)在接收者(订阅者)接收消息时发送消息。传送消息的链路称为信道。</p><hr>]]></content>
    
    <summary type="html">
    
      redis非关系型数据库，redis实现缓存存储，高效查询
    
    </summary>
    
      <category term="数据库" scheme="https://www.dzou.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="分布式" scheme="https://www.dzou.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="后端" scheme="https://www.dzou.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Redis" scheme="https://www.dzou.top/tags/Redis/"/>
    
      <category term="NoSql" scheme="https://www.dzou.top/tags/NoSql/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC框架学习笔记--更新中 JavaWeb开发（SSM框架第三部分）从介绍SpringMVC到使用,让你掌握核心知识</title>
    <link href="https://www.dzou.top/post/f3a4f54b.html"/>
    <id>https://www.dzou.top/post/f3a4f54b.html</id>
    <published>2019-07-24T01:14:50.000Z</published>
    <updated>2019-08-02T11:54:14.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><h3 id="服务器端三层架构"><a href="#服务器端三层架构" class="headerlink" title="服务器端三层架构"></a>服务器端三层架构</h3><ul><li>表现层（SpringMVC）</li><li>务层（Spring）</li><li>持久层（Mybatis）<br>表现层：拿到http请求的参数，传递给spring</li></ul><p><img src="https://img-blog.csdnimg.cn/20190518202814921.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p><strong>SpringMVC：一种基于Java实现的MVC设计模型的请求驱动类型的轻量级框架</strong></p><ul><li>M（model）：javaBean对象（将参数封装成JavaBean对象交给业务层处理）</li><li>V(view)：jsp （向控制器提交数据，显示模型中的数据）</li><li>C（controller）：servlet（根据视图提出的请求判断将请求交给那个模型处理，将处理后的结果交给对应的视图更新显示）</li></ul><h3 id="SpringMVC运行流程"><a href="#SpringMVC运行流程" class="headerlink" title="SpringMVC运行流程"></a>SpringMVC运行流程</h3><p>在Spring MVC框架中，从“Request（请求）”开始，依次进入“DispatcherServlet（核心分发器）” —&gt; “HandlerMapping（处理器映射）” —&gt; “Controller（控制器）” —&gt; “ModelAndView（模型和视图）” —&gt; “ViewResolver（视图解析器）” —&gt; “View（视图）” —&gt; “Response（响应）”结束，其中DispatcherServlet、HandlerMapping和ViewResolver 只需要在XML文件中配置即可，从而大大提高了开发的效率，特别是对于 HandlerMapping 框架为其提供了默认的配置。</p><ul><li>1.HandlerMapping（处理器映射）：通过映射找到哪个控制器执行哪个方法@RequestMapping（path=“”）再通过HandlerAdapter适配器执行方法</li><li>2.ViewResolver（视图解析器）：找到哪个视图的显示</li></ul><p><img src="https://img-blog.csdnimg.cn/20190519203907629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="SpringMVC和struct2区别"><a href="#SpringMVC和struct2区别" class="headerlink" title="SpringMVC和struct2区别"></a>SpringMVC和struct2区别</h3><ul><li>共同：都是表现层框架，离不开ServletAPI， 请求的机制都是一个核心控制器</li><li>不同：<ul><li>1.SpringMVC核心控制器是Servlet，Struct是Filter</li><li>2.SpringMVC是基于方法设计的，Struct是基于类设计的，前者效率较高</li><li>3.SpringMVC使用更简洁，支持JSR303，处理ajax请求更方便</li><li>4.Struct的OGNL表达式比SpringMVC开发效率高，执行效率比JSTL低，尤其Struct的表单标签，没有html效率高</li></ul></li></ul><h3 id="创建SpringMVC-Web项目"><a href="#创建SpringMVC-Web项目" class="headerlink" title="创建SpringMVC Web项目"></a>创建SpringMVC Web项目</h3><blockquote><p>使用maven构建webapp项目，maven添加archetypeCatalog=internal，国外服务器太慢</p></blockquote><p><a href="mvc:annotation-driven/" rel="external nofollow noopener noreferrer" target="_blank">mvc:annotation-driven/</a>打开注解（处理器映射器、处理器适配器、视图解析器配置）</p><h4 id="请求参数绑定"><a href="#请求参数绑定" class="headerlink" title="请求参数绑定"></a>请求参数绑定</h4><p>当你以表当post提交参数时，RequestMapping可以根据HandlerMapping寻找指定controller携带的javabean类对象参数将参数封装成一个bean对象返回（jsp表单指定属性name值要与bean对象属性名相同，当参数时包装对象时，应使用包装对象里的对象名加属性）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"params/userVoadd"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    username<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"user.username"</span>&gt;</span><span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line">    password<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"user.password"</span>&gt;</span><span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line">    money<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"user.money"</span>&gt;</span><span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line">    UserVoName<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"userVoname"</span>&gt;</span><span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line">    UserVoPassword<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"userVopassword"</span>&gt;</span><span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="请求时参数转换器"><a href="#请求时参数转换器" class="headerlink" title="请求时参数转换器"></a>请求时参数转换器</h4><p>（1）首先定义一个类继承<strong>Converter</strong>或者<strong>formatter</strong>类，<br>前者可用泛型表达参数转换类型&lt;String,Integer&gt;，后者使用<t>,formatter转换源类型必须是String，对于Web应用Http发送的数据都是以String类型存储，使用formatter更合适</t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Convertors</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>,<span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"请你传入数据!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        DateFormat df=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> df.parse(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"转换出错"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）在主文件中配置装换器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span> <span class="attr">id</span>=<span class="string">"conversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.dingxiang.utils.DateConvertor.Convertors"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（3）在注解中打开转换器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">"conversionServiceFactoryBean"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><h4 id="RequestParam"><a href="#RequestParam" class="headerlink" title="RequestParam"></a>RequestParam</h4><p>（1）RequestParam=request.getParameter(“name”)（name和value属性基本等同，required表示是否必须）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用s来获取参数username</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestParam</span><span class="params">(@RequestParam(name = <span class="string">"username"</span>)</span>String s)</span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"start"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="RequestBody"><a href="#RequestBody" class="headerlink" title="RequestBody"></a>RequestBody</h4><p>（2）RequestBody（获取请求体的内容，得到key=value&amp;keyvalue…，gei方式不适用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取表单传递参数，用字符串接受</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestBody</span><span class="params">(@RequestBody String body)</span></span>&#123;</span><br><span class="line">        System.out.println(body);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"start"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="PathVarible"><a href="#PathVarible" class="headerlink" title="PathVarible"></a>PathVarible</h4><p>（3）PathVariable使用RESTful风格，即根据参数传递类型和参数数量选取不同的方法执行，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用占位符&#123;&#125;直接传入参数</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testPathVariable/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testPathVariable</span><span class="params">(@PathVariable(value = <span class="string">"id"</span>)</span> String body)</span>&#123;</span><br><span class="line">        System.out.println(body);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"start"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="静态方法发送请求"><a href="#静态方法发送请求" class="headerlink" title="静态方法发送请求"></a>静态方法发送请求</h4><p>浏览器插件测试各种请求方式<br>（4）RequestHeader（少用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestHeader</span>(value = <span class="string">"User-Agent"</span>)</span><br></pre></td></tr></table></figure><p>（5）CookieValue（少用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CookieValue</span>(value = <span class="string">"JSESSIONID"</span>)</span><br></pre></td></tr></table></figure><h4 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="ModelAttribute"></a>ModelAttribute</h4><p>（6）ModelAttribute（方法、参数）首先执行<br>用于将多个参数封装到一个实体对象，从而简化数据绑定流程，自动暴露为模型数据，在视图展示时使用<br>两种方法，返回bean对象或者通过把bean对象加入到集合使用注解来读取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testModelAttribute"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">testModelAttribute</span><span class="params">(@ModelAttribute(<span class="string">"1"</span>)</span> User user)</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"testModelAttribute"</span>);</span><br><span class="line">       System.out.println(user.toString());</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"start"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@ModelAttribute</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modelattribute</span><span class="params">(Map&lt;String,User&gt; map)</span></span>&#123;</span><br><span class="line">       User user=<span class="keyword">new</span> User();</span><br><span class="line">       user.setDate(<span class="keyword">new</span> Date());</span><br><span class="line">       user.setMoney(<span class="number">12.212</span>);</span><br><span class="line">       map.put(<span class="string">"1"</span>,user);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testModelAttribute"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testModelAttribute</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testModelAttribute"</span>);</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"start"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">modelattribute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User user=<span class="keyword">new</span> User();</span><br><span class="line">        user.setDate(<span class="keyword">new</span> Date());</span><br><span class="line">        user.setMoney(<span class="number">12.212</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="SessionAttribute"><a href="#SessionAttribute" class="headerlink" title="SessionAttribute"></a>SessionAttribute</h4><p>（7）SessionAttribute<br>使用HttpSession的话需要servletAPI支持，存在耦合<br>value代表我们需要把什么样的对象放入session</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SessionAttributes</span>(value = &#123;<span class="string">"name"</span>&#125;)</span><br></pre></td></tr></table></figure><h4 id="前端控制器拦截资源文件"><a href="#前端控制器拦截资源文件" class="headerlink" title="前端控制器拦截资源文件"></a>前端控制器拦截资源文件</h4><p>（8）不让前端控制器拦截资源文件<br>    <code>&lt;mvc:resources mapping=&quot;/css/**&quot; location=&quot;/css/**&quot;/&gt;</code></p><h4 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="ResponseBody"></a>ResponseBody</h4><p>（9）ResponseBody 使用到了json转换器jackson，添加maven依赖<br>核心包：jackson-databind jackson-annatation jackson-core</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Ajax前后端数据传输"><a href="#Ajax前后端数据传输" class="headerlink" title="Ajax前后端数据传输"></a>Ajax前后端数据传输</h3><p> <strong>jQuery Ajax实现前后台json数据传输并使用@RequestBody封装成对象传输到后台@ResponseBody封装成对象返回到jsp</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            $(<span class="string">'#ajax'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                $.ajax(&#123;</span><br><span class="line">                    url:<span class="string">'user/testAjax2'</span>,</span><br><span class="line">                    contentType:<span class="string">'application/json; charset=UTF-8'</span>,</span><br><span class="line">                    type:<span class="string">'post'</span>,</span><br><span class="line">                    data:<span class="string">'&#123;"username":"zoufuob","password":"12345"&#125;'</span>,</span><br><span class="line">                    dataType:<span class="string">'json'</span>,</span><br><span class="line">                    error:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                        alert(<span class="string">"获取数据失败"</span>)</span><br><span class="line">                    &#125;,</span><br><span class="line">                    success:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                        alert(data.username)</span><br><span class="line">                        alert(data.password)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jackson把json String封装发哦user对象</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testAjax2"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">User <span class="title">testAjax2</span><span class="params">(@RequestBody User user)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行了testAjax2"</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="comment">//模拟查找修改数据库数据</span></span><br><span class="line">        user.setUsername(<span class="string">"wangdatao"</span>);</span><br><span class="line">        user.setPassword(<span class="string">"52zoufubo"</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul><li>（1）异常类  继承Exception</li><li>（2）异常解析类 实现接口HandlerExceptionResolver重写resolveException方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse, Object o, Exception e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取异常对象</span></span><br><span class="line">        SysException exception=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(e <span class="keyword">instanceof</span> SysException)&#123;</span><br><span class="line">            exception= (SysException) e;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            exception = <span class="keyword">new</span> SysException(<span class="string">"error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建modelandview</span></span><br><span class="line">        ModelAndView modelAndView=<span class="keyword">new</span> ModelAndView();</span><br><span class="line">        modelAndView.addObject(<span class="string">"errorMsg"</span>,exception.getMsg());</span><br><span class="line">        modelAndView.setViewName(<span class="string">"error"</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>（3）配置异常处理器（配置异常解析类对象到spring）</li></ul><p><img src="https://img-blog.csdnimg.cn/20190522230615681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NzYwMzMy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><blockquote><p>表单 enctype=”multipart/form-data”</p></blockquote><h4 id="单服务器文件上传"><a href="#单服务器文件上传" class="headerlink" title="单服务器文件上传"></a>单服务器文件上传</h4><p>用MultipartFile对象作为Controller参数接收表单传入数据，通过transferTo方法上传文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testUpload2</span><span class="params">(HttpServletRequest request, MultipartFile upload2)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"文件上传"</span>);</span><br><span class="line">        String path=request.getSession().getServletContext().getRealPath(<span class="string">"/uploads/"</span>);</span><br><span class="line">        File file=<span class="keyword">new</span> File(path);</span><br><span class="line">        <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">            file.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line">        String name=upload2.getOriginalFilename();</span><br><span class="line">        String uuid=UUID.randomUUID().toString().replace(<span class="string">"-"</span>,<span class="string">""</span>);</span><br><span class="line">        name=uuid+<span class="string">"_"</span>+name;</span><br><span class="line">        upload2.transferTo(<span class="keyword">new</span> File(path,name));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="跨服务器上传文件"><a href="#跨服务器上传文件" class="headerlink" title="跨服务器上传文件"></a>跨服务器上传文件</h4><ul><li>（1）创建客户端对象</li><li>（2）与服务器建立连接</li><li>（3）传入数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"testUpload3"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testUpload3</span><span class="params">(MultipartFile upload3)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"跨服务器文件上传"</span>);</span><br><span class="line">        String path=<span class="string">"http://localhost:8090/uploads/"</span>;</span><br><span class="line">        String name=upload3.getOriginalFilename();</span><br><span class="line">        String uuid=UUID.randomUUID().toString().replace(<span class="string">"-"</span>,<span class="string">""</span>);</span><br><span class="line">        name=uuid+<span class="string">"_"</span>+name;</span><br><span class="line">        <span class="comment">//创建客户端对象</span></span><br><span class="line">        Client client=Client.create();</span><br><span class="line">        <span class="comment">//与服务器进行连接</span></span><br><span class="line">        WebResource resource=client.resource(path+name);</span><br><span class="line">        <span class="comment">//传文件</span></span><br><span class="line">        resource.put(upload3.getBytes());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>功能与过滤器基本相同，但是拦截器只能对用户请求的方法进行拦截，用在权限验证，判断用户是否登录，记录请求信息的日志</p><ul><li>拦截器类 实现接口HandlerInterceptor 可重写<ul><li>preHandle（返回true时执行下一个拦截器，没有拦截器时执行Controller）</li><li>postHandle（该方法在控制器请求方法调用之后，视图解析之前进行执行）</li><li>afterHandle（在视图解析后执行）</li></ul></li><li>配置拦截器</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--要拦截的方法--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/user/testInterceptor"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.dingxiang.Interceptor.MyInterceptor"</span> <span class="attr">id</span>=<span class="string">"myInterceptor"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--要拦截的方法--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/user/testInterceptor"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.dingxiang.Interceptor.MyInterceptor2"</span> <span class="attr">id</span>=<span class="string">"myInterceptor2"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/login/main"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.dingxiang.Interceptor.loginInterceptor.LoginInterceptor"</span> <span class="attr">id</span>=<span class="string">"loginInterceptor"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="数据验证"><a href="#数据验证" class="headerlink" title="数据验证"></a>数据验证</h3><p>网页前端验证后还需要在服务器端对数据进行验证</p><h4 id="Spring-Validator接口"><a href="#Spring-Validator接口" class="headerlink" title="Spring Validator接口"></a>Spring Validator接口</h4><p>首先需要编写一个Vaidator类实现该接口，对数据进行验证的配置，相当于JSR303的注解配置验证信息；<br>然后再主配置文件中配置一个ReloadableResourceBundleMessageSource Bean并打开注解validator</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ReloadableResourceBundleMessageSource"</span> <span class="attr">id</span>=<span class="string">"messageSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basename"</span> <span class="attr">value</span>=<span class="string">"classpath:errorMessege"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">validator</span>=<span class="string">"validator"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="JSR303-JSR-303"><a href="#JSR303-JSR-303" class="headerlink" title="JSR303 JSR-303"></a>JSR303 JSR-303</h4><p> Java EE 6 中的一项子规范，叫做 Bean Validation JSR 303 用于对 Java Bean 中的字段的值进行验证。</p><ol><li><p>Bean Validation 中内置的 constraint</p><ul><li>@Null<br>被注释的元素必须为 null</li><li>@NotNull<br>被注释的元素必须不为 null</li><li>@AssertTrue<br>被注释的元素必须为 true</li><li>@AssertFalse<br>被注释的元素必须为 false</li><li>@Min(value)<br>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li><li>@Max(value)<br>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li><li>@DecimalMin(value)<br>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li><li>@DecimalMax(value)<br>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li><li>@Size(max, min)<br>被注释的元素的大小必须在指定的范围内</li><li>@Digits (integer, fraction)<br>被注释的元素必须是一个数字，其值必须在可接受的范围内</li><li>@Past<br>被注释的元素必须是一个过去的日期</li><li>@Future<br>被注释的元素必须是一个将来的日期</li><li>@Pattern(value)<br>被注释的元素必须符合指定的正则表达式</li></ul></li><li><p>Hibernate Validator 附加的 constraint</p><ul><li>@Email<br>被注释的元素必须是电子邮箱地址</li><li>@Length<br>被注释的字符串的大小必须在指定的范围内</li><li>@NotEmpty<br>被注释的字符串的必须非空</li><li>@Range<br>被注释的元素必须在合适的范围内</li></ul></li></ol><p>与Validator不同的是需要配置一个LocalValidatorFactoryBean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"validator"</span> <span class="attr">class</span>=<span class="string">"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"providerClass"</span> <span class="attr">value</span>=<span class="string">"org.hibernate.validator.HibernateValidator"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"validationMessageSource"</span> <span class="attr">ref</span>=<span class="string">"messageSource"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      SpringMVC：一种基于Java实现的MVC设计模型的请求驱动类型的轻量级框架- M（model）：javaBean对象（将参数封装成JavaBean对象交给业务层处理）- V(view)：jsp （向控制器提交数据，显示模型中的数据）- C（controller）：servlet（根据视图提出的请求判断将请求交给那个模型处理，将处理后的结果交给对应的视图更新显示）
    
    </summary>
    
      <category term="Java Web" scheme="https://www.dzou.top/categories/Java-Web/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="后端" scheme="https://www.dzou.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Spring" scheme="https://www.dzou.top/tags/Spring/"/>
    
      <category term="SSM" scheme="https://www.dzou.top/tags/SSM/"/>
    
      <category term="SpringMVC" scheme="https://www.dzou.top/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>解决Deepin系统使用中dock栏消失不显示</title>
    <link href="https://www.dzou.top/post/3a5de41c.html"/>
    <id>https://www.dzou.top/post/3a5de41c.html</id>
    <published>2019-07-23T12:38:32.000Z</published>
    <updated>2019-08-02T11:47:09.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解决Deepin系统使用中dock栏消失不显示"><a href="#解决Deepin系统使用中dock栏消失不显示" class="headerlink" title="解决Deepin系统使用中dock栏消失不显示"></a>解决Deepin系统使用中dock栏消失不显示</h2><p>不需要卸载重新安装<strong>dde-dock</strong></p><p>只需要把进程kill</p><p>终端中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall dde-dock</span><br></pre></td></tr></table></figure><p>dock栏就出现了</p>]]></content>
    
    <summary type="html">
    
      解决Deepin系统使用中dock栏消失不显示
    
    </summary>
    
      <category term="linux" scheme="https://www.dzou.top/categories/linux/"/>
    
    
      <category term="deepin" scheme="https://www.dzou.top/tags/deepin/"/>
    
      <category term="linux" scheme="https://www.dzou.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>牛客网算法编程题--物流中转站 解答</title>
    <link href="https://www.dzou.top/post/90a1be19.html"/>
    <id>https://www.dzou.top/post/90a1be19.html</id>
    <published>2019-07-23T08:40:32.000Z</published>
    <updated>2019-08-02T11:45:18.084Z</updated>
    
    <content type="html"><![CDATA[<h2 id="物流中转站"><a href="#物流中转站" class="headerlink" title="物流中转站"></a>物流中转站</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Shopee物流会有很多个中转站。在选址的过程中，会选择离用户最近的地方建一个物流中转站。</p><p>假设给你一个二维平面网格，每个格子是房子则为1，或者是空地则为0。找到一个空地修建一个物流中转站，使得这个物流中转站到所有的房子的距离之和最小。 能修建，则返回最小的距离和。如果无法修建，则返回 -1。</p><p>若范围限制在100*100以内的网格，如何计算出最小的距离和？</p><p>当平面网格非常大的情况下，如何避免不必要的计算？</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">0 1 1 0</span><br><span class="line">1 1 0 1</span><br><span class="line">0 0 1 0</span><br><span class="line">0 0 0 0</span><br><span class="line"></span><br><span class="line">先输入方阵阶数，然后逐行输入房子和空地的数据，以空格分隔。</span><br></pre></td></tr></table></figure><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line"></span><br><span class="line">能修建，则返回最小的距离和。如果无法修建，则返回 -1。</span><br></pre></td></tr></table></figure><hr><blockquote><p>相信大家都会使用二维数组和循环遍历,下面我讲这道题将使用大家一些比较不熟悉或者陌生的知识</p></blockquote><h3 id="Lambda-Stream-静态内部类"><a href="#Lambda-Stream-静态内部类" class="headerlink" title="Lambda Stream+静态内部类"></a>Lambda Stream+静态内部类</h3><p>希望大家看完以后可以学会将stream和内部类应用到项目中,也可以进一步学习一下Lambda,时很有必要的</p><h4 id="步入正题"><a href="#步入正题" class="headerlink" title="步入正题"></a>步入正题</h4><p>思路</p><p>使用封装对象Point存放点的坐标,再把他们存放到集合List中(ArrayList读取效率高),编写求距离和的函数和求两点距离和的函数,最后通过stream和Lambda组合获得距离最小值</p><p><img src="/images/1.png" alt="1562076624237"></p><p>关键代码就一行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> re = noBuildings.stream()</span><br><span class="line">    .map(x-&gt;distanceSum(x.x,x.y))</span><br><span class="line">    .min(Integer::compareTo)</span><br><span class="line">    .get();</span><br></pre></td></tr></table></figure><p><strong>这段代码中stream就是获取一个流对象,map把参数x与求解距离总和的方法映射得到该方法的返回值min就是在这些返回值中获得最小的值(使用了Integer中的ComparaTo方法 最后通过get获得这个最小值)</strong></p><h3 id="如果又看不懂的可以看一下我的另外一篇关于Lambda和Stream的博客"><a href="#如果又看不懂的可以看一下我的另外一篇关于Lambda和Stream的博客" class="headerlink" title="如果又看不懂的可以看一下我的另外一篇关于Lambda和Stream的博客"></a>如果又看不懂的可以看一下我的另外一篇关于Lambda和Stream的博客</h3><p>我们在输入点的时候就把点封装add到集合中,我们只需要从没有建筑的点中查取出与空地的距离的最小值</p><p>源代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Point&gt; buildings;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    buildings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Point&gt; noBuildings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> l = scanner.nextInt();</span><br><span class="line">    <span class="keyword">int</span>[][] sites = <span class="keyword">new</span> <span class="keyword">int</span>[l][l];</span><br><span class="line">    scanner.nextLine();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">        String[] str;</span><br><span class="line">        str = scanner.nextLine().split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>;m&lt;l;m++)&#123;</span><br><span class="line">                sites[i][m] = Integer.parseInt(str[m].trim());</span><br><span class="line">                <span class="keyword">if</span>(sites[i][m]==<span class="number">0</span>)&#123;</span><br><span class="line">                    noBuildings.add(<span class="keyword">new</span> Point(i,m));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    buildings.add(<span class="keyword">new</span> Point(i,m));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(noBuildings.isEmpty())&#123;</span><br><span class="line">        System.out.println(<span class="string">"-1"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> re = noBuildings.stream().map(x-&gt;distanceSum(x.x,x.y)).min(Integer::compareTo).get();</span><br><span class="line">    System.out.println(re);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">distanceSum</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> line)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Point point : buildings) &#123;</span><br><span class="line">        sum+=twoPoint(row,line,point.x,point.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">twoPoint</span><span class="params">(<span class="keyword">int</span> row1,<span class="keyword">int</span> line1,<span class="keyword">int</span> row2,<span class="keyword">int</span> line2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(row2-row1)+Math.abs(line2-line1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    Point(<span class="keyword">int</span> row,<span class="keyword">int</span> line)&#123;</span><br><span class="line">        x=row;</span><br><span class="line">        y=line;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Shopee物流会有很多个中转站。在选址的过程中，会选择离用户最近的地方建一个物流中转站。假设给你一个二维平面网格，每个格子是房子则为1，或者是空地则为0。找到一个空地修建一个物流中转站，使得这个物流中转站到所有的房子的距离之和最小。 能修建，则返回最小的距离和。如果无法修建，则返回 -1。
    
    </summary>
    
      <category term="算法" scheme="https://www.dzou.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="算法" scheme="https://www.dzou.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="牛客" scheme="https://www.dzou.top/tags/%E7%89%9B%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>AbstractQueuedSynchronizer AQS锁原理（源码分析）及ReentrantLock非公平锁的实现并实现自定义AQS锁</title>
    <link href="https://www.dzou.top/post/7a5625fe.html"/>
    <id>https://www.dzou.top/post/7a5625fe.html</id>
    <published>2019-07-23T08:38:32.000Z</published>
    <updated>2019-08-02T11:46:31.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AbstractQueuedSynchronizer-AQS锁原理及ReentrantLock非公平锁的实现"><a href="#AbstractQueuedSynchronizer-AQS锁原理及ReentrantLock非公平锁的实现" class="headerlink" title="AbstractQueuedSynchronizer AQS锁原理及ReentrantLock非公平锁的实现"></a>AbstractQueuedSynchronizer AQS锁原理及ReentrantLock非公平锁的实现</h1><p>AbstractQueuedSynchronizer是基于一个FIFO双向链队列 CLH队列，用于构建锁或者同步装置的类，也称为Java同步器，ReentrantLock的公平锁与非公平锁就是由该同步器构成，链队列结构图如下。</p><p>你可以理解为银行ATM机取钱，一个人先去取，获取到了锁，在这个时间内其他线程处于阻塞状态，只有等他取完钱了，他走了，释放了锁，排在它后面的人才可以获取到释放的锁并进行取钱。</p><p><img src="http://ifeve.com/wp-content/uploads/2013/10/21.png" alt="img"></p><p>该同步器利用一个int值表示状态，实现方式是==使用内部类继承该同步器的方式==实现它的tryRelease、tryAcquire等方法管理状态，管理状态使用以下三个方法：</p><ul><li>getState()  获取状态</li><li>setState()  基本设置状态</li><li>compareAndSetSate(int,int) 基于CAS实现的原子性设置状态</li></ul><h3 id="AQS节点"><a href="#AQS节点" class="headerlink" title="AQS节点"></a>AQS节点</h3><p>节点包含的状态有：</p><ol><li>CANCELLED，值为1，表示当前的线程被取消；</li><li>SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark；</li><li>CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中；</li><li>PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行；</li><li>值为0，表示当前节点在sync队列中，等待着获取锁。</li></ol><p>节点其他信息：</p><table><thead><tr><th><strong>Node prev</strong></th><th>前驱节点</th></tr></thead><tbody><tr><td><strong>Node next</strong></td><td><strong>后继节点</strong></td></tr><tr><td><strong>Node nextWaiter</strong></td><td><strong>存储condition队列中的后继节点</strong></td></tr><tr><td><strong>Thread thread</strong></td><td><strong>入队列时的当前线程</strong></td></tr></tbody></table><h2 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h2><p>锁在一个时间点只能被一个线程锁占有，AQS实现的ReentrantLock，又分为公平锁和非公平锁</p><ul><li><p>公平锁</p><p>保障了多线程下各线程获取锁的顺序，先到的线程优先获取锁</p></li><li><p>非公平锁</p><p>加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待</p></li></ul><h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><p>锁在一个时间点可以被多个线程同时获取，AQS实现的CountDownLatch、ReadWriteLock</p><h2 id="一、AQS实现ReentrantLock非公平锁"><a href="#一、AQS实现ReentrantLock非公平锁" class="headerlink" title="一、AQS实现ReentrantLock非公平锁"></a>一、AQS实现ReentrantLock非公平锁</h2><h3 id="ReentrantLock非公平锁获取锁"><a href="#ReentrantLock非公平锁获取锁" class="headerlink" title="ReentrantLock非公平锁获取锁"></a>ReentrantLock非公平锁获取锁</h3><h4 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="acquire"><a href="#acquire" class="headerlink" title="acquire()"></a>acquire()</h4><blockquote><p>根据指定状态获取，能获取到 执行compareAndSetState方法设置新状态</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="comment">//tryAcquire成功的话 acquire结束；</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            <span class="comment">//AcquireQueued方法进行阻塞等待,直到获取锁为止</span></span><br><span class="line">            <span class="comment">//addWaiter把当前线程添加到队列尾部</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            <span class="comment">//tryAcquire失败并且acquiredQueued成功的话把当前线程中断</span></span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>尝试获取锁；</li><li>如果获取不到，将当前线程构造成节点Node并加入队列；<br>addWaiter方法把节点加入队列，每个线程都是一个节点Node，从而形成了一个双向队列，类似CLH队列。</li><li>再次尝试获取，如果没有获取到那么将当前线程从线程调度器上摘下，进入等待状态。</li></ol><h4 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire()"></a>tryAcquire()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取状态</span></span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//如果该锁未被任何线程占有，该锁能被当前线程获取</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="comment">//若被获取到 查看是否被当前线程</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="comment">//是当前线程的话再次获取，计数+1</span></span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在tryAcquire方法中使用了同步器提供的对state操作的方法，利用CAS原理保证只有一个线程能够对状态进行成功修改，而没有成功修改的线程将进入队列排队。</p><h4 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued()"></a>acquireQueued()</h4><p>AcquireQueued方法进行阻塞等待,直到获取锁为止</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//node为null，排他方式阻塞等待</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//p为当前节点的前一个节点</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">//如果p为头结点并且获取成功就把当前线节点设置为头结点</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果线程需要被阻塞 则interrputr为true</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>获取当前节点的前驱节点；</li><li>当前驱节点是头结点并且能够获取状态，代表该当前节点占有锁；</li><li>否则进入等待状态。</li></ol><h4 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire()"></a>shouldParkAfterFailedAcquire()</h4><p>判断线程是否需要阻塞</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">        <span class="comment">//线程需要运行</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="comment">//ws&gt;0 处于CANCEL状态的线程</span></span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//把这些线程从队列中清除</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//把等待的设置为运行状态</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>先判断线程是否处于运行状态</li><li>如果处于CANCEL状态则把他们都从队列中清除</li><li>把当前节点下一个节点等待状态设置为准备运行</li></ol><h4 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt()"></a>parkAndCheckInterrupt()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// park方法让其他线程处于等待状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>调用阻塞线程本地方法park</li><li>返回线程是否被阻塞</li></ol><h3 id="ReentrantLock非公平锁释放锁"><a href="#ReentrantLock非公平锁释放锁" class="headerlink" title="ReentrantLock非公平锁释放锁"></a>ReentrantLock非公平锁释放锁</h3><h4 id="unlock"><a href="#unlock" class="headerlink" title="unlock()"></a>unlock()</h4><p>调用release释放一个锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//释放一个锁</span></span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="release"><a href="#release" class="headerlink" title="release()"></a>release()</h4><blockquote><p>释放锁</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="comment">//调用tryRelease尝试释放一个锁 </span></span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="comment">//释放成功后</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>调用tryRelease方法尝试释放锁，失败返回false</li><li>释放成功判断头结点不为null并且状态不为等待获取锁状态</li><li>满足条件则唤醒线程并返回true</li></ol><h4 id="tryRelease"><a href="#tryRelease" class="headerlink" title="tryRelease()"></a>tryRelease()</h4><blockquote><p>尝试释放当前锁</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="keyword">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ol><li>释放锁必需是当前线程，如果不是当前线程抛出异常</li><li>如果获取锁的线程为当前线程则判断释放后的状态是否为0，即释放前为CANCEL状态，如果是，则设置独占模式线程为null，并设置状态为0，返回true。</li></ol><h4 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor()"></a>unparkSuccessor()</h4><blockquote><p>锁释放后唤醒线程，一同竞争CPU资源</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前节点状态</span></span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">        <span class="comment">//把状态设置为等待获取锁状态</span></span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//如果没有下一个节点或者下一个节点状态为CANCEL，则把它们清除</span></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则调用LockSupport中unpark方法，唤醒后一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>获取当前节点状态</li><li>判断如果状态&lt;0，即不为等待获取锁状态，则把状态设置为等待获取锁状态</li><li>如果没有下一个节点或者下一个节点状态为CANCEL，则把它们清除</li><li>当当前节点下一个节点不为null时，调用LockSupport中unpark方法，唤醒后一个节点</li></ol><h4 id="unpark"><a href="#unpark" class="headerlink" title="unpark()"></a>unpark()</h4><blockquote><p>调用UNSAFE的本地方法unpark唤醒线程</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">            UNSAFE.unpark(thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="二、AQS实现ReentrantLock公平锁"><a href="#二、AQS实现ReentrantLock公平锁" class="headerlink" title="二、AQS实现ReentrantLock公平锁"></a>二、AQS实现ReentrantLock公平锁</h2><p>AQS实现ReentrantLock公平锁与非公平锁最大的区别在下面这段代码：</p><p><img src="/images/2.png" alt="1563697815749"></p><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">        <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">        <span class="comment">// thread is first in queue.</span></span><br><span class="line">        Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>判断”当前线程”是不是在CLH队列的队首，来实现公平性。</p></blockquote><h2 id="三、AQS实现的自定义锁"><a href="#三、AQS实现的自定义锁" class="headerlink" title="三、AQS实现的自定义锁"></a>三、AQS实现的自定义锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAQSLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAQSLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> Sync();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>,unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把lock、unlock实现使用AQS构建为内部类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span>&#123;</span><br><span class="line">        <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//第一个线程进来拿到锁</span></span><br><span class="line">            <span class="keyword">int</span> state = getState();</span><br><span class="line">            <span class="comment">//用于重入锁判断</span></span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">if</span>(state==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>,arg))&#123;</span><br><span class="line">                    setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//重入锁判断 当前线程和独占锁线程相同，则再次获取</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(current==getExclusiveOwnerThread())&#123;</span><br><span class="line">                <span class="keyword">int</span> next = state+arg;</span><br><span class="line">                <span class="keyword">if</span>(next&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">                &#125;</span><br><span class="line">                setState(next);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 可重入释放锁</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> arg</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread()!=getExclusiveOwnerThread())&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> state = getState()-arg;</span><br><span class="line">            <span class="keyword">if</span>(state==<span class="number">0</span>)&#123;</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">                setState(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试（可重入锁）"><a href="#测试（可重入锁）" class="headerlink" title="测试（可重入锁）"></a>测试（可重入锁）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAQSLock2</span> </span>&#123;</span><br><span class="line">    MyAQSLock myLock = <span class="keyword">new</span> MyAQSLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        myLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            b();</span><br><span class="line">            <span class="keyword">return</span> value++;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            myLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">        myLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(++value2);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            myLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestAQSLock2 myLock = <span class="keyword">new</span> TestAQSLock2();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + myLock.a());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      AbstractQueuedSynchronizer AQS锁原理及ReentrantLock非公平锁的实现,AbstractQueuedSynchronizer是基于一个FIFO双向链队列 CLH队列，用于构建锁或者同步装置的类，也称为Java同步器，ReentrantLock的公平锁与非公平锁就是由该同步器构成.
    
    </summary>
    
      <category term="Java并发编程" scheme="https://www.dzou.top/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="后端" scheme="https://www.dzou.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="并发编程" scheme="https://www.dzou.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="AQS" scheme="https://www.dzou.top/tags/AQS/"/>
    
      <category term="同步器" scheme="https://www.dzou.top/tags/%E5%90%8C%E6%AD%A5%E5%99%A8/"/>
    
      <category term="锁" scheme="https://www.dzou.top/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>使用宝塔面板+Nginx添加反向代理+SSL实现https 部署网站并绑定域名</title>
    <link href="https://www.dzou.top/post/7e6f0b0d.html"/>
    <id>https://www.dzou.top/post/7e6f0b0d.html</id>
    <published>2019-07-23T08:35:32.000Z</published>
    <updated>2019-08-02T11:55:53.306Z</updated>
    
    <content type="html"><![CDATA[<h2 id="icp备案"><a href="#icp备案" class="headerlink" title="icp备案"></a>icp备案</h2><p>各个服务器提供商备案</p><h2 id="公安备案"><a href="#公安备案" class="headerlink" title="公安备案"></a>公安备案</h2><p>公安网备案</p><h2 id="Springboot项目部署到服务器并绑定域名"><a href="#Springboot项目部署到服务器并绑定域名" class="headerlink" title="Springboot项目部署到服务器并绑定域名"></a>Springboot项目部署到服务器并绑定域名</h2><ol><li><p>Springboot打jar包</p></li><li><p>通过宝塔或者ftp软件上传到服务器</p></li><li><p>阿里云（腾讯云）域名解析到服务器IP ，@代表直接访问域名，www代表访问www.+域名</p></li><li><p>宝塔面板添加站点 （设置数据库、tomcat：springboot无需、ftp）</p></li><li><p>如需使用https 需添加SSL证书  并给域名添加一条txt记录进行DNS解析</p></li></ol><ol start="6"><li><p>给nginx添加反向代理conf配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include /www/server/panel/vhost/nginx/*.conf;</span><br></pre></td></tr></table></figure><p>服务器该目录新建一个应用程序的conf文件，配置以下 形成反向代理（通过域名访问ip+端口）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen <span class="number">80</span>;</span><br><span class="line">server_name api.51carry.com;</span><br><span class="line">#access_log /data/wwwlogs/api.51carry.com_nginx.log combined;</span><br><span class="line">   </span><br><span class="line">location / &#123;</span><br><span class="line">    proxy_pass http:<span class="comment">//127.0.0.1:9090; #这里的端口记得改成项目对应的哦</span></span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">    proxy_set_header X-Forwarded-Port $server_port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>服务器后台运行jar包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar lol.jar &amp; #后台部署</span><br><span class="line">ps aux|grep xxx.jar   #kill关闭进程</span><br><span class="line">cat nohup.out #查看应用日志</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      Springboot项目部署到服务器并绑定域名,服务器该目录新建一个应用程序的conf文件，配置以下 形成反向代理（通过域名访问ip+端口）
    
    </summary>
    
      <category term="网站部署" scheme="https://www.dzou.top/categories/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="后端" scheme="https://www.dzou.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="网站部署" scheme="https://www.dzou.top/tags/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2/"/>
    
      <category term="Nginx" scheme="https://www.dzou.top/tags/Nginx/"/>
    
      <category term="Https" scheme="https://www.dzou.top/tags/Https/"/>
    
      <category term="域名" scheme="https://www.dzou.top/tags/%E5%9F%9F%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>Docker基础知识以及使用Docker部署Springboot项目</title>
    <link href="https://www.dzou.top/post/6bb3246.html"/>
    <id>https://www.dzou.top/post/6bb3246.html</id>
    <published>2019-07-23T08:29:32.000Z</published>
    <updated>2019-08-02T11:47:36.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>将应用程序自动部署到容器</p><p>GO语言开发</p><p><img src="http://7xo6kd.com1.z0.glb.clouddn.com/upload-ueditor-image-20170425-1493117446353024350.jpg" alt="Docker架构"></p><h3 id="Docker使用"><a href="#Docker使用" class="headerlink" title="Docker使用"></a>Docker使用</h3><ul><li>开发、测试、部署服务</li></ul><h3 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h3><p>直接运行在操作系统之上，一直虚拟化方案</p><h3 id="虚拟机和Linux容器"><a href="#虚拟机和Linux容器" class="headerlink" title="虚拟机和Linux容器"></a>虚拟机和Linux容器</h3><p>虚拟机还需要操作系统，占用太多的内存</p><h3 id="DockerFile-构建镜像"><a href="#DockerFile-构建镜像" class="headerlink" title="DockerFile 构建镜像"></a>DockerFile 构建镜像</h3><p>Dockerfile 是一个文本文件，其内包含了一条条的 <strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><blockquote><p>docker build</p></blockquote><ol><li><p>新建一个目录并创建一个Dockfile文件</p></li><li><p>编写dockerfile配置镜像文件 （docker执行的一些命令）</p></li><li><p>使用docker build命令创建镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t nginx_test .</span><br><span class="line">.表示当前目录下</span><br></pre></td></tr></table></figure></li><li><p>执行完可以查看镜像，并运行镜像</p></li></ol><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><p>DockerHub是Docker官方提供的镜像仓库，你可以把你写的项目打包成镜像上传到Dockerhub，别人也就可以使用Docker命令运行你的镜像；当然各个官方镜像都可以在DockerHub获取并有详细使用方法。</p><h4 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h4><ul><li>docker images 镜像</li><li>docker search  搜索镜像</li><li>docker pull  下载镜像</li><li>docker rmi 镜像id 删除镜像</li></ul><h4 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h4><ul><li>docker run –name name -d image-name   -p 端口映射-d后台</li><li>docker ps 查看运行中的容器 -a</li><li>docker stop containerid 停止容器</li><li>docker rm conatinerid 删除容器</li><li>docker start containerid 启动容器</li><li>docker logs containerid 运行日志</li><li>docker exec -it containerid /bin/bash 进入容器</li></ul><h2 id="Springboot部署项目到Docker"><a href="#Springboot部署项目到Docker" class="headerlink" title="Springboot部署项目到Docker"></a>Springboot部署项目到Docker</h2><blockquote><p>使用可执行jar包构建成docker镜像</p></blockquote><ol><li><p>将jar包上传到服务器目录</p></li><li><p>同目录下编写Dockerfile文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#基于哪个镜像</span><br><span class="line">from java</span><br><span class="line">#将本地文件夹挂载到当前容器</span><br><span class="line">volume /tmp</span><br><span class="line">#复制文件到</span><br><span class="line">add jar包文件名 重命名文件名</span><br><span class="line">#声明需要暴露的端口</span><br><span class="line">expose 端口号</span><br><span class="line">#配置容器启动后执行命令</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/jar包重命名文件名&quot;]</span><br></pre></td></tr></table></figure><blockquote><p>VOLUME 指向了一个<code>/tmp</code>的目录，由于 Spring Boot 使用内置的Tomcat容器，Tomcat 默认使用<code>/tmp</code>作为工作目录。这个命令的效果是：在宿主机的<code>/var/lib/docker</code>目录下创建一个临时文件并把它链接到容器中的<code>/tmp</code>目录</p></blockquote></li><li><p>使用docker build命令构建镜像</p><blockquote><p>docker build  -t 镜像名</p></blockquote></li><li><p>使用docker run运行</p></li></ol>]]></content>
    
    <summary type="html">
    
      将应用程序自动部署到容器,DockerHub是Docker官方提供的镜像仓库，你可以把你写的项目打包成镜像上传到Dockerhub，别人也就可以使用Docker命令运行你的镜像；当然各个官方镜像都可以在DockerHub获取并有详细使用方法。
    
    </summary>
    
      <category term="网站部署" scheme="https://www.dzou.top/categories/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="Docker" scheme="https://www.dzou.top/tags/Docker/"/>
    
      <category term="分布式" scheme="https://www.dzou.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="SpringBoot" scheme="https://www.dzou.top/tags/SpringBoot/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="后端" scheme="https://www.dzou.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>牛客网算法编程题--办公室路径走法 解答</title>
    <link href="https://www.dzou.top/post/f08593ab.html"/>
    <id>https://www.dzou.top/post/f08593ab.html</id>
    <published>2019-07-23T08:29:32.000Z</published>
    <updated>2019-08-02T11:44:02.231Z</updated>
    
    <content type="html"><![CDATA[<h2 id="办公室路径走法"><a href="#办公室路径走法" class="headerlink" title="办公室路径走法"></a>办公室路径走法</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>shopee的办公室非常大，小虾同学的位置坐落在右上角，而大门却在左下角，可以把所有位置抽象为一个网格（门口的坐标为0，0），小虾同学很聪明，每次只向上，或者向右走，因为这样最容易接近目的地，但是小虾同学不想让自己的boss们看到自己经常在他们面前出没，或者迟到被发现。他决定研究一下如果他不通过boss们的位置，他可以有多少种走法？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">第一行 x,y,n (0&lt;x&lt;=30, 0&lt;y&lt;=30, 0&lt;=n&lt;= 20) 表示x,y小虾的座位坐标,n 表示boss的数量（ n &lt;= 20）</span><br><span class="line"></span><br><span class="line">接下来有n行, 表示boss们的坐标(0&lt;xi&lt;= x, 0&lt;yi&lt;=y，不会和小虾位置重合)</span><br><span class="line"></span><br><span class="line">x1, y1</span><br><span class="line"></span><br><span class="line">x2, y2</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">xn, yn</span><br></pre></td></tr></table></figure><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3 3 2</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="方法一-递归遍历-时间复杂度太高-很多点走了多次-sub-problem"><a href="#方法一-递归遍历-时间复杂度太高-很多点走了多次-sub-problem" class="headerlink" title="方法一:递归遍历(时间复杂度太高,很多点走了多次,sub-problem)"></a>方法一:递归遍历(时间复杂度太高,很多点走了多次,sub-problem)</h3><p>思路:使用自己编写的Point或者awt包下的把点封装成对象,对起始点进行递归,递归的出口为现在所在的点nowPoint为终点或者上面和右边同时存在boss,否则如果右边为空上面不为空,nowPoint往右遍历;如果右边不为空,上边为空则遍历nowPoint上边,如果都为空,对上边和右边同时遍历,最后进行计数并输出.</p><blockquote><p>但是递归时间复杂度太高,可达O(2^n^) 所以牛客网没有通过,它应该是想让我们使用dp(动态规划法)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Point endPoint;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Point&gt; bossList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String[] s = scanner.nextLine().split(<span class="string">" "</span>);</span><br><span class="line">        endPoint =  <span class="keyword">new</span> Point(Integer.parseInt(s[<span class="number">0</span>]),Integer.parseInt(s[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">int</span> numberBoss = Integer.parseInt(s[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numberBoss;i++)&#123;</span><br><span class="line">            String[] boss = scanner.nextLine().split(<span class="string">" "</span>);</span><br><span class="line">            bossList.add(<span class="keyword">new</span> Point(Integer.parseInt(boss[<span class="number">0</span>]),Integer.parseInt(boss[<span class="number">1</span>])));</span><br><span class="line">        &#125;</span><br><span class="line">        Point nowPoint = <span class="keyword">new</span> Point(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        walk(nowPoint);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">(Point nowPoint)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((nowPoint.x&lt;=endPoint.x&amp;&amp;nowPoint.y&lt;=endPoint.y)</span><br><span class="line">                &amp;&amp;!(nowPoint.x==endPoint.x&amp;&amp;nowPoint.y==endPoint.y)</span><br><span class="line">                &amp;&amp;!(existRight(nowPoint)&amp;&amp;existTop(nowPoint)))&#123;</span><br><span class="line">            <span class="keyword">if</span>(existRight(nowPoint)&amp;&amp;!existTop(nowPoint))&#123;</span><br><span class="line">                nowPoint.translate(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">                walk(nowPoint);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(existTop(nowPoint)&amp;&amp;!existRight(nowPoint))&#123;</span><br><span class="line">                nowPoint.translate(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">                walk(nowPoint);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!existRight(nowPoint)&amp;&amp;!existTop(nowPoint))&#123;</span><br><span class="line">                walk(<span class="keyword">new</span> Point(nowPoint.x+<span class="number">1</span>,nowPoint.y));</span><br><span class="line">                walk(<span class="keyword">new</span> Point(nowPoint.x,nowPoint.y+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arrive(nowPoint))&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">existRight</span><span class="params">(Point nowPoint)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bossList.contains(<span class="keyword">new</span> Point(nowPoint.x+<span class="number">1</span>,nowPoint.y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">existTop</span><span class="params">(Point nowPoint)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bossList.contains(<span class="keyword">new</span> Point(nowPoint.x,nowPoint.y+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">arrive</span><span class="params">(Point nowPoint)</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (nowPoint.x==endPoint.x&amp;&amp;nowPoint.y==endPoint.y-<span class="number">1</span>)||(nowPoint.x==endPoint.x-<span class="number">1</span>&amp;&amp;nowPoint.y==endPoint.y);</span><br><span class="line">        <span class="comment">//return nowPoint.x==endPoint.x&amp;&amp;nowPoint.y==endPoint.y;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="方法二-动态规划-把已经走过的点的值保存在数组里"><a href="#方法二-动态规划-把已经走过的点的值保存在数组里" class="headerlink" title="方法二:动态规划(把已经走过的点的值保存在数组里)"></a>方法二:动态规划(把已经走过的点的值保存在数组里)</h3><p>思路:</p><p>使用二维数组保存各点的走法,把有boss的格子赋值为-1,代表走不了,把起始位置的行和列(第0行,第0列)中没有boss的格子赋值为1,代表这些位置可以由初始位置通过一条路径到达(boss后面的除外),这里当然也可以把第一个boss前面的赋值为1;</p><p>然后遍历并计算每个格子的值(即为达到该点有几条路径),在进行路径相加时,由于我们把boss设置为了-1,所以应该在检查到boss要被加上时,把它去掉,也就是加上0(不能通过boss这个格子到达),最后得到终点的值也就是最后我们的总路径数.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String[] s = scanner.nextLine().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">long</span>[][] dp = <span class="keyword">new</span> <span class="keyword">long</span>[Integer.parseInt(s[<span class="number">0</span>])+<span class="number">1</span>][Integer.parseInt(s[<span class="number">1</span>])+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> numberBoss = Integer.parseInt(s[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numberBoss;i++)&#123;</span><br><span class="line">            String[] boss = scanner.nextLine().split(<span class="string">" "</span>);</span><br><span class="line">            dp[Integer.parseInt(boss[<span class="number">0</span>])][Integer.parseInt(boss[<span class="number">1</span>])] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(count(dp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">count</span><span class="params">(<span class="keyword">long</span>[][] dp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = dp.length;</span><br><span class="line">        <span class="keyword">int</span> j = dp[<span class="number">0</span>].length;</span><br><span class="line">       <span class="comment">// System.out.println("rows:"+i+" lines:"+j);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>;n&lt;i;n++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[n][<span class="number">0</span>]!=-<span class="number">1</span>)&#123;</span><br><span class="line">                dp[n][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>;m&lt;j;m++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[<span class="number">0</span>][m]!=-<span class="number">1</span>)&#123;</span><br><span class="line">                dp[<span class="number">0</span>][m] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">1</span>;m&lt;=i-<span class="number">1</span>;m++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">1</span>;n&lt;=j-<span class="number">1</span>;n++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[m][n]!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[m-<span class="number">1</span>][n]==-<span class="number">1</span>)&#123;</span><br><span class="line">                        dp[m][n] = dp[m][n - <span class="number">1</span>];</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[m][n-<span class="number">1</span>]==-<span class="number">1</span>)&#123;</span><br><span class="line">                        dp[m][n] = dp[m - <span class="number">1</span>][n];</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[m][n] = dp[m - <span class="number">1</span>][n] + dp[m][n - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="大家有想法和意见都可以交流-我之后还会定期更新牛客和LeetCode的算法题解法"><a href="#大家有想法和意见都可以交流-我之后还会定期更新牛客和LeetCode的算法题解法" class="headerlink" title="大家有想法和意见都可以交流,我之后还会定期更新牛客和LeetCode的算法题解法"></a>大家有想法和意见都可以交流,我之后还会定期更新牛客和LeetCode的算法题解法</h2>]]></content>
    
    <summary type="html">
    
      shopee的办公室非常大，小虾同学的位置坐落在右上角，而大门却在左下角，可以把所有位置抽象为一个网格（门口的坐标为0，0），小虾同学很聪明，每次只向上，或者向右走，因为这样最容易接近目的地，但是小虾同学不想让自己的boss们看到自己经常在他们面前出没，或者迟到被发现。
    
    </summary>
    
      <category term="算法" scheme="https://www.dzou.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="算法" scheme="https://www.dzou.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="牛客" scheme="https://www.dzou.top/tags/%E7%89%9B%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>动态规划算法基本案例</title>
    <link href="https://www.dzou.top/post/b3bf778.html"/>
    <id>https://www.dzou.top/post/b3bf778.html</id>
    <published>2019-07-23T06:29:32.000Z</published>
    <updated>2019-08-02T11:47:58.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dynamic-Programing"><a href="#Dynamic-Programing" class="headerlink" title="Dynamic Programing"></a>Dynamic Programing</h2><p>递归算法复杂度太高 可达O(2^n^) 动态规划可达O(n)</p><p>使用数组存放已经遍历过的值 下一次可以直接使用而不需要再次进行遍历</p><h3 id="exam1"><a href="#exam1" class="headerlink" title="exam1"></a>exam1</h3><p>找出给定整数数组不相邻最大和</p><p>思路:</p><p>每个值对应一个最优解,每个值对应两种情况,一种是选,则结果是它前面两个数的最优解加上它本身,另外一种是不选,结果是它前面一个元素的最优解.</p><p><img src="/images/3.png" alt="1562071409803"></p><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(opt(array,<span class="number">0</span>,array.length-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">opt</span><span class="params">(<span class="keyword">int</span>[] diguiArray,<span class="keyword">int</span> s,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s+diguiArray[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(diguiArray[<span class="number">0</span>]&gt;diguiArray[<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> opt(diguiArray,s,<span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> s+diguiArray[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> a = opt(diguiArray,s+diguiArray[i],i-<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">int</span> b = opt(diguiArray,s,i-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> Math.max(a,b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="动态规划法"><a href="#动态规划法" class="headerlink" title="动态规划法"></a>动态规划法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(dp(array,array.length-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                dp[i] = array[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i-<span class="number">1</span>]&gt;dp[i])&#123;</span><br><span class="line">                    dp[i] = dp[i-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> a = dp[i-<span class="number">2</span>]+array[i];</span><br><span class="line">                <span class="keyword">int</span> b = dp[i-<span class="number">1</span>];</span><br><span class="line">                dp[i] = Math.max(a,b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      动态规划算法
    
    </summary>
    
      <category term="算法" scheme="https://www.dzou.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="算法" scheme="https://www.dzou.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="牛客" scheme="https://www.dzou.top/tags/%E7%89%9B%E5%AE%A2/"/>
    
      <category term="动态规划" scheme="https://www.dzou.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>JDK8新特性-流Stream，Lambda表达式以及Comparator和Comparable使用</title>
    <link href="https://www.dzou.top/post/8184a8fd.html"/>
    <id>https://www.dzou.top/post/8184a8fd.html</id>
    <published>2019-06-23T08:35:32.000Z</published>
    <updated>2019-08-02T11:54:55.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lambda-Jdk8"><a href="#Lambda-Jdk8" class="headerlink" title="Lambda Jdk8"></a>Lambda Jdk8</h2><p> Lambda 是一个匿名函数，只关注参数列表和方法体,我们可以把 Lambda表达式理解为是一段可以传递的代码（将代码像数据一样进行传递)</p><p>类型推断:省略参数类型</p><h3 id="与内部类比较"><a href="#与内部类比较" class="headerlink" title="与内部类比较"></a>与内部类比较</h3><p>内部类this关键字指向内部类本身,Lambda中this指向lambda所处在的类</p><p>Java编译器将lambda表达式编译成类的私有方法。使用了Java 7的 <strong>invokedynamic</strong> 字节码指令来动态绑定这个方法。</p><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>引入了-&gt;新操作符:参数表加操作体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Parameters)-&gt;&#123;expressions&#125;</span><br></pre></td></tr></table></figure><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>类名 :: 方法名</p><h3 id="功能接口-使用要求"><a href="#功能接口-使用要求" class="headerlink" title="功能接口(使用要求)"></a>功能接口(使用要求)</h3><p>使用@FunctionalInterface注解</p><p>接口中的抽象方法只能是一个(函数式接口)</p><h4 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a><strong>Predicate</strong></h4><p>java.util.function.Predicate函数式接口,向API方法添加逻辑,非常适合做过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    List&lt;String&gt; names=Arrays.asList(<span class="string">"dx"</span>,<span class="string">"wdt"</span>,<span class="string">"zfb"</span>,<span class="string">"wuguangyao"</span>,<span class="string">"nihaoshiw"</span>));</span><br><span class="line">    Predicate&lt;String&gt; filter1 = str-&gt;str.length()&gt;<span class="number">5</span>;</span><br><span class="line">    Predicate&lt;String&gt; filter2 = str-&gt;str.endsWith(<span class="string">"yao"</span>);</span><br><span class="line">   <span class="comment">// filter(names,(n)-&gt;((String)n).startsWith("d"));</span></span><br><span class="line">    filter(names,filter2);</span><br><span class="line">    names.stream().filter(filter1.and(filter2))</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(List&lt;String&gt; list, Predicate condition)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(String str:list)&#123;</span><br><span class="line">        <span class="keyword">if</span>(condition.test(str))&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runnable t = ()-&gt; System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">        t.run();</span><br></pre></td></tr></table></figure><p>s</p><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>根接口</p><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><h4 id="implements-Comparable"><a href="#implements-Comparable" class="headerlink" title="implements Comparable"></a>implements Comparable</h4><p>实体类实现Comparable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">~~~~</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stuId.compareTo(o.getStuId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Collections-sort-List-lt-gt-new-Comparator"><a href="#Collections-sort-List-lt-gt-new-Comparator" class="headerlink" title="Collections.sort(List&lt;?&gt;,new Comparator())"></a>Collections.sort(List&lt;?&gt;,new Comparator())</h4><p>创建一个比较器实现Comparator接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;StudentNoSort&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(StudentNoSort o1, StudentNoSort o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getStuId().compareTo(o2.getStuId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p>使用Jdk8 Stream更加简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;StudentNoSort&gt; streamList = list.stream()</span><br><span class="line">                .filter(w -&gt; w.getClass()==StudentNoSort.class)</span><br><span class="line">                .sorted(((o1, o2) -&gt; o1.getStuId().compareTo(o2.getStuId())))</span><br><span class="line">                .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><hr><h2 id="Stream-1"><a href="#Stream-1" class="headerlink" title="Stream"></a>Stream</h2><p>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。</p><h3 id="Stream构成"><a href="#Stream构成" class="headerlink" title="Stream构成"></a>Stream构成</h3><p>获取一个数据源（source）→ 数据转换→执行操作(返回新的Stream对象)，这就允许对其操作可以像链条一样排列，变成一个管道</p><p><img src="/images/4.png" alt="1561548534995"></p><h4 id="Stream-Source"><a href="#Stream-Source" class="headerlink" title="Stream Source"></a>Stream Source</h4><p>集合，数组，I/O channel， 产生器generator 等</p><h4 id="Stream-Operation"><a href="#Stream-Operation" class="headerlink" title="Stream Operation"></a>Stream Operation</h4><h5 id="Intermediate"><a href="#Intermediate" class="headerlink" title="Intermediate"></a>Intermediate</h5><p>一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。</p><h6 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h6><p>创建一个List</p><h6 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h6><p>过滤器:集合进行过滤操作</p><h6 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h6><p>集合元素去重</p><h6 id="map"><a href="#map" class="headerlink" title="map"></a>map</h6><p>对函数进行操作</p><h6 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h6><p>组合元素</p><h6 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h6><p>遍历元素</p><h6 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h6><p>限定流中数据的数量</p><h6 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h6><p>排序 使用Comparator接口</p><h6 id="march-allMatch-noneMatch-anyMatch"><a href="#march-allMatch-noneMatch-anyMatch" class="headerlink" title="march,allMatch,noneMatch,anyMatch"></a>march,allMatch,noneMatch,anyMatch</h6><p>符合元素传入predicate,返回boolean</p><h6 id="还有以下"><a href="#还有以下" class="headerlink" title="还有以下"></a>还有以下</h6><p>mapToInt (转换为int), summaryStatistics(int型变量统计) ,sum(int型求和)</p><h5 id="Terminal"><a href="#Terminal" class="headerlink" title="Terminal"></a>Terminal</h5><p>一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。</p><h4 id="构造Stream"><a href="#构造Stream" class="headerlink" title="构造Stream"></a>构造Stream</h4><p>Collections</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collections</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(strArray);</span><br><span class="line">stream = list.stream();</span><br></pre></td></tr></table></figure><h3 id="example"><a href="#example" class="headerlink" title="example:"></a>example:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 12, 1, 1, 2, 3, 2, 432, 4, 32, 54, 3, 3));</span><br><span class="line">        int sum = list.stream().map(x -&gt; x * x)</span><br><span class="line">                .reduce((x, y) -&gt; x + y)</span><br><span class="line">                .get();</span><br></pre></td></tr></table></figure><h4 id="遍历文件-nio-lambda"><a href="#遍历文件-nio-lambda" class="headerlink" title="遍历文件(nio+lambda)"></a>遍历文件(nio+lambda)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Path start = FileSystems.getDefault().getPath(&quot;/home/dzou/报告/模电&quot;);</span><br><span class="line">        Files.walk(start)</span><br><span class="line">                .filter(path -&gt; path.toFile().isFile())</span><br><span class="line">                .filter(path -&gt; path.toString().endsWith(&quot;.jpg&quot;))</span><br><span class="line">                .forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数</p><h2 id="并行parallelStream"><a href="#并行parallelStream" class="headerlink" title="并行parallelStream"></a>并行parallelStream</h2><p>我们看这个代码,输出不是顺序的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">        numbers.parallelStream()</span><br><span class="line">                .forEach(out::println);</span><br></pre></td></tr></table></figure><p>底层使用ForkJoinPool,相比于ThreadPoolExecutor,可以让线程创建新的任务,并挂起当前任务,此时线程可以在队列中选择子任务执行</p>]]></content>
    
    <summary type="html">
    
      Lambda 是一个匿名函数，只关注参数列表和方法体,我们可以把 Lambda表达式理解为是一段可以传递的代码（将代码像数据一样进行传递);stream：Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="后端" scheme="https://www.dzou.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Lambda" scheme="https://www.dzou.top/tags/Lambda/"/>
    
      <category term="stream" scheme="https://www.dzou.top/tags/stream/"/>
    
  </entry>
  
</feed>
