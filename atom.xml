<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dzou&#39;s Blog</title>
  
  <subtitle>No pains,no gains.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.dzou.top/"/>
  <updated>2019-09-12T12:00:12.643Z</updated>
  <id>https://www.dzou.top/</id>
  
  <author>
    <name>dzou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot自定义参数解析器</title>
    <link href="https://www.dzou.top/post/diy-params-resolver.html"/>
    <id>https://www.dzou.top/post/diy-params-resolver.html</id>
    <published>2019-09-12T07:55:55.000Z</published>
    <updated>2019-09-12T12:00:12.643Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringBoot自定义参数解析器"><a href="#SpringBoot自定义参数解析器" class="headerlink" title="SpringBoot自定义参数解析器"></a>SpringBoot自定义参数解析器</h2><p><strong>我们都知道SpringMvc的Controller的方法上可以接收各种各样的参数，比如<code>HttpServletRequest</code>或<code>HttpServletResponse</code>，各种注解<code>@RequestParam</code>、<code>@RequestHeader</code>、<code>@RequestBody</code>、<code>@PathVariable</code>、<code>@ModelAttribute</code>，这些参数是从哪里获取的？</strong></p><blockquote><p>这些参数都是由不同的参数解析器为我们解析出来的，可以解析类也可以解析带注解的类</p></blockquote><ul><li>我们可以利用解析器解析自定义的参数(类、注解)，在我们需要的传入的controller方法上传入它(不需要每次都要在方法内部通过<code>request</code>、<code>response</code>等参数做一系列操作来获取该类对象)</li></ul><h3 id="添加解析器"><a href="#添加解析器" class="headerlink" title="添加解析器"></a>添加解析器</h3><ul><li>我们想要自定义解析参数的时候我们就需要通过更改SpringBoot的配置来添加自己实现的解析类</li></ul><p>自定义配置类实现<code>WebMvcConfigurer</code>接口，重写其中的<code>addArgumentResolvers</code>方法来添加自己的解析类(通过自动注入的方法注入)</p><pre><code class="java">@Configurationpublic class WebConfig implements WebMvcConfigurer {    @Autowired    private SecKillUserArgumentResolvers secKillUserArgumentResolvers;    @Override    public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) {        argumentResolvers.add(secKillUserArgumentResolvers);    }}</code></pre><h3 id="实现自定义解析器"><a href="#实现自定义解析器" class="headerlink" title="实现自定义解析器"></a>实现自定义解析器</h3><ul><li>我们自定义解析器需要实现<code>HandlerMethodArgumentResolver处理器方法解析器</code>接口，并实现其中的<code>supportsParameter</code>和<code>resolveArgument</code>方法</li></ul><p><code>HandlerMethodArgumentResolver</code>的接口定义如下：</p><p>（1）<code>supportsParameter</code> 用于判断是否支持对某种参数的解析(支持则返回true)</p><p>（2）<code>resolveArgument</code> 将请求中的参数值解析为某种对象(具体的操作获取解析对象)</p><p>下面这个自定义解析器用于获取User对象(通过token获取保存在redis中的user)，无需每次使用resquest和response在controller方法内部获取，可以直接获取到作为参数传入</p><pre><code class="java">/** * 自定义参数解析器 * 解析每次都要获取的user自动传入，无需每次获取 */@Componentpublic class SecKillUserArgumentResolvers implements HandlerMethodArgumentResolver {    @Autowired    private UserService userService;    @Override    public boolean supportsParameter(MethodParameter methodParameter) {        Class&lt;?&gt; c = methodParameter.getParameterType();        return c == User.class;    }    @Override    public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {        HttpServletRequest request = nativeWebRequest.getNativeRequest(HttpServletRequest.class);        HttpServletResponse response = nativeWebRequest.getNativeResponse(HttpServletResponse.class);        assert request != null;        String paramToken = request.getParameter(UserServiceImpl.COOKIE_NAME_TOKEN);//COOKIE_NAME_TOKEN=&quot;token&quot;        String cookieToken = getCookieValue(request);        if(StringUtils.isEmpty(cookieToken)&amp;&amp;StringUtils.isEmpty(paramToken)){//通过两种方式获取，如果都获取失败则返回null            return null;        }else {            String token = StringUtils.isEmpty(paramToken)?cookieToken:paramToken;            return UserService.getUserByToken(response,token);        }    }//遍历cookie获取名称相同的那个cookie的值    private String getCookieValue(HttpServletRequest request) {        Cookie[] cookies = request.getCookies();        for(Cookie cookie:cookies){            if(cookie.getName().equals(SecKillUserServiceImpl.COOKIE_NAME_TOKEN)){                return cookie.getValue();            }        }        return null;    }}</code></pre><blockquote><p>到此，一个自定义参数解析器就实现好了，我们可以通过传入参数的形式直接通过解析器帮我们获取到</p></blockquote><h3 id="解析对象的使用"><a href="#解析对象的使用" class="headerlink" title="解析对象的使用"></a>解析对象的使用</h3><ul><li>我们在controller方法中传入该参数，可以直接为我们获取到User对象</li></ul><pre><code class="java">@RequestMapping(&quot;/to_list&quot;)    public String toList(Model model,User user){    }</code></pre><h3 id="Springboot中其他参数解析器"><a href="#Springboot中其他参数解析器" class="headerlink" title="Springboot中其他参数解析器"></a>Springboot中其他参数解析器</h3><h4 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h4><ul><li>我们知道我们可以传入<code>Model</code>对象参数就可以直接使用它，我们看看它的参数解析器</li></ul><p><code>ModelAttributeMethodProcessor</code>类</p><pre><code class="java">public boolean supportsParameter(MethodParameter parameter) {        return parameter.hasParameterAnnotation(ModelAttribute.class) || this.annotationNotRequired &amp;&amp; !BeanUtils.isSimpleProperty(parameter.getParameterType());    }    @Nullable    public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {        Assert.state(mavContainer != null, &quot;ModelAttributeMethodProcessor requires ModelAndViewContainer&quot;);        Assert.state(binderFactory != null, &quot;ModelAttributeMethodProcessor requires WebDataBinderFactory&quot;);        String name = ModelFactory.getNameForParameter(parameter);        ModelAttribute ann = (ModelAttribute)parameter.getParameterAnnotation(ModelAttribute.class);        if (ann != null) {            mavContainer.setBinding(name, ann.binding());        }        Object attribute = null;        BindingResult bindingResult = null;        if (mavContainer.containsAttribute(name)) {            attribute = mavContainer.getModel().get(name);        } else {            try {                attribute = this.createAttribute(name, parameter, binderFactory, webRequest);            } catch (BindException var10) {                if (this.isBindExceptionRequired(parameter)) {                    throw var10;                }                if (parameter.getParameterType() == Optional.class) {                    attribute = Optional.empty();                }                bindingResult = var10.getBindingResult();            }        }        if (bindingResult == null) {            WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);            if (binder.getTarget() != null) {                if (!mavContainer.isBindingDisabled(name)) {                    this.bindRequestParameters(binder, webRequest);                }                this.validateIfApplicable(binder, parameter);                if (binder.getBindingResult().hasErrors() &amp;&amp; this.isBindExceptionRequired(binder, parameter)) {                    throw new BindException(binder.getBindingResult());                }            }            if (!parameter.getParameterType().isInstance(attribute)) {                attribute = binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);            }            bindingResult = binder.getBindingResult();        }        Map&lt;String, Object&gt; bindingResultModel = bindingResult.getModel();        mavContainer.removeAttributes(bindingResultModel);        mavContainer.addAllAttributes(bindingResultModel);        return attribute;    }</code></pre><h4 id="RequestParam"><a href="#RequestParam" class="headerlink" title="RequestParam"></a>RequestParam</h4><p><code>RequestParamMethodArgumentResolver</code>类，基于注解的方式</p><p>如果传入参数parameter上有该注解，则可以解析</p><pre><code class="java">public boolean supportsParameter(MethodParameter parameter) {        if (parameter.hasParameterAnnotation(RequestParam.class)) {            if (!Map.class.isAssignableFrom(parameter.nestedIfOptional().getNestedParameterType())) {                return true;            } else {                RequestParam requestParam = (RequestParam)parameter.getParameterAnnotation(RequestParam.class);                return requestParam != null &amp;&amp; StringUtils.hasText(requestParam.name());            }        } else if (parameter.hasParameterAnnotation(RequestPart.class)) {            return false;        } else {            parameter = parameter.nestedIfOptional();            if (MultipartResolutionDelegate.isMultipartArgument(parameter)) {                return true;            } else {                return this.useDefaultResolution ? BeanUtils.isSimpleProperty(parameter.getNestedParameterType()) : false;            }        }    }</code></pre><h4 id="PathVariable"><a href="#PathVariable" class="headerlink" title="PathVariable"></a>PathVariable</h4><p><code>PathVariableMethodArgumentResolver</code>类，也是基于注解，与RequestParam类似</p><pre><code class="java">public boolean supportsParameter(MethodParameter parameter) {        if (!parameter.hasParameterAnnotation(PathVariable.class)) {            return false;        } else if (!Map.class.isAssignableFrom(parameter.nestedIfOptional().getNestedParameterType())) {            return true;        } else {            PathVariable pathVariable = (PathVariable)parameter.getParameterAnnotation(PathVariable.class);            return pathVariable != null &amp;&amp; StringUtils.hasText(pathVariable.value());        }    }</code></pre><h3 id="基于注解自定义参数解析器"><a href="#基于注解自定义参数解析器" class="headerlink" title="基于注解自定义参数解析器"></a>基于注解自定义参数解析器</h3><ul><li>编写注解类，需要解析的类需要有此注解</li></ul><pre><code class="java">@Target(value = ElementType.PARAMETER)@Retention(RetentionPolicy.RUNTIME)public @interface ParamModel {}</code></pre><ul><li>实现解析器</li></ul><pre><code class="java">public class MyArgumentResolver implements HandlerMethodArgumentResolver {    @Override    public boolean supportsParameter(MethodParameter methodParameter) {        return methodParameter.hasParameterAnnotation(ParamModel.class);//带有注解就解析    }    @Override    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer container,            NativeWebRequest webRequest, WebDataBinderFactory binderFactory) {        //实现解析对象代码    }</code></pre><ul><li>配置到<code>WebMvcConfigurer</code></li></ul><pre><code class="java">@Configurationpublic class WebConfig implements WebMvcConfigurer {    @Autowired    private MyArgumentResolvers myArgumentResolvers;    @Override    public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) {        argumentResolvers.add(myArgumentResolvers);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      SpringBoot自定义参数解析器,我们可以利用解析器解析自定义的参数(类、注解)，在我们需要的传入的controller方法上传入它(不需要每次都要在方法内部通过request、response等参数做一系列操作来获取该类对象)addArgumentResolvers
    
    </summary>
    
      <category term="消息中间件" scheme="https://www.dzou.top/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="SpringBoot" scheme="https://www.dzou.top/tags/SpringBoot/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="项目" scheme="https://www.dzou.top/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>秒杀Seckill项目总结</title>
    <link href="https://www.dzou.top/post/seckill-sum.html"/>
    <id>https://www.dzou.top/post/seckill-sum.html</id>
    <published>2019-09-12T01:55:55.000Z</published>
    <updated>2019-09-12T11:36:31.656Z</updated>
    
    <content type="html"><![CDATA[<h2 id="秒杀项目总结"><a href="#秒杀项目总结" class="headerlink" title="秒杀项目总结"></a>秒杀项目总结</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>利用了两周时间完成了一个秒杀项目，这是第一次正式做项目，收获很多，下面记录一下自己的收获</strong></p><h3 id="1-关于Service层调用dao层"><a href="#1-关于Service层调用dao层" class="headerlink" title="1.关于Service层调用dao层"></a>1.关于Service层调用dao层</h3><ul><li>Service内只调自己的mapper，其他的Service  而不调其他的mapper</li></ul><blockquote><p>Service中要更新缓存，如果你调用了其他的mapper更改了，那么缓存可能不更改，缓存不一致</p></blockquote><h3 id="2-关于Dto、Vo和实体的使用"><a href="#2-关于Dto、Vo和实体的使用" class="headerlink" title="2.关于Dto、Vo和实体的使用"></a>2.关于Dto、Vo和实体的使用</h3><ul><li>Dto：数据传输对象，用于和前端交互数据的对象，可以简单理解为需要通过controller层传递给前端数据(可能是实体、vo的封装，集合或者只包括它们其中一些成员变量)</li><li>Vo：包装类对象，用于对实体类和一些分离参数的封装，使得操作只需要操作该包装对象</li><li>entity：实体对象，直接作用于dao层的对象，是数据库字段的封装</li></ul><p>例如：</p><p><strong>DTO</strong>：我需要传递给前端我在Service或者controller层操作的一些数据(非实体内部成员)，那么我们需要把它封装为Dto对象</p><p><strong>VO</strong>：像登录参数的封装就属于Vo对象，还有就是实体之间构成的一些参数封装成的对象(多个表中某些字段构成的)</p><h3 id="3-关于枚举类定义以及结果封装"><a href="#3-关于枚举类定义以及结果封装" class="headerlink" title="3.关于枚举类定义以及结果封装"></a>3.关于枚举类定义以及结果封装</h3><p><strong>我们通常需要一个枚举类定义程序的状态，它包含两个可以获取到的元素(状态码和状态信息)，为了可以获取到这两个信息，我们会声明一个状态码的接口，声明两个get方法，再让枚举类实现该接口来获取状态信息</strong></p><pre><code class="java">public interface IError {    int getCode();    String getMessage();}</code></pre><pre><code class="java">@Getter@AllArgsConstructorpublic enum ErrorCodeEnum implements IError {    /**     * 100X  用户相关错误     * //     */    PASSWORD_EMPTY(1001, &quot;密码能不为空&quot;),    MOBILE_PATTERN_WRONG(1002, &quot;手机号格式错误&quot;),    MOBILE_NOT_EXIST(1003, &quot;手机号不存在&quot;),    LOGIN_FAIL(1004, &quot;登陆失败,密码错误&quot;),    USER_NOT_EXSIT(1005, &quot;用户不存在&quot;),    NOT_LOGIN(1006,&quot;尚未登录&quot;),    /**     * 000X 公共错误     */    SUCCESS(2000, &quot;OK&quot;),    NET_ERROR(2001, &quot;网络错误&quot;),    PARAM_ERROR(2002, &quot;参数错误&quot;),    /**     * 400X 业务错误     */    SECKILL_FAIL(4001, &quot;秒杀失败，库存不足&quot;);    private int code;    private String message;}</code></pre><h4 id="结果封装"><a href="#结果封装" class="headerlink" title="结果封装"></a>结果封装</h4><p><strong>我们把数据和状态传递给前端的时候，需要把状态信息和状态码传递过去，我们前端才可以根据状态码判断需要执行的操作</strong></p><blockquote><p>该结果类需要在网路之间传输，需要进行序列化操作，最简单的序列化操作就是实现Serializable接口，定义一个全局的版本号。在该类中，包括状态码、状态信息msg、数据对象T和是否成功(成功或者错误信息)的标志</p></blockquote><pre><code class="java">@Datapublic class Result&lt;T&gt; implements Serializable {    private static final long serialVersionUID = 3956528717501837568L;    private boolean success;    private int code;    private String msg;    private T data;    public Result() {    }    public Result(boolean success, int code, String msg, T data) {        this.success = success;        this.code = code;        this.msg = msg;        this.data = data;    }    public static &lt;T&gt; Result&lt;T&gt; error(IError error) {        return error(error.getCode(), error.getMessage());    }    public static &lt;T&gt; Result&lt;T&gt; success(T data) {        return new Result&lt;T&gt;(true, ErrorCodeEnum.SUCCESS.getCode(), ErrorCodeEnum.SUCCESS.getMessage(), data);    }    public static Result&lt;String&gt; ok() {        return success(&quot;ok&quot;);    }    public static &lt;T&gt; Result&lt;T&gt; fillArgs(IError iError, Object... args) {        return error(iError.getCode(), String.format(iError.getMessage(), args));    }}</code></pre><blockquote><p>我们可以注意到最后一个<code>fillArgs</code>方法是支持枚举类错误信息中带<code>%s</code>的，可以使用<code>String.format</code>替换，这就是支持带参数传递的错误信息</p></blockquote><h3 id="4-关于注解的使用"><a href="#4-关于注解的使用" class="headerlink" title="4.关于注解的使用"></a>4.关于注解的使用</h3><h4 id="注解效验器使用"><a href="#注解效验器使用" class="headerlink" title="注解效验器使用"></a>注解效验器使用</h4><p>我在另外一篇博文中说到了参数效验器的使用，也说到自定义效验器，就是基于注解的形式，<code>用于判断前端传来的数据在服务端再进行一次效验</code>，例如：传来的手机号是否符号格式要求</p><ul><li>声明一个注解<code>@IsMobile</code></li><li>编写验证器代码(具体任何效验)，实现<code>ConstraintValidator</code>接口，重写<code>isValid</code>方法</li><li>注解标注在具体成员变量上，再在封装类上标注<code>@Valid</code>注解</li></ul><h4 id="注解实现拦截器"><a href="#注解实现拦截器" class="headerlink" title="注解实现拦截器"></a>注解实现拦截器</h4><ul><li>声明一个注解：拦截器拦截后你想实现的功能和具体的参数</li></ul><pre><code class="java">@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface AccessLimit {    int seconds();//时间范围    int maxCount();//最大尝试次数    boolean needLogin() default true;//声明是否需要登录}</code></pre><ul><li>编写拦截器，实现<code>HandlerInterceptor</code>接口，实现具体的拦截方法，重写<code>preHandler</code>方法</li><li>在配置类中注入拦截器然后再重写方法把拦截器注册到拦截器工厂，并声明要拦截的URL</li></ul><pre><code class="java">@Configurationpublic class WebConfig implements WebMvcConfigurer {    @Autowired    private LimitAccessCountInterceptor limitAccessCountInterceptor;    @Override    public void addInterceptors(InterceptorRegistry registry) {        registry.addInterceptor(limitAccessCountInterceptor).addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/login/**&quot;);    }}</code></pre><h4 id="注解mapper"><a href="#注解mapper" class="headerlink" title="注解mapper"></a>注解mapper</h4><pre><code class="java">public interface UserMapper {    @Select(&quot;select * from user where id = #{id};&quot;)    public User getById(int id);    @Insert(&quot;insert into user (name) values(#{name});&quot;)    public Boolean insert(User user);}</code></pre><h3 id="5-异常的声明以及全局异常处理器"><a href="#5-异常的声明以及全局异常处理器" class="headerlink" title="5.异常的声明以及全局异常处理器"></a>5.异常的声明以及全局异常处理器</h3><p><strong>我们一般需要为我们的应用程序创建自己的异常，再抛出异常时打印到控制台和日志，我们可以声明一个全局异常类，并通过自定义异常处理器去操作异常</strong></p><ul><li>我们通过传入状态来创建一个异常，该异常属于运行时异常，需要继承<code>RuntimeException</code></li></ul><pre><code class="java">public class GlobalException extends RuntimeException {    private IError i;    public GlobalException(IError i) {        this.i = i;    }    public IError getI() {        return i;    }}</code></pre><ul><li>编写全局异常处理器—用于Service层抛出异常</li></ul><blockquote><p>在方法上标注上@ExceptionHandler注解来拦截指定类型异常，这里我们拦截所有的异常</p><ul><li>如果是绑定异常则获取异常信息并通过参数传入结果返回</li><li>如果是我们自定义的全局异常则作为错误信息返回</li><li>如果是其他异常则返回网络错误的状态</li></ul></blockquote><pre><code class="java">@ControllerAdvice@ResponseBody@Slf4jpublic class GlobalExceptionHandler {    @ExceptionHandler(value = Exception.class)//拦截所有异常    public Result&lt;String&gt; exceptionHandler(HttpServletRequest request, Exception e) {        e.printStackTrace();        if (e instanceof BindException) {            BindException ex = (BindException) e;            List&lt;ObjectError&gt; errors = ex.getAllErrors();            String error = errors.get(0).toString();            String reg = &quot;[^\u4e00-\u9fa5]&quot;;//使用正则提取错误中的中文信息            String str = error.replaceAll(reg, &quot;&quot;);            return Result.fillArgs(ErrorCodeEnum.BIND_ERROR, str);//带参数异常        } else if (e instanceof GlobalException) {            GlobalException ex = (GlobalException) e;            return Result.error(ex.getI());        } else {            log.error(&quot;其他异常&quot;);            return Result.error(ErrorCodeEnum.NET_ERROR);        }    }}</code></pre><h3 id="6-ThreadLocal存储user"><a href="#6-ThreadLocal存储user" class="headerlink" title="6.ThreadLocal存储user"></a>6.ThreadLocal存储user</h3><p><strong>在页面中很多地方都需要用于处于登录状态才能获取并操作该页面，我们无法为每一个controller中每个方法都执行获取用户的操作，我们可以在第一次登录时把用户保存到Cookie中或者session中</strong></p><p><strong>但是当后端在很多方法中都需要用户的时候我们没办法每次都去获取，我们可以在第一次获取到时把它保存到ThreadLocal中(一个用户操作对应一个线程，所以我们可以放心保存)，需要的时候直接拿出来使用</strong></p><pre><code class="java">public class UserContext {    private static ThreadLocal&lt;User&gt; userContext = new ThreadLocal&lt;&gt;();    public static void setUserContext(User userContext) {        UserContext.userContext.set(userContext);    }    public static User getUserContext() {        return userContext.get();    }}</code></pre><blockquote><p>ThreadLocal当然可以保存很多东西，比如交易Id、票据等，当这些东西保存到数据库的话会浪费很多资源，我们可以直接放到ThreadLocal中</p></blockquote><h3 id="7-基于RabbitMQ实现商品秒杀扣减库存"><a href="#7-基于RabbitMQ实现商品秒杀扣减库存" class="headerlink" title="7.基于RabbitMQ实现商品秒杀扣减库存"></a>7.基于RabbitMQ实现商品秒杀扣减库存</h3><ul><li>初始化将库存加载到Redis</li><li>收到请求，预减库存，库存不足返回(利用Redis单线程)，已经有订单返回</li><li>成功请求入队</li><li>请求出队，生成订单；客户端轮询秒杀是否成功</li></ul><blockquote><p>这样不仅把秒杀和扣减库存解耦，还让生成订单成为了异步操作，我们只需要提交秒杀请求，而不需要等到获取到结果再返回。</p></blockquote><h3 id="8-Redis的深度使用"><a href="#8-Redis的深度使用" class="headerlink" title="8.Redis的深度使用"></a>8.Redis的深度使用</h3><h4 id="Redis根据前缀存储"><a href="#Redis根据前缀存储" class="headerlink" title="Redis根据前缀存储"></a>Redis根据前缀存储</h4><p><strong>我们使用redis存储时，通常不会考虑到不同用户不同操作不同请求的存储方式，通过这个项目我学会了使用<code>前缀</code>的方式存储数据到Redis中，不同用户根据id存储，不同操作根据方式存储，不同请求根据url存储，这样就可以区分每个<code>put</code>的key是来自哪个操作哪个请求和哪个用户，进行后台管理时也会很方便</strong></p><p><strong>最重要的一点是，我们可以通过前缀设置该<code>key</code>的过期时间</strong></p><ul><li>创建一个前缀接口</li></ul><pre><code class="java">public interface KeyPrefix {    public int expireSeconds();    public String getPrefix();}</code></pre><ul><li>创建一个抽象类实现该接口(提供一个实现模板)</li></ul><pre><code class="java">@AllArgsConstructor@RequiredArgsConstructorpublic abstract class BasePrefix implements KeyPrefix {    @NonNull    private String prefix;//前缀    private int expireSeconds;//过期时间，默认永久    @Override    public int expireSeconds() {        return expireSeconds;    }    @Override    public String getPrefix() {        String className = getClass().getSimpleName();        return className + &quot;:&quot; + prefix;    }}</code></pre><ul><li>就可以创建不同的前缀了，例如：根据用户获取方式不同的创建不同的前缀，不设置过期时间</li></ul><pre><code class="java">public class UserKey extends BasePrefix {    public UserKey(String prefix, int expireSeconds) {        super(prefix, expireSeconds);    }    public UserKey(String prefix) {        super(prefix);    }    public static UserKey getById = new UserKey(&quot;id&quot;);    public static UserKey getByName = new UserKey(&quot;name&quot;);}</code></pre><ul><li>要保存到Redis需要为RedisService实现自定义的set、get方法</li></ul><pre><code class="java"> public &lt;T&gt; boolean set(KeyPrefix prefix, String key, T value) {        Jedis jedis = null;        try {            jedis = jedisPool.getResource();            String str = beanToString(value);            if (str == null || str.length() &lt;= 0) {                return false;            }            //生成真正的key            String realKey = prefix.getPrefix() + key;            int seconds = prefix.expireSeconds();            if (seconds &lt;= 0) {                jedis.set(realKey, str);            } else {                jedis.setex(realKey, seconds, str);            }            return true;        } finally {            returnToPool(jedis);        }    }</code></pre><pre><code class="java">public &lt;T&gt; T get(KeyPrefix prefix, String key, Class&lt;T&gt; clazz) {        Jedis jedis = null;        try {            jedis = jedisPool.getResource();            //生成真正的key            String realKey = prefix.getPrefix() + key;            String str = jedis.get(realKey);            T t = stringToBean(str, clazz);            return t;        } finally {            returnToPool(jedis);        }    }</code></pre><h4 id="Redis在分布式session的使用"><a href="#Redis在分布式session的使用" class="headerlink" title="Redis在分布式session的使用"></a>Redis在分布式session的使用</h4><p><strong>在使用分布式Session的时候，我们需要把生成的token值作为key保存到redis中，依赖获取用户user对象</strong></p><pre><code class="java">private String addOrUpdateCookie(HttpServletResponse response, String token, SeckillUser user) {        if (StringUtils.isEmpty(token)) {            token = UUIDUtil.uuid();        }        redisService.set(UserKey.token, token, user);//用户前缀中的token前缀，存储时将加上“token”        Cookie cookie = new Cookie(COOKIE_NAME_TOKEN, token);        int ex = SecKillUserKey.token.expireSeconds();        cookie.setMaxAge(ex);//过期时间子在前缀中获取        cookie.setPath(&quot;/&quot;);        response.addCookie(cookie);        return token;    }</code></pre><h4 id="Redis缓存验证码结果"><a href="#Redis缓存验证码结果" class="headerlink" title="Redis缓存验证码结果"></a>Redis缓存验证码结果</h4><p><strong>我们为秒杀操作添加验证码的时候，我们需要有一个地方保存验证码的计算结果，我们选择Redis保存</strong></p><h4 id="Redis缓存页面"><a href="#Redis缓存页面" class="headerlink" title="Redis缓存页面"></a>Redis缓存页面</h4><p><strong>页面每次渲染需要很长时间，我们可以把html缓存到redis中，过期时间短一些，防止页面不刷新</strong></p><h4 id="Redis缓存库存数量"><a href="#Redis缓存库存数量" class="headerlink" title="Redis缓存库存数量"></a>Redis缓存库存数量</h4><p><strong>我们可以在加载商品信息页面的时候把商品的库存缓存到redis中，避免高并发情况下每次都去访问数据库，redis中预减库存为0后，其他线程都将直接返回秒杀失败</strong></p><h4 id="Redis缓存加密后的秒杀接口需要的参数"><a href="#Redis缓存加密后的秒杀接口需要的参数" class="headerlink" title="Redis缓存加密后的秒杀接口需要的参数"></a>Redis缓存加密后的秒杀接口需要的参数</h4><p><strong>为了防止秒杀接口被刷，我们要携带参数请求并判断参数的正确性，该参数加密后存储到redis中，需要判断的时候拿出来与前端传来的进行判断</strong></p><h3 id="9-加密"><a href="#9-加密" class="headerlink" title="9.加密"></a>9.加密</h3><h4 id="用户密码加密"><a href="#用户密码加密" class="headerlink" title="用户密码加密"></a>用户密码加密</h4><p><strong>只在前端进行加密是不行的，我们后端拿到表单密码(第一次加密后的密码)还需要在进行一次加密，在与数据库中的值进行比对，防止一次加密，前端直接获取到最终数据库中的密码</strong></p><h4 id="秒杀请求接口加密"><a href="#秒杀请求接口加密" class="headerlink" title="秒杀请求接口加密"></a>秒杀请求接口加密</h4><p><strong>防止秒杀请求接口被获取到，直接访问接口秒杀商品，我们就需要对秒杀请求传入一个必须的参数，在后端进行加密后保存到redis并返回给前端，前端拿到数据后提交给真正的秒杀请求，后端判断拿到的数据和redis存储的是否对应，不对应则请求失败</strong></p><pre><code class="java">1.前端携带id请求秒杀接口，实际上是获取秒杀路径的接口2.后端获取id加密保存到redis，并返回加密数据给前端3.前端成功获取到数据后跳转请求到真正的秒杀接口(携带后端传过来的加密数据)4.后端秒杀接口判断该参数和redis中的数据是否相等，不相等说明参数过期或者参数是错误的(伪造的)</code></pre><h3 id="10-layer-web组件使用"><a href="#10-layer-web组件使用" class="headerlink" title="10.layer web组件使用"></a>10.layer web组件使用</h3><blockquote><p>弹窗显示后端传来的结果中的msg信息</p></blockquote><h3 id="11-JMeter压测工具使用"><a href="#11-JMeter压测工具使用" class="headerlink" title="11.JMeter压测工具使用"></a>11.JMeter压测工具使用</h3><p><strong>用来压测秒杀可以承受的并发量</strong></p><p>下载地址：<a href="https://jmeter.apache.org/download_jmeter.cgi" rel="external nofollow noopener noreferrer" target="_blank">https://jmeter.apache.org/download_jmeter.cgi</a></p><p><code>bin/JMeter</code>就是可运行程序，Java GUI写的</p><ul><li>配置环境变量</li></ul><pre><code>vim /etc/profile在最后加入：export JMETER=/home/jmeter/apache-jmeter-2.13export CLASSPATH=${JMETER}/lib/ext/ApacheJMeter_core.jar:${JMETER}/lib/jorphan.jar:$JMETER/lib/logkit-2.0.jar:${CLASSPATH}export PATH=${JMETER}/bin/:${PATH}保存后，source /etc/profile 使环境变量生效。jmeter -v 确认是否配置成功。</code></pre><ul><li>在电脑中创建好测试文件<code>.jmx</code>文件，上传到服务器</li></ul><p>通过执行<code>jmeter -n -t**/路径/*.jmx -l  *.jtl</code>进行压测，得到<code>.jtl</code>结果文件，下载到电脑就可以在JMeter中打开查看了</p><h3 id="12-页面优化"><a href="#12-页面优化" class="headerlink" title="12.页面优化"></a>12.页面优化</h3><h4 id="页面缓存、URL缓存、对象缓存"><a href="#页面缓存、URL缓存、对象缓存" class="headerlink" title="页面缓存、URL缓存、对象缓存"></a>页面缓存、URL缓存、对象缓存</h4><p><strong>使用Springboot提供的Thymeleaf模板引擎获取页面html缓存到Redis中</strong></p><blockquote><p>首先我们要把前端需要的数据放到model对象中</p></blockquote><ul><li>为Controller注入Thymeleaf解析器</li></ul><pre><code class="java">@Autowired    private ThymeleafViewResolver thymeleafViewResolver;</code></pre><ul><li>在请求方法中获取WebContext</li></ul><pre><code class="java">WebContext context = new WebContext(request, response, request.getServletContext(), request.getLocale(), model.asMap());</code></pre><ul><li>通过解析器和context参数获取html</li></ul><pre><code class="java">html = thymeleafViewResolver.getTemplateEngine().process(&quot;goods_list&quot;, context);</code></pre><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><ol><li>加载页面时先查缓存，缓存有就直接获取</li><li>没有的话执行完获取操作添加到model中后</li><li>用Thymeleaf解析器解析页面并写入缓存</li></ol><pre><code class="java">@RequestMapping(value = &quot;/to_list&quot;, produces = &quot;text/html&quot;)    @ResponseBody    public String toList(HttpServletResponse response, HttpServletRequest request,                         Model model, SeckillUser user) throws IOException {        WebContext context = new WebContext(request, response, request.getServletContext(), request.getLocale(), model.asMap());        if (user == null) {            response.sendRedirect(&quot;/login/to_login&quot;);            return &quot;not login&quot;;        } else {            //查缓存            String html = redisService.get(GoodsKey.goodsList, &quot;&quot;, String.class);            if (!StringUtils.isEmpty(html)) {                return html;            }            model.addAttribute(&quot;user&quot;, user);            List&lt;GoodsVo&gt; goodsVoList = goodsService.getGoodsVoList();            log.info(&quot;goods list:{}&quot;, goodsVoList);            model.addAttribute(&quot;goodsList&quot;, goodsVoList);            /**             * 使用页面缓存             * 1.取缓存             * 2.为空则渲染写入缓存             */            html = thymeleafViewResolver.getTemplateEngine().process(&quot;goods_list&quot;, context);            redisService.set(GoodsKey.goodsList, &quot;&quot;, html);            return html;        }    }</code></pre><h4 id="页面静态化"><a href="#页面静态化" class="headerlink" title="页面静态化"></a>页面静态化</h4><p><strong>在前后端分离后，静态资源不需要从服务器端加载渲染，浏览器会帮我们缓存到客户端，当然我们也可以使用CDN等加速(有限从最近节点获取)保存静态资源</strong></p><ul><li>JS/CSS压缩</li><li>CDN加速</li><li>合并CSS/JS文件，减少连接数</li></ul><h3 id="13-唯一索引防止超卖"><a href="#13-唯一索引防止超卖" class="headerlink" title="13.唯一索引防止超卖"></a>13.唯一索引防止超卖</h3><p><strong>除了在sql中加上库存判断外，我们为了保证商品不超卖还需要添加一个唯一索引</strong></p><blockquote><p>唯一索引，即是唯一的意思，在数据库表结构中对字段(一个或者多个字段)添加唯一索引后进行数据库进行存储操作时数据库会判断库中是否已经存在此数据，不存在此数据时才能进行插入操作。</p></blockquote><p>我们建立两个字段的唯一索引：商品id和用户id</p><ul><li>创建订单时，如果存在商品id和用户id都在存在(与待创建的一样)的订单，则不能插入</li></ul><h3 id="14-秒杀限流"><a href="#14-秒杀限流" class="headerlink" title="14.秒杀限流"></a>14.秒杀限流</h3><ul><li>使用验证码减少同一时间内的请求数量</li></ul><p>使用<code>Graphics</code>画出表达式并通过<code>BufferedImage</code>生成验证码通过<code>ImageIO</code>通过write方法写到response，并使用JDK6提供的脚本支持<code>ScriptEngine</code>来调用<code>js.eval()</code>方法计算验证码不等式的值，保存到redis中，根据用户输入的去redis中比对。</p><ol><li>生成表达式</li></ol><pre><code class="java">private static char[] ops = new char[] {&#39;+&#39;, &#39;-&#39;, &#39;*&#39;};    private String generateVerifyCode(Random rdm) {        int num1 = rdm.nextInt(10);        int num2 = rdm.nextInt(10);        int num3 = rdm.nextInt(10);        char op1 = ops[rdm.nextInt(3)];        char op2 = ops[rdm.nextInt(3)];        String exp = &quot;&quot;+ num1 + op1 + num2 + op2 + num3;        return exp;    }</code></pre><ol start="2"><li>生成验证码</li></ol><pre><code class="java">int width = 80;        int height = 32;        //create the image        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);        Graphics g = image.getGraphics();        // set the background color        g.setColor(new Color(0xDCDCDC));        g.fillRect(0, 0, width, height);        // draw the border        g.setColor(Color.black);        g.drawRect(0, 0, width - 1, height - 1);        // create a random instance to generate the codes        Random rdm = new Random();        // make some confusion        for (int i = 0; i &lt; 50; i++) {            int x = rdm.nextInt(width);            int y = rdm.nextInt(height);            g.drawOval(x, y, 0, 0);        }        // generate a random code        String verifyCode = generateVerifyCode(rdm);        g.setColor(new Color(0, 100, 0));        g.setFont(new Font(&quot;Candara&quot;, Font.BOLD, 24));        g.drawString(verifyCode, 8, 24);        g.dispose();        //把验证码存到redis中        int rnd = calc(verifyCode);        redisService.set(SecKillUserKey.getVerifyCode, user.getId()+&quot;,&quot;+goodsId, rnd);        //输出图片        return image;</code></pre><ol start="2"><li>ScriptEngine调用js的eval方法</li></ol><pre><code class="java">ScriptEngineManager manager = new ScriptEngineManager();            ScriptEngine engine = manager.getEngineByName(&quot;JavaScript&quot;);            return (Integer)engine.eval(exp);//计算表达式的值并返回结果</code></pre><ul><li>使用拦截器防止用户在几秒内多次请求(防刷)</li></ul><p>把最大限制次数在第一次请求时放到redis中，之后每请求一次redis对key执行<code>decr</code>方法，&lt;0的话则返回错误信息，限制访问。</p><pre><code class="java">@Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        if (handler instanceof HandlerMethod) {            //获取用户            SeckillUser user = getUser(request, response);            //放到UserContext的ThreadLocal存储            UserContext.setUserContext(user);            log.info(&quot;把用户{}存储到ThreadLocal中&quot;,user.getId());            HandlerMethod method = (HandlerMethod) handler;            AccessLimit limit = method.getMethodAnnotation(AccessLimit.class);            if (limit == null) {                return true;            }            int seconds = limit.seconds();            int maxCount = limit.maxCount();            boolean requiredLogin = limit.needLogin();            String key = request.getRequestURI();//用于redis查找防刷商品            if (requiredLogin) {                if (user == null) {                    log.error(&quot;用户登录信息获取错误&quot;);                    sendError(ErrorCodeEnum.NOT_LOGIN, response);                    return false;                } else {                    key += &quot;_&quot; + user.getId();                }            }            //限流防刷访问            SecKillUserKey getAccessCount = SecKillUserKey.getAccessCount(seconds);            Integer count = redisService.get(getAccessCount, key, Integer.class);            if (count == null) {                redisService.set(getAccessCount, key, maxCount);            } else if (count &gt; 0) {                redisService.decr(getAccessCount, key);            } else {                log.error(&quot;操作达到上限，稍等再试&quot;);                sendError(ErrorCodeEnum.REQUEST_TOO_MUCH, response);                return false;            }            return true;        }        return true;    }</code></pre>]]></content>
    
    <summary type="html">
    
      关于Service层调用dao层，关于Dto、Vo和实体的使用，关于枚举类定义以及结果封装，关于注解的使用，异常的声明以及全局异常处理器，ThreadLocal使用，Redis深度使用，RabbitMQ使用，加密，压测JMeter，页面优化
    
    </summary>
    
      <category term="项目" scheme="https://www.dzou.top/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="项目" scheme="https://www.dzou.top/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="秒杀" scheme="https://www.dzou.top/tags/%E7%A7%92%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ理解和使用</title>
    <link href="https://www.dzou.top/post/rabbitmq.html"/>
    <id>https://www.dzou.top/post/rabbitmq.html</id>
    <published>2019-09-11T11:55:55.000Z</published>
    <updated>2019-09-12T11:55:20.436Z</updated>
    
    <content type="html"><![CDATA[<p>##　JMS—Java消息服务</p><blockquote><p>JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。</p></blockquote><p><strong>RabbitMQ客户端、ActiveMQ、Kafka、RocketMQ等都有使用JMS API实现</strong></p><p><strong>异步：</strong>订阅者或消费者可以注册为一个消息监听器。当消息到达之后，系统自动调用监听器的onMessage方法。</p><p><strong>同步：</strong>订阅者或消费者调用receive方法来接收消息，receive方法在能够接收到消息之前（或超时之前）将一直阻塞</p><h3 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h3><h4 id="点对点"><a href="#点对点" class="headerlink" title="点对点"></a>点对点</h4><p>每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/rabbitmq/7.png"><h4 id="发布者-订阅者-Pub-Sub"><a href="#发布者-订阅者-Pub-Sub" class="headerlink" title="发布者/订阅者(Pub/Sub)"></a>发布者/订阅者(Pub/Sub)</h4><p>多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。</p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/rabbitmq/8.png"><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息（Message）是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串，也可以更复杂，可能包含嵌入对象。</p><p>消息队列（Message Queue）是一种应用间的通信方式，消息发送后可以立即返回，由消息系统来确保消息的可靠传递。消息发布者只管把消息发布到 MQ 中而不用管谁来取，消息使用者只管从 MQ 中取消息而不管是谁发布的。这样发布者和使用者都不用知道对方的存在。</p><blockquote><p>从上面的描述中可以看出消息队列是一种应用间的异步协作机制，那什么时候需要使用 MQ 呢？</p><p>以常见的订单系统为例，用户点击【下单】按钮之后的业务逻辑可能包括：扣减库存、生成相应单据、发红包、发短信通知。在业务发展初期这些逻辑可能放在一起同步执行，随着业务的发展订单量增长，需要提升系统服务的性能，这时可以将一些不需要立即生效的操作拆分出来异步执行，比如发放红包、发短信通知等。这种场景下就可以用 MQ ，在下单的主流程（比如扣减库存、生成相应单据）完成之后发送一条消息到 MQ 让主流程快速完结，而由另外的单独线程拉取MQ的消息（或者由 MQ 推送消息），当发现 MQ 中有发红包或发短信之类的消息时，执行相应的业务逻辑。</p><p>以上是用于业务解耦的情况，其它常见场景包括最终一致性、广播、错峰流控等等。</p></blockquote><ul><li>秒杀业务：把扣减库存服务和生成订单服务拆分</li><li>用户注册后发送邮件和短信，无需等待发送，只需提交给RabbitMQ队列异步处理</li></ul><h2 id="RabbitMQ—基于AMQP的消息队列"><a href="#RabbitMQ—基于AMQP的消息队列" class="headerlink" title="RabbitMQ—基于AMQP的消息队列"></a>RabbitMQ—基于AMQP的消息队列</h2><blockquote><p>使用<code>ErLang</code>编写，使用<code>JMS API</code>集成,但是RabbitMQ路由过程除了消息、发送者、接受者还有<code>交换机</code>和<code>绑定者</code>的角色，决定发送到那个队列</p></blockquote><p><strong>消息中间件：分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题。</strong></p><ul><li>异步处理</li><li>应用解耦(订单服务和库存服务)</li><li>流量削峰</li><li>不需要及时得到结果的消息放到MQ中</li></ul><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/rabbitmq/1.png"><ol><li>Exchange 交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。</li><li>Binding 绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</li><li>Channel 信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内地虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</li><li>Virtual Host 虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。</li><li>Broker 表示消息队列服务器实体。</li></ol><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/rabbitmq/2.png"><h3 id="Exchange类型"><a href="#Exchange类型" class="headerlink" title="Exchange类型"></a>Exchange类型</h3><h4 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a>Direct</h4><p><strong>消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为“dog”，则只转发 routing key 标记为“dog”的消息，不会转发“dog.puppy”，也不会转发“dog.guard”等等。它是完全匹配、单播的模式.</strong></p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/rabbitmq/3.png"><h4 id="Fanout"><a href="#Fanout" class="headerlink" title="Fanout"></a>Fanout</h4><p><strong>每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。fanout 交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。</strong></p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/rabbitmq/4.png"><h4 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h4><p><strong>将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。#匹配0个或多个单词，*匹配不多不少一个单词。</strong></p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/rabbitmq/5.png"><h3 id="常用命令行操作"><a href="#常用命令行操作" class="headerlink" title="常用命令行操作"></a>常用命令行操作</h3><ul><li><p><code>sudo rabbitmq-server</code>  启动RabbitMQ</p></li><li><p><code>systemctl status rabbitmq-server.service</code> 查看RabbitMQ状态</p></li><li><p><code>sudo systemctl restart rabbitmq-server</code> 重启RabbitMQ</p></li><li><p><code>sudo rabbitmq-plugins enable rabbitmq_management</code> 启用 RabbitMQ web 管理插件 可以在 <code>15672</code>端口进入RabbitMQ后台</p></li><li><p><code>sudo rabbitmqctl stop</code> 停止RabbitMQ(关闭整个节点)</p></li><li><p><code>sudo rabbitmqctl stop_app</code> 只关闭应用程序不关闭节点 </p></li><li><p><code>sudo rabbitmqctl start_app</code>启动应用程序</p></li><li><p><code>sudo rabbitmqctl list_queues</code> 查看RabbitMQ中的队列</p></li><li><p><code>sudo rabbitmqctl list_exchanges</code>查看交换器</p></li><li><p><code>sudo rabbitmqctl list_bindings</code>查看绑定</p></li><li><p><code>sudo rabbitmqctl reset</code> 重置RabbitMQ节点(清空队列)，但是在使用此命令前，要先关闭应用，否则不能清除</p></li><li><p><code>sudo rabbitmqctl add_user  dzou 1234</code> 添加用户</p></li></ul><h3 id="rabbitmq-client"><a href="#rabbitmq-client" class="headerlink" title="rabbitmq-client"></a>rabbitmq-client</h3><ul><li>maven依赖</li></ul><pre><code class="xml">        &lt;dependency&gt;            &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;            &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;            &lt;version&gt;3.6.0&lt;/version&gt;        &lt;/dependency&gt;</code></pre><ul><li>发送者</li></ul><pre><code class="java">public class P {  private final static String QUEUE_NAME = &quot;hello&quot;;  public static void main(String[] argv) throws Exception {    ConnectionFactory factory = new ConnectionFactory();    factory.setHost(&quot;localhost&quot;);    Connection connection = factory.newConnection();    Channel channel = connection.createChannel();    channel.queueDeclare(QUEUE_NAME, false, false, false, null);    String message = &quot;Hello World!&quot;;    channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes(&quot;UTF-8&quot;));    System.out.println(&quot;P [x] Sent &#39;&quot; + message + &quot;&#39;&quot;);    channel.close();    connection.close();  }}</code></pre><ul><li>接收者</li></ul><pre><code class="java">public class C {    private final static String QUEUE_NAME = &quot;hello&quot;;    public static void main(String[] argv) throws Exception {        ConnectionFactory factory = new ConnectionFactory();        factory.setHost(&quot;localhost&quot;);        Connection connection = factory.newConnection();        Channel channel = connection.createChannel();        channel.queueDeclare(QUEUE_NAME, false, false, false, null);        System.out.println(&quot;C [*] Waiting for messages. To exit press CTRL+C&quot;);        Consumer consumer = new DefaultConsumer(channel) {            @Override            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {                String message = new String(body, &quot;UTF-8&quot;);                System.out.println(&quot;C [x] Received &#39;&quot; + message + &quot;&#39;&quot;);            }        };        channel.basicConsume(QUEUE_NAME, true, consumer);    }}</code></pre><h3 id="AmqpTemplate"><a href="#AmqpTemplate" class="headerlink" title="AmqpTemplate"></a>AmqpTemplate</h3><h5 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h5><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h5 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h5><pre><code class="yml">spring:  rabbitmq:    host: localhost    port: 5672    username: guest    password: guest    virtual-host: /    listener:      simple:        acknowledge-mode: manual # 手动应答        concurrency: 5 # 消费端最小并发数        max-concurrency: 10 # 消费端最大并发数        prefetch: 5 # 一次请求中预处理的消息数量    cache:      channel:        size: 50 # 缓存的channel数量### 自定义配置 可不需要mq:  defaultExchange: amqpExchange # 默认交换器  queue: queue # 队列名  routeKey: queue_key # 路由key</code></pre><h5 id="配置MQ队列"><a href="#配置MQ队列" class="headerlink" title="配置MQ队列"></a>配置MQ队列</h5><pre><code class="java">@Configurationpublic class MQConfig {    public static final String SECKILL_QUEUE = &quot;seckill.queue&quot;;    @Bean    public Queue secKillQueue(){        return new Queue(SECKILL_QUEUE);    }}</code></pre><h5 id="发送者"><a href="#发送者" class="headerlink" title="发送者"></a>发送者</h5><pre><code class="java">@Service@Slf4jpublic class MQSender {    @Autowired    private AmqpTemplate amqpTemplate;    @Autowired    RedisService redisService;    public void sendSeckillInfo(SecKillMessage secKillMessage) {        String msg = redisService.beanToString(secKillMessage);        log.info(&quot;send message :{}&quot;,msg);        amqpTemplate.convertAndSend(MQConfig.SECKILL_QUEUE,msg);    }    public void send(Object message){        String msg = redisService.beanToString(message);        log.info(&quot;send message :{}&quot;,msg);        amqpTemplate.convertAndSend(MQConfig.QUEUE_NAME,msg);    }    //以Topic模式发送    public void sendTopic(Object message){        String msg = redisService.beanToString(message);        log.info(&quot;send message :{}&quot;,msg);        amqpTemplate.convertAndSend(MQConfig.TOPIC_EXCHANGE_NAME,MQConfig.ROUTING_KEY1_NAME,msg);        amqpTemplate.convertAndSend(MQConfig.TOPIC_EXCHANGE_NAME,MQConfig.ROUTING_KEY_NAME,msg+&quot;17231&quot;);    }    //以fanout模式发送    public void sendFanout(Object message) {        String msg = redisService.beanToString(message);        log.info(&quot;send fanout message:&quot;+msg);        amqpTemplate.convertAndSend(MQConfig.FANOUT_EXCHANGE_NAME, &quot;&quot;, msg);    }    //以Header模式发送    public void sendHeader(Object message) throws UnsupportedEncodingException {        String msg = redisService.beanToString(message);        log.info(&quot;send header message:&quot; + msg);        MessageProperties properties = new MessageProperties();        properties.setHeader(&quot;header1&quot;, &quot;value1&quot;);        properties.setHeader(&quot;header2&quot;, &quot;value2&quot;);        Message obj = new Message(msg.getBytes(&quot;UTF-8&quot;), properties);        amqpTemplate.convertAndSend(MQConfig.HEADERS_EXCHANGE_NAME, &quot;&quot;, obj);    }}</code></pre><h5 id="接收者"><a href="#接收者" class="headerlink" title="接收者"></a>接收者</h5><pre><code class="java">@Slf4j@Service@RabbitListener(queues = MQConfig.SECKILL_QUEUE)public class MQReceive {    @Autowired    private RedisService redisService;    @Autowired    private SecKillService secKillService;    @RabbitHandler    public void receiveMsg(String message){        log.info(&quot;receive msg:{}&quot;,message);        SecKillMessage msg = redisService.stringToBean(message,SecKillMessage.class);            //处理相应的业务逻辑    }    //测试Topic模式    @RabbitListener(queues = MQConfig.TOPIC_QUEUE1_NAME)    public void receiveMsg(String message){        log.info(&quot;receive msg:{}&quot;,message);    }    @RabbitListener(queues = MQConfig.TOPIC_QUEUE2_NAME)    public void receiveMsg2(String message){        log.info(&quot;receive msg:{}&quot;,message);    }    //测试Headers模式    @RabbitListener(queues=MQConfig.HEADERS_QUEUE2_NAME)    public void receiveHeaderQueue(byte[] message) throws UnsupportedEncodingException {        log.info(&quot; header  queue message:&quot;+new String(message,&quot;UTF-8&quot;));    }}</code></pre><h5 id="String和Bean互转"><a href="#String和Bean互转" class="headerlink" title="String和Bean互转"></a>String和Bean互转</h5><blockquote><p>使用alibaba的<code>fastJson</code></p></blockquote><pre><code class="java">//bean转为字符串    public  &lt;T&gt; String beanToString(T value) {        if (value == null) {            return null;        }        Class&lt;?&gt; clazz = value.getClass();        if (clazz == int.class || clazz == Integer.class) {            return &quot;&quot; + value;        } else if (clazz == String.class) {            return (String) value;        } else if (clazz == long.class || clazz == Long.class) {            return &quot;&quot; + value;        } else {            return JSON.toJSONString(value);        }    }    //字符串转为bean    @SuppressWarnings(&quot;unchecked&quot;)    public  &lt;T&gt; T stringToBean(String str, Class&lt;T&gt; clazz) {        if (str == null || str.length() &lt;= 0 || clazz == null) {            return null;        }        if (clazz == int.class || clazz == Integer.class) {            return (T) Integer.valueOf(str);        } else if (clazz == String.class) {            return (T) str;        } else if (clazz == long.class || clazz == Long.class) {            return (T) Long.valueOf(str);        } else {            return JSON.parseObject(str, clazz);        }    }</code></pre><blockquote><p>RabbitMQ支持集群分发消息</p></blockquote><h3 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h3><p>将任务封装为消息并发给队列。在后台运行的工作者（consumer）将其取出，然后最终执行。当你运行多个工作者（consumer），队列中的任务被工作进行共享执行。</p><h3 id="轮询分发"><a href="#轮询分发" class="headerlink" title="轮询分发"></a>轮询分发</h3><p>一个生产者生产消息到队列，多个消费者从队列依次轮询消费消息。这里的轮询机制是你一个，我一个轮询分发机制，比如我有50个消息，无论C1、C2的消费处理能力如何，最后他们都会按照你一个我一个的方式都拿到25个消息消费，这就是所谓的轮询，轮着来的意思。</p><h3 id="消息应答和持久化—针对消费者"><a href="#消息应答和持久化—针对消费者" class="headerlink" title="消息应答和持久化—针对消费者"></a>消息应答和持久化—针对消费者</h3><h4 id="消息应答—ACK"><a href="#消息应答—ACK" class="headerlink" title="消息应答—ACK"></a>消息应答—ACK</h4><blockquote><p>默认情况下如果一个 Message 被消费者所正确接收则会被从 Queue 中移除</p></blockquote><blockquote><p>如果一个 Queue 没被任何消费者订阅，那么这个 Queue 中的消息会被 Cache（缓存），当有消费者订阅时则会立即发送，当 Message 被消费者正确接收时，就会被从 Queue 中移除</p></blockquote><p><strong>Message acknowledgment(消息应答)：当消息被消费者成功接收到时，就会告诉RabbitMQ你可以从队列删除该消息，我已经接收到了</strong></p><pre><code class="java">autoAck = true;//自动确认模式，当消息被接收，就从内存中删除</code></pre><p><strong>这种情况下，杀死消费者就会导致消息丢失。</strong></p><pre><code class="java">autoAck = false;//手动确认模式，如果有消息挂了，就把该消息交给其他消费者</code></pre><p><strong>这种情况下，消费者挂了不会丢失消息，但是如果服务器宕机RabbitMQ挂了，消息也会丢失。</strong></p><blockquote><p>所以我们需要使用其他机制把消息存储起来。</p></blockquote><h4 id="持久化—durable"><a href="#持久化—durable" class="headerlink" title="持久化—durable"></a>持久化—durable</h4><ul><li>声明好的队列无法更改持久化</li></ul><p><strong>默认队列和消息都是放在内存中的，当RabbitMQ退出或者崩溃，将会丢失队列和消息。为了保证即使RabbitMQ崩溃也不会丢失消息，我们必须把“队列”和“消息”设为持久化，当队列和消息持久化以后即使RabbitMQ崩溃，消息还存在磁盘中，当RabbitMQ再次启动的时候，队列和消息仍然还在。</strong></p><ul><li><strong>durable</strong>设置为true</li></ul><pre><code class="java">// 队列持久化boolean durable = true;  channel.queueDeclare(&quot;hello&quot;, durable, false, false, null); // 消息持久化 方式一channel.basicPublish(&quot;&quot;, &quot;key&quot;, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes(&quot;UTF-8&quot;));// 消息持久化 方式二AMQP.BasicProperties.Builder properties = new AMQP.BasicProperties().builder();properties.deliveryMode(2);  // 设置消息是否持久化，1： 非持久化 2：持久化channel.basicPublish(&quot;&quot;, &quot;key&quot;, properties.build(), message.getBytes(&quot;UTF-8&quot;));</code></pre><p><strong>但是消息任然可以没有保存到内存中，如果要完全100%保证写入RabbitMQ的数据必须落地磁盘，不会丢失，需要依靠其他的机制。</strong></p><h3 id="消息确认机制—针对生产者"><a href="#消息确认机制—针对生产者" class="headerlink" title="消息确认机制—针对生产者"></a>消息确认机制—针对生产者</h3><p><strong>当消息的发布者在将消息发送出去之后，消息到底有没有正确到达broker代理服务器呢？</strong></p><blockquote><p>如果到不了，那么持久化将无法使用，为此，我们还需要对生产者发送消息建立确认机制</p></blockquote><p>RabbitMQ提供两种消息确认机制：</p><ul><li>事务：通过AMQP事务机制实现</li><li>confirm：通过将channel设置成confirm模式来实现</li></ul><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p><strong>RabbitMQ中与事务机制有关的方法有三个：txSelect(), txCommit()以及txRollback(), txSelect用于将当前channel设置成transaction模式，txCommit用于提交事务，txRollback用于回滚事务，在通过txSelect开启事务之后，我们便可以发布消息给broker代理服务器了，如果txCommit提交成功了，则消息一定到达了broker了，如果在txCommit执行之前broker异常崩溃或者由于其他原因抛出异常，这个时候我们便可以捕获异常通过txRollback回滚事务了。</strong></p><pre><code class="java">channel.txSelect();//开启事务模式channel.basicPublish(ConfirmConfig.exchangeName, ConfirmConfig.routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, ConfirmConfig.msg_10B.getBytes());channel.txCommit();</code></pre><blockquote><p>只有消息成功被服务器接受，事务提交才能成功，否则我们便可以在捕获异常进行事务回滚操作同时进行消息重发，但是使用事务机制的话会降低RabbitMQ的性能,<code>下面我们还用一种更高效的方法确认消息的提交：confirm</code></p></blockquote><h4 id="confirm"><a href="#confirm" class="headerlink" title="confirm"></a>confirm</h4><p><strong>消息的确认是指生产者投递消息后，如果 Broker 代理服务器接收到消息，则会给生产者一个应答(根据一个指定的唯一id确认消息)。生产者进行接收应答，用来确认这条消息是否正常的发送到 Broker，这种方式也是消息可靠性投递的核心保障</strong></p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/rabbitmq/6.png"><ul><li>设置为confirm模式</li></ul><pre><code class="java">channel.confirmSelect();</code></pre><h5 id="confirm模式有三种："><a href="#confirm模式有三种：" class="headerlink" title="confirm模式有三种："></a>confirm模式有三种：</h5><ul><li>普通confirm模式：每发送一条消息后，调用<code>waitForConfirms()</code>方法，等待服务器端confirm。实际上是一种串行confirm。</li></ul><pre><code class="java">channel.basicPublish(ConfirmConfig.exchangeName, ConfirmConfig.routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, ConfirmConfig.msg_10B.getBytes());if(!channel.waitForConfirms()){    System.out.println(&quot;send message failed.&quot;);}</code></pre><ul><li>批量confirm模式：每发送一批消息后，调用<code>waitForConfirms()</code>方法，等待服务器端confirm。</li></ul><pre><code class="java">channel.confirmSelect();for(int i=0;i&lt;batchCount;i++){    channel.basicPublish(ConfirmConfig.exchangeName, ConfirmConfig.routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, ConfirmConfig.msg_10B.getBytes());}if(!channel.waitForConfirms()){    System.out.println(&quot;send message failed.&quot;);}</code></pre><blockquote><p>其中一个消息返回false需要消息全部重发</p></blockquote><ul><li>异步confirm模式：提供一个回调方法(监听器)，服务端confirm了一条或者多条消息后Client端会回调这个方法。</li></ul><pre><code class="java"> channel.confirmSelect();        channel.addConfirmListener(new ConfirmListener() {            //发送成功            public void handleAck(long deliveryTag, boolean multiple) throws IOException {                //成功进入这，根据业务实现            }            //发送失败            public void handleNack(long deliveryTag, boolean multiple) throws IOException {                System.out.println(&quot;Nack, SeqNo: &quot; + deliveryTag + &quot;, multiple: &quot; + multiple);                //失败进入这，根据业务实现            }        });        while (true) {            long nextSeqNo = channel.getNextPublishSeqNo();            channel.basicPublish(ConfirmConfig.exchangeName, ConfirmConfig.routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, ConfirmConfig.msg_10B.getBytes());            confirmSet.add(nextSeqNo);        }</code></pre><p>参考博文：</p><p><a href="https://juejin.im/post/5a67f7836fb9a01cb74e8931" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/post/5a67f7836fb9a01cb74e8931</a></p><p><a href="https://segmentfault.com/a/1190000017130224" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000017130224</a></p><p>安装参考：</p><p><a href="https://blog.csdn.net/nextyu/article/details/79250174#commentBox" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/nextyu/article/details/79250174#commentBox</a></p>]]></content>
    
    <summary type="html">
    
      RabbitMQ—基于AMQP的消息队列.JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。消息中间件：分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题。
    
    </summary>
    
      <category term="消息中间件" scheme="https://www.dzou.top/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="项目" scheme="https://www.dzou.top/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="消息队列" scheme="https://www.dzou.top/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="JMS" scheme="https://www.dzou.top/tags/JMS/"/>
    
      <category term="消息中间件" scheme="https://www.dzou.top/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot读取配置文件的方法</title>
    <link href="https://www.dzou.top/post/read-config-springboot.html"/>
    <id>https://www.dzou.top/post/read-config-springboot.html</id>
    <published>2019-09-11T07:55:55.000Z</published>
    <updated>2019-09-12T11:57:51.354Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>推荐两种方法</p><ul><li>@Value注解 <code>org.springframework.beans.factory.annotation.Value</code></li><li>@ConfigurationProperties注解 <code>org.springframework.boot.context.properties.ConfigurationProperties</code></li></ul></blockquote><h3 id="Value注解"><a href="#Value注解" class="headerlink" title="@Value注解"></a>@Value注解</h3><ul><li>需要声明为<code>Component</code>，在需要的的地方可以直接注入并使用<code>getter</code>方法获取</li></ul><p>下面以redis配置为例</p><pre><code class="java">@Data@Componentpublic class RedisConfig {    @Value(&quot;${redis.host}&quot;)    private String host;    @Value(&quot;${redis.port}&quot;)    private int port;    @Value(&quot;${redis.timeout}&quot;)    private int timeout;//秒    @Value(&quot;${redis.password}&quot;)    private String password;    @Value(&quot;${redis.pool-max-active}&quot;)    private int poolMaxActive;    @Value(&quot;${redis.pool-max-idle}&quot;)    private int poolMaxIdle;    @Value(&quot;${redis.pool-max-wait}&quot;)    private int poolMaxWait;//秒}</code></pre><ul><li>在yml配置文件中写入</li></ul><pre><code class="yml">redis:  host: 127.0.0.1  port: 6379  timeout: 100  password: ××××  pool-max-active: 2000  pool-max-idle: 10  pool-max-wait: 10000</code></pre><ul><li>在需要的地方自动注入并获取值，例如redispool连接池</li></ul><pre><code class="java">public class RedisPoolFactory {    @Autowired    RedisConfig redisConfig;    @Bean    public JedisPool JedisPoolFactory() {        JedisPoolConfig poolConfig = new JedisPoolConfig();        poolConfig.setMaxIdle(redisConfig.getPoolMaxIdle());        poolConfig.setMaxTotal(redisConfig.getPoolMaxActive());        poolConfig.setMaxWaitMillis(redisConfig.getPoolMaxWait() * 1000);        JedisPool jp = new JedisPool(poolConfig, redisConfig.getHost(), redisConfig.getPort(),                redisConfig.getTimeout(), redisConfig.getPassword(), 0);        return jp;    }}</code></pre><h3 id="ConfigurationProperties注解"><a href="#ConfigurationProperties注解" class="headerlink" title="@ConfigurationProperties注解"></a>@ConfigurationProperties注解</h3><blockquote><p>也需要注上Component被扫描到 通过<code>prefix</code>前缀的方式获取配置文件<code>properties</code>或者<code>yml</code>的值</p></blockquote><ul><li>yml如下：</li></ul><pre><code class="yml">info:   name: dx   tel: 1271286123   add: China   # list结构   recipients[0]: admin@mail.com   recipients[1]: owner@mail.com   # Map结构   hobby:       sports: basketball       music: gentle</code></pre><ul><li>配置文件获取类如下</li></ul><pre><code class="java">@Data@Component@ConfigurationProperties(prefix = &quot;info&quot;)public class RedisConfig {    private String name;    private String tel;    private String add;    Map&lt;String,String&gt; hobby;    List&lt;String&gt; recipients;}</code></pre><h3 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h3><ul><li>当然，两种方法都可以指定配置文件的路径，通过<code>@PropertySource</code>注解，注到获取配置信息类上</li></ul><pre><code class="java">@PropertySource(&quot;classpath:application.properties&quot;)</code></pre>]]></content>
    
    <summary type="html">
    
      Springboot读取配置文件方式，@Value注解，@ConfigurationProperties注解 ，@PropertySource
    
    </summary>
    
      <category term="消息中间件" scheme="https://www.dzou.top/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="SpringBoot" scheme="https://www.dzou.top/tags/SpringBoot/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="项目" scheme="https://www.dzou.top/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>JSR参数效验以及自定义参数效验器</title>
    <link href="https://www.dzou.top/post/params-valid.html"/>
    <id>https://www.dzou.top/post/params-valid.html</id>
    <published>2019-09-11T02:55:55.000Z</published>
    <updated>2019-09-12T11:52:02.939Z</updated>
    
    <content type="html"><![CDATA[<p><strong>我们在写Controller或者Service时经常在方法中写入大量的数据校验代码，如下</strong></p><pre><code class="java">       if(StringUtils.isEmpty(pass)){            return Result.error(ErrorCodeEnum.PASSWORD_EMPTY);        }else if(!ValidatorUtil.isMobile(mobile)){            return Result.error(ErrorCodeEnum.MOBILE_PATTERN_WRONG);        }</code></pre><p><strong>不仅浪费时间，还让业务逻辑代码更复杂，下面我们使用JSR303为我们提供的校验工具避免过多的代码校验</strong></p><h2 id="JSR303"><a href="#JSR303" class="headerlink" title="JSR303"></a>JSR303</h2><blockquote><p>JSR 303 – Bean Validation 是一个数据验证的规范，不符合规范的将返回一条具体的信息说明该规范的错误</p></blockquote><ul><li>有以下注解为我们提供校验</li></ul><pre><code class="java">@Null    被注释的元素必须为 null@NotNull    被注释的元素必须不为 null@AssertTrue    被注释的元素必须为 true@AssertFalse    被注释的元素必须为 false@Min(value)    被注释的元素必须是一个数字，其值必须大于等于指定的最小值@Max(value)    被注释的元素必须是一个数字，其值必须小于等于指定的最大值@DecimalMin(value)    被注释的元素必须是一个数字，其值必须大于等于指定的最小值@DecimalMax(value)    被注释的元素必须是一个数字，其值必须小于等于指定的最大值@Size(max, min)    被注释的元素的大小必须在指定的范围内@Digits (integer, fraction)    被注释的元素必须是一个数字，其值必须在可接受的范围内@Past    被注释的元素必须是一个过去的日期@Future    被注释的元素必须是一个将来的日期@Pattern(value)    被注释的元素必须符合指定的正则表达式</code></pre><ul><li>例如：一个封装的登录信息类<code>LoginVo</code></li></ul><pre><code class="java">@Datapublic class LoginVo {    @NotNull    @Length(max = 11,min = 11)    private String mobile;//手机号    @NotNull    @Length(min = 32)    private String password;//密码}</code></pre><blockquote><p>我们使用@NotNull注解为该字段声明为非空，也就是前端传过来的该参数必须有具体的值，不能为null</p><p>@Length注解为字段声明字符串最长最短的临界条件，前端传来的数据必须符合要求</p></blockquote><ul><li>最后我们在使用到登录封装类的地方(如Controller参数)打上<code>@Valid</code>注解，就会帮我们的封装类进行校验</li></ul><pre><code class="java">public Result doLogin( @Valid LoginVo loginVo)</code></pre><h3 id="自定义验证器"><a href="#自定义验证器" class="headerlink" title="自定义验证器"></a>自定义验证器</h3><blockquote><p>为了深入了解JSR303，我们将实现一个自定义验证器(自定义注解实现具体的验证代码)，观察它是如何工作的</p></blockquote><ul><li><p>现在我们需要为登录信息类里的<code>mobile</code>字段进行手机号校验(校验是否为手机号，格式错误返回格式错误信息)</p></li><li><p>我们将其声明为<code>@IsMobile</code>注解</p></li></ul><p><strong>通过观察上述众多注解，发现验证器的一般代码如下</strong></p><ul><li>validatedBy：就是要传入一个具体的自定义验证器类(实现验证器逻辑)</li><li>message方法：这里返回具体的校验失败的错误信息</li></ul><pre><code class="java">@Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})@Retention(RetentionPolicy.RUNTIME)@Repeatable(IsMobile.List.class)@Documented@Constraint(        validatedBy = {MobileValidator.class}//这里的validatedBy就是要传入一个具体的自定义验证器类(实现验证器逻辑))public @interface IsMobile {    boolean required() default true;//可以使用该字段声明是否必须    String message() default &quot;手机号格式不合法&quot;;//这里返回具体的校验失败的错误信息    Class&lt;?&gt;[] groups() default {};    Class&lt;? extends Payload&gt;[] payload() default {};    @Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})    @Retention(RetentionPolicy.RUNTIME)    @Documented    public @interface List {        IsMobile[] value();    }}</code></pre><ul><li><p>所以我们需要编写一个类实现验证器逻辑<code>MobileValidator</code></p><blockquote><p>验证器需要实现<code>ConstraintValidator</code>接口，该接口用泛型指定两个参数</p><ul><li>&lt;A extends Annotation, T&gt;</li><li>第一个参数A：就是自定义注解的类</li><li>T就是具体需要校验的值的类型</li></ul></blockquote></li></ul><p><strong>重写其中的<code>isValid</code>方法</strong></p><pre><code class="java">public class MobileValidator implements ConstraintValidator&lt;IsMobile, String&gt; {    private boolean required = true;    @Override    public void initialize(IsMobile constraintAnnotation) {    }    @Override    public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) {        if(required){//如果必须 说明以传入  则进行效验            return ValidatorUtil.isMobile(s);        }else {//如果不必须 说明可以没有 先判断是否为空再校验            if (StringUtils.isEmpty(s)) {                return false;            } else return ValidatorUtil.isMobile(s);        }    }}</code></pre><ul><li>ValidatorUtil 工具类 用户验证</li></ul><pre><code class="java">public class ValidatorUtil {    //使用正则匹配1开头的11位数字    private static final Pattern mobile_pattern = Pattern.compile(&quot;1\\d{10}&quot;);//如果匹配返回true，手机号格式正确    public static boolean isMobile(String s){        if(StringUtils.isEmpty(s)){            return false;        }        Matcher m = mobile_pattern.matcher(s);        return m.matches();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      JSR 303 – Bean Validation 是一个数据验证的规范，不符合规范的将返回一条具体的信息说明该规范的错误，我们使用@NotNull注解为该字段声明为非空，也就是前端传过来的该参数必须有具体的值，不能为null，为了深入了解JSR303，我们将实现一个自定义验证器(自定义注解实现具体的验证代码)，观察它是如何工作的
    
    </summary>
    
      <category term="Java Web" scheme="https://www.dzou.top/categories/Java-Web/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="参数效验" scheme="https://www.dzou.top/tags/%E5%8F%82%E6%95%B0%E6%95%88%E9%AA%8C/"/>
    
      <category term="JSR" scheme="https://www.dzou.top/tags/JSR/"/>
    
      <category term="项目" scheme="https://www.dzou.top/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>分布式session的几种实现</title>
    <link href="https://www.dzou.top/post/distributed-session.html"/>
    <id>https://www.dzou.top/post/distributed-session.html</id>
    <published>2019-09-11T01:55:55.000Z</published>
    <updated>2019-09-12T11:58:18.296Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SpringBoot-分布式session"><a href="#SpringBoot-分布式session" class="headerlink" title="SpringBoot 分布式session"></a>SpringBoot 分布式session</h3><blockquote><p>在如今服务器集群的情况下，用户登录会话状态的保存也从单机的变成了分布式要求的，下面详细说一下几种分布式session存储方案。</p></blockquote><ol><li><p>session复制：在支持session复制的服务器上进行，同步session，保持session一致</p><p>方案：<code>tomcat-redis-session-manager</code></p></li><li><p>session粘滞：强行分发session到各个服务器</p><p>方案：负载均衡</p></li><li><p>cookie存储session：把sessionid存储到cookie中(不安全，cookie容易被盗取，可以存储不重要的数据)</p></li><li><p>session集中管理：把用户的session存储在单台或者集群服务器的缓存中，所有web服务器从中拿取session，实现session共享</p><p>方案：Redis存储用户生成的sessionId或者存储保存sessionId的cookie</p></li></ol><blockquote><p>这里只讲解第四种方案，使用最多最稳定</p></blockquote><h3 id="Redis做缓存持久化存储session"><a href="#Redis做缓存持久化存储session" class="headerlink" title="Redis做缓存持久化存储session"></a>Redis做缓存持久化存储session</h3><h4 id="Redis存储cookie，里面保存用户生成的uuid-token作为sessionId"><a href="#Redis存储cookie，里面保存用户生成的uuid-token作为sessionId" class="headerlink" title="Redis存储cookie，里面保存用户生成的uuid(token作为sessionId)"></a>Redis存储cookie，里面保存用户生成的uuid(token作为sessionId)</h4><ul><li>cookie名称和过期时间</li></ul><pre><code class="java">public static final String COOKIE_NAME_TOKEN = &quot;token&quot;;private static final ex  = 3600;</code></pre><ul><li>创建cookie并存储到redis</li></ul><pre><code class="java">private String addCookie(HttpServletResponse response,SeckillUser user){        String token = UUIDUtil.uuid();        redisService.set(token,user);//使用redis把token作为键存储user作为值 我使用jedis自己实现的也可以使用redisTemplate        Cookie cookie = new Cookie(COOKIE_NAME_TOKEN, token);//设置cookie 名称为token        cookie.setMaxAge(ex);//设置过期时间         cookie.setPath(&quot;/&quot;);        response.addCookie(cookie);        return token;    }</code></pre><ul><li>uuid作为sessionid生成工具</li></ul><pre><code class="java">public class UUIDUtil {    public static String uuid(){        return UUID.randomUUID().toString();    }}</code></pre><h4 id="使用Shiro集成的crazy-cake-使用Redis存储SessionId"><a href="#使用Shiro集成的crazy-cake-使用Redis存储SessionId" class="headerlink" title="使用Shiro集成的crazy-cake(使用Redis存储SessionId)"></a>使用Shiro集成的<code>crazy-cake</code>(使用Redis存储SessionId)</h4><ul><li>shiro是一个Web安全框架，用于登录认证，用户身份授权，使用易于<code>spring-security</code>，还可以继承session、cookie分布式存储</li></ul><p>不了解的可以看这篇博文：<a href="https://www.dzou.top/post/712f837.html">Shiro的使用以及集成redis做缓存</a></p><h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><ul><li><strong>使用缓存存储session（单服务器使用EhCacheManager）</strong></li><li><strong>但是在分布式系统中，服务器集群情况下，EhCacheManager无法解决数据共享（会多次查询数据库），则选择使用redis作为缓存</strong></li></ul><h5 id="Redis实现shiro缓存"><a href="#Redis实现shiro缓存" class="headerlink" title="Redis实现shiro缓存"></a>Redis实现shiro缓存</h5><ul><li><p><strong>分布式共享session和授权信息需要把session和授权持久化到数据库或者缓存 shiro集群为了防止多次插查询数据库</strong></p></li><li><p><strong>自定义实现类:或者使用crazycake开源shiro-redis实现好的工具</strong></p><ul><li><strong>RedisSessionDAO</strong> 可以继承EnterpriseCacheSessionDAO实现session控制</li><li><strong>RedisCache</strong> 继承Cache类实现具体redis操作缓存（remove、get、set、keys</li><li><strong>RedisCacheManager</strong> 实现接口CacheManager的getCache获得RedisCache交给securityManager管理</li></ul><p><strong>使用了ConcurrentMap管理数据和缓存，更加高效</strong></p></li></ul><ol><li>在<code>ShiroConfig</code>配置类中把<code>sessionManager</code>交给<code>DefaultWebSecurityManager</code>管理</li></ol><pre><code class="java">@Bean    public DefaultWebSessionManager sessionManager(){        DefaultWebSessionManager sessionManager  = new DefaultWebSessionManager();        //session时间        sessionManager.setGlobalSessionTimeout(redisConfig().getTimeout());        //删除无效session        sessionManager.setDeleteInvalidSessions(true);        log.info(&quot;sessionManager注入成功&quot;);        sessionManager.setSessionIdCookie(cookie());        // sessionDao 分布式共享session和授权信息需要把session和授权持久化到数据库或者缓存 shiro集群为了防止多次插查询数据库        sessionManager.setSessionDAO(redisSessionDao());        return sessionManager;    }</code></pre><ol start="2"><li>在<code>sessionManager</code>中注入cookie存储<code>jsessionId</code></li></ol><pre><code class="java">@Bean    public SimpleCookie cookie() {        SimpleCookie cookie = new SimpleCookie(&quot;JSESSIONID&quot;);        cookie.setHttpOnly(true);        cookie.setPath(&quot;/&quot;);        return cookie;    }</code></pre><ol start="3"><li>再在<code>sessionManager</code>中注入<code>redisSessionDao</code>负责session持久化</li></ol><pre><code class="java">@Bean    public RedisSessionDAO redisSessionDao(){        RedisSessionDAO redisSessionDAO = new RedisSessionDAO();        redisSessionDAO.setRedisManager(redisManager());        redisSessionDAO.setSessionIdGenerator(sessionIdGenerator());        return redisSessionDAO;    }</code></pre>]]></content>
    
    <summary type="html">
    
      分布式session.session复制：在支持session复制的服务器上进行，同步session，保持session一致.session集中管理：把用户的session存储在单台或者集群服务器的缓存中，所有web服务器从中拿取session，实现session共享
    
    </summary>
    
      <category term="Java Web" scheme="https://www.dzou.top/categories/Java-Web/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="SpringBoot" scheme="https://www.dzou.top/tags/SpringBoot/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="项目" scheme="https://www.dzou.top/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="Redis" scheme="https://www.dzou.top/tags/Redis/"/>
    
      <category term="秒杀" scheme="https://www.dzou.top/tags/%E7%A7%92%E6%9D%80/"/>
    
      <category term="分布式session" scheme="https://www.dzou.top/tags/%E5%88%86%E5%B8%83%E5%BC%8Fsession/"/>
    
      <category term="shiro" scheme="https://www.dzou.top/tags/shiro/"/>
    
  </entry>
  
  <entry>
    <title>前后端两次MD5加密设计</title>
    <link href="https://www.dzou.top/post/md5-encryption.html"/>
    <id>https://www.dzou.top/post/md5-encryption.html</id>
    <published>2019-09-11T01:55:55.000Z</published>
    <updated>2019-09-12T11:58:27.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MD5加密设计"><a href="#MD5加密设计" class="headerlink" title="MD5加密设计"></a>MD5加密设计</h2><blockquote><p>前端后端分别进行一次<code>md5+salt</code>加密</p></blockquote><h3 id="前端加密"><a href="#前端加密" class="headerlink" title="前端加密"></a>前端加密</h3><blockquote><p>为了防止密码明文在http上传输，则需要在前端进行一次md5+salt加密</p></blockquote><ul><li>使用<code>JQuery</code> md5</li></ul><p>前端JQuery md5工具：<a href="https://github.com/emn178/js-md5" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/emn178/js-md5</a></p><ul><li>在前端js中声明一个固定盐salt</li></ul><pre><code class="js">//saltvar g_passsword_salt=&quot;ewn576ifa12&quot;;</code></pre><ul><li>登录js方法中加密调用<code>ajax</code></li></ul><blockquote><p>这里使用<code>layer</code> Web组件，进行ajax消息弹窗</p></blockquote><pre><code class="js">function doLogin(){    var inputPass = $(&quot;#password&quot;).val();    var salt = g_passsword_salt;    //使用盐中5位组合md5加密    var str = &quot;&quot;+salt.charAt(0) + salt.charAt(2) + salt.charAt(5) + inputPass + salt.charAt(7) + salt.charAt(8);    var password = md5(str);    //使用第一次加密的密码进行ajax传输    $.ajax({        url: &quot;/login/do_login&quot;,        type: &quot;POST&quot;,        data:{            mobile:$(&quot;#mobile&quot;).val(),            password: password        },        //成功回调函数        success:function(data){            layer.closeAll();            if(data.code == 2000){                layer.msg(&quot;成功&quot;);                window.location.href=&quot;/goods/to_list&quot;;            }else{                layer.msg(data.msg);            }        },        //失败回调函数        error:function(){            layer.closeAll();        }    });}</code></pre><h3 id="后端加密存储"><a href="#后端加密存储" class="headerlink" title="后端加密存储"></a>后端加密存储</h3><blockquote><p>后端将拿到第一次md5加密的结果，这个密码就是表单提交上来的密码，我们需要在后端编写第二道md5加密方式来加密表单传来的密码后再与数据库存储的两次md5加密的密码进行比较，相同才能登陆成功</p></blockquote><ul><li>第二次加密作用：因为第一次前端加密的密码有可能被窃取的，也可能解析我们的js看到我们前端加密方式，可以直接得到明文密码，所以我们需要第二次后端加密再存储，这样即使前端密码被拿到了后端的也不符合。</li></ul><p><strong>我们将后端使用同样的方式(也可以用不同的方式)再次加密，盐值salt需要相等，用于注册时，后端进行计算出与前端第一次加密匹配的密码。</strong></p><ul><li>依赖：Apache-commons-codec</li></ul><pre><code class="xml">&lt;dependency&gt;            &lt;groupId&gt;commons-codec&lt;/groupId&gt;            &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;            &lt;version&gt;1.9&lt;/version&gt;        &lt;/dependency&gt;</code></pre><ul><li>MD5Util 类</li></ul><pre><code class="java">public class MD5Util {    public static String md5(String t){        return DigestUtils.md5Hex(t);    }    private static final String salt = &quot;ewn576ifa12&quot;;//前端输入的密码到表单提交的密码(第一次加密) 用于校验前端传入的密码与该方法返回的密码是否相等    public static String inputPassToFormPass(String pass){        String s = &quot;&quot; + salt.charAt(0) + salt.charAt(2) + salt.charAt(5) + pass + salt.charAt(7) + salt.charAt(8);        return md5(s);    }//表单提交的密码(第一次加密的密码)到数据库存储的密码(第二次加密)    public static String formPassToDb(String formPass,String salt){        String s = &quot;&quot; + salt.charAt(0) + salt.charAt(2) + salt.charAt(5) + formPass + salt.charAt(7) + salt.charAt(8);        return md5(s);    }//前端输入的明文密码到数据库存储的密码 可用于注册    public static String inputPassToDbPass(String input,String salt){        String form = inputPassToFormPass(input);        return formPassToDb(form,salt);    }}</code></pre><ul><li>登录业务代码</li></ul><pre><code class="java">public boolean login(HttpServletResponse response,String mobile, String formPass) {    //根据手机号获取User用户对象        User user = UserMapper.getById(Long.parseLong(mobile));        if(user==null){            throw new GlobalException(ErrorCodeEnum.MOBILE_NOT_EXIST);//抛出自定义异常        }        String dbPass = user.getPassword();//获取数据库的第二次加密的密码        String dbSalt = user.getSalt();//获取后端存储的盐        String calPass = MD5Util.formPassToDb(formPass,dbSalt);//根据前端表单传来的密码计算出第二次加密结果        if(!calPass.equals(dbPass)){//如果不相等            log.error(&quot;{}登录密码错误&quot;,mobile);            throw new GlobalException(ErrorCodeEnum.LOGIN_FAIL);        }        return true;    }</code></pre>]]></content>
    
    <summary type="html">
    
      前端后端分别进行一次md5+salt加密，为了防止密码明文在http上传输，则需要在前端进行一次md5+salt加密，后端将拿到第一次md5加密的结果，这个密码就是表单提交上来的密码，我们需要在后端编写第二道md5加密方式来加密表单传来的密码后再与数据库存储的两次md5加密的密码进行比较，相同才能登陆成功
    
    </summary>
    
      <category term="Java Web" scheme="https://www.dzou.top/categories/Java-Web/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="SpringBoot" scheme="https://www.dzou.top/tags/SpringBoot/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="项目" scheme="https://www.dzou.top/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="加密" scheme="https://www.dzou.top/tags/%E5%8A%A0%E5%AF%86/"/>
    
      <category term="MD5" scheme="https://www.dzou.top/tags/MD5/"/>
    
  </entry>
  
  <entry>
    <title>牛客网算法编程题 剑指offer—数值的整数次方 解答</title>
    <link href="https://www.dzou.top/post/quick-mi-numm.html"/>
    <id>https://www.dzou.top/post/quick-mi-numm.html</id>
    <published>2019-09-09T08:29:32.000Z</published>
    <updated>2019-09-12T10:58:59.918Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer—数值的整数次方"><a href="#剑指offer—数值的整数次方" class="headerlink" title="剑指offer—数值的整数次方"></a>剑指offer—数值的整数次方</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><p>保证base和exponent不同时为0</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>这题首先考虑到循环遍历数值的大小次，计算出结果，<code>但是还有比这更优的方法：快速幂</code></p></blockquote><h4 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h4><blockquote><p>快速幂就是快速算底数的n次幂。其时间复杂度为 O(log₂N)，比O(N)更快</p></blockquote><p>例如</p><p><img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D103/sign=885b42e39c16fdfadc6cc2ee878d8cea/d0c8a786c9177f3e48bd45c571cf3bc79e3d5668.jpg" alt="img"></p><p>11的二进制是1011</p><p><img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D247/sign=2a9c504edfc8a786ba2a4d0a5008c9c7/aa18972bd40735fae94ebe0d90510fb30e2408c3.jpg" alt="img"></p><p>因此，我们将a¹¹转化为算</p><p><img src="https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D95/sign=257afe75a8773912c0268964f919a226/e850352ac65c1038803a760ab3119313b17e89b6.jpg" alt="img"></p><ul><li><strong>快速幂可以帮助我们使用二进制快速计算幂函数和指数函数</strong></li></ul><blockquote><p>在正数情况下，我们每次对指数右移，只要它对应二进制位为<code>1</code>，我们就需要乘上a的2的n次方(n为二进制所在位数)，我们可以利用右移每次对一个duoble变量累乘，只要当前位为<code>1</code>就乘上该变量，否则就一直累乘该变量，直到为1的位数，或者指数为0时结束循环。</p></blockquote><p>我们需要用到的：</p><ul><li>判断二进制当前位(最右边一位)是否为1</li></ul><pre><code class="java">(e&amp;1)==1</code></pre><ul><li>每次循环右移</li></ul><pre><code class="java">e&gt;&gt;=1  或者   e=e&gt;&gt;1</code></pre><blockquote><p>当然我们需要考虑到指数为负数的情况，我们知道负数的指数函数为正数的倒数，所以如果为负数我们把它取负保存到一个变量(变为正数进行计算)，最后输出结果时判断该指数为负数的话则输出倒数，反之输出结果。</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="java">public class Solution {    public double Power(double base, int exp) {        int e = exp;//存储正数的指数        double res = 1;//存储结果        double count = base;//原来存储累乘变量        if(exp==0){//指数为0返回1            return 1;        }else if(exp&lt;1){//小于1取负保存到e中            e = -exp;        }        while(e!=0){//循环计算            if((e&amp;1)==1){                res *= count;//利用快速幂，如果当前位为1则相乘            }            count *= base;//累乘操作            e&gt;&gt;=1;//右移        }        return exp&lt;0?1/res:res;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      剑指offer—数值的整数次方.给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。
    
    </summary>
    
      <category term="算法" scheme="https://www.dzou.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="算法" scheme="https://www.dzou.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="牛客" scheme="https://www.dzou.top/tags/%E7%89%9B%E5%AE%A2/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="剑指offer" scheme="https://www.dzou.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="笔试" scheme="https://www.dzou.top/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>牛客网算法编程题 剑指offer—链表倒数第k个节点 解答</title>
    <link href="https://www.dzou.top/post/last-kth-node-linedlist.html"/>
    <id>https://www.dzou.top/post/last-kth-node-linedlist.html</id>
    <published>2019-09-08T08:29:32.000Z</published>
    <updated>2019-09-12T10:57:38.182Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer—链表倒数第k个节点"><a href="#剑指offer—链表倒数第k个节点" class="headerlink" title="剑指offer—链表倒数第k个节点"></a>剑指offer—链表倒数第k个节点</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，输出该链表中倒数第k个结点。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>单向链表只能从前往后获取，而无法从后往前获取</p></blockquote><ul><li>方法1：首先我们可以想到的就是遍历一次链表存储链表长度<code>l</code>，然后再进行一次<code>l-k</code>的循环，获得第k个节点</li></ul><blockquote><p>但是该方法耗费时间太多，时间复杂度大，我们想想有没有一种方法只需要遍历一次就可以获得结果</p></blockquote><ul><li>方法2：我们使用两个指针，第一个指针在循环<code>前k次</code>指向后面一个节点，此时第一个指针指向第<code>k</code>个节点，此时开始两个指针移动，直到第一个指针移动到链表末尾，这个时候第二个指针指向的节点就是倒数第<code>k</code>个节点</li></ul><blockquote><p>这种方法就是使用一点点空间换取了大量的时间，使用一个辅助节点来判断第二个节点需要移动到的位置</p></blockquote><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/algorithm/8.png"><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li>基础版本</li></ul><pre><code class="java">/*public class ListNode {    int val;    ListNode next = null;    ListNode(int val) {        this.val = val;    }}*/public class Solution {    public ListNode FindKthToTail(ListNode head,int k) {        if(head == null||k == 0){            return null;        }        ListNode node = head;        ListNode kThFlag = head;        while(kThFlag.next!=null){            if(k-1&gt;0){                k--;                kThFlag = kThFlag.next;            }else{                kThFlag = kThFlag.next;                node = node.next;            }        }        if(k&gt;=2){            return null;        }        return node;    }}</code></pre><blockquote><p>看起来很复杂，优化一下，慢慢写出漂亮的代码</p></blockquote><ul><li>简化后</li></ul><pre><code class="java">public ListNode FindKthToTail(ListNode head,int k) {        if(head == null||k == 0)            return null;        ListNode q,p;        q = p = head;        while(q.next!=null){            if(--k&gt;0){                q = q.next;            }else{                q = q.next;                p = p.next;            }        }        return k&gt;=2?null:p;    }</code></pre><h3 id="扩展—删除链表的倒数第N个节点"><a href="#扩展—删除链表的倒数第N个节点" class="headerlink" title="扩展—删除链表的倒数第N个节点"></a>扩展—删除链表的倒数第N个节点</h3><ul><li>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</li></ul><pre><code>示例：给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.说明：给定的 n 保证是有效的。</code></pre><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>根据上面一题思路，但是这里要拿到的是删除节点的前一个节点，执行删除<code>node.next=node.next.next</code></li><li>根据这样的思考，既然拿到删除节点的前一个节点，就要考虑<code>删除节点前一个节点是否为null</code>(不存在，删除节点为头结点)，想到了使用变量<code>i</code>来存储节点数量(每次循环+1)和<code>m</code>存储倒数节点数n的值<ul><li>如果<code>i=m</code>说明要删除头结点，我们需要进行单独操作把头结点指向后面一个节点</li><li>如果<code>i&gt;m</code>说明删除节点n是有效的，在链表范围内，就执行<code>node.next=node.next.next</code>操作</li></ul></li></ul><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre><code class="java">class Solution {    //拿到第n-1个节点    public ListNode removeNthFromEnd(ListNode head, int n) {        ListNode q,h;        q = h = head;        int i = 1;int m = n;        while(q.next!=null){            if(n--&gt;0){                q = q.next;            }else{                q = q.next;                head = head.next;            }            i++;        }        if(i&gt;m){            head.next = n&gt;=1||q==head?null:head.next.next;//n&gt;=1用来判断n是否有效(在链表范围内)；因为n每次减一，如果循环结束了n还不为0则说明n是无效的数(无法删除该节点)        }else if(i==m){            h = h.next;        }        return h;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      剑指offer—链表倒数第k个节点.输入一个链表，输出该链表中倒数第k个结点。
    
    </summary>
    
      <category term="算法" scheme="https://www.dzou.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="算法" scheme="https://www.dzou.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="牛客" scheme="https://www.dzou.top/tags/%E7%89%9B%E5%AE%A2/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="剑指offer" scheme="https://www.dzou.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="笔试" scheme="https://www.dzou.top/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>牛客网算法编程题 剑指offer—合并两个有序链表 解答</title>
    <link href="https://www.dzou.top/post/combine-two-sorted-linkedlist.html"/>
    <id>https://www.dzou.top/post/combine-two-sorted-linkedlist.html</id>
    <published>2019-09-07T08:29:32.000Z</published>
    <updated>2019-09-12T10:56:41.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer—合并两个有序链表"><a href="#剑指offer—合并两个有序链表" class="headerlink" title="剑指offer—合并两个有序链表"></a>剑指offer—合并两个有序链表</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>我们考虑到最优实现，时间复杂度应该为两个链表长度O(M+N)，空间复杂度为O(1)，只使用几个指针，类似归并排序思想</p></blockquote><ul><li>先从第一个链表开始迭代，如果链表1当前指针的值&lt;链表2当前指针的值则链表1指针往后移动一位，反之如果链表1当前指针的值&gt;=链表2的值，则执行插入到链表1当前指针前面一个位置，基本代码如下：<code>pre</code>指向链表1当前节点的前一个节点，用于插入</li></ul><pre><code class="java">ListNode next = list2.next;//保存链表2的下一个节点指针pre.next = list2;//pre指向新插入节点list2.next = list1;//新插入节点指向链表1当前节点pre = list2;//更新pre到pre的下一个节点也就是新插入的节点list2 = next;//更新链表2当前节点为下一个节点(保存的引用在这里使用)</code></pre><ul><li>当链表1为空或者链表2为空时，结束迭代，剩下的非空链表的所有元素都大于新链表所有元素，直接<code>接入</code>到新链表后面就可以了，代码如下</li></ul><pre><code class="java">if(list1==null&amp;&amp;list2!=null){//如果有一个不为空则执行连接链表操作    list1 = list2;    pre.next = list1;}    </code></pre><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/algorithm/11.png"><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="java">public class Solution {    public ListNode Merge(ListNode list1,ListNode list2) {        if(list1==null||list2==null){            return list2==null?list1:list2;        }        ListNode head1,head2,pre;        head1 = list1;head2 = list2;pre = null;        while(list1!=null&amp;&amp;list2!=null){            if(list1.val&gt;=list2.val){                //把list2放过来                ListNode next = list2.next;                if(pre!=null){                    pre.next = list2;                }                list2.next = list1;                pre = list2;                list2 = next;            }else{                list1 = list1.next;                if(pre == null){                    pre = head1;                }else{                    pre = pre.next;                }            }        }        if(list1==null&amp;&amp;list2!=null){            list1 = list2;            pre.next = list1;        }        return head2.val&lt;=head1.val?head2:head1;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      剑指offer—合并两个有序链表.输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。
    
    </summary>
    
      <category term="算法" scheme="https://www.dzou.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="算法" scheme="https://www.dzou.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="牛客" scheme="https://www.dzou.top/tags/%E7%89%9B%E5%AE%A2/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="剑指offer" scheme="https://www.dzou.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="笔试" scheme="https://www.dzou.top/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>牛客网算法编程题 剑指offer—斐波那契数列 解答</title>
    <link href="https://www.dzou.top/post/fib-array.html"/>
    <id>https://www.dzou.top/post/fib-array.html</id>
    <published>2019-09-06T08:29:32.000Z</published>
    <updated>2019-09-12T10:55:55.930Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer—斐波那契数列"><a href="#剑指offer—斐波那契数列" class="headerlink" title="剑指offer—斐波那契数列"></a>剑指offer—斐波那契数列</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p><strong>斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。</strong>也就是：</p><pre><code class="java">F(0) = 0,   F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.给定 N，计算 F(N)。示例 1：输入：2输出：1解释：F(2) = F(1) + F(0) = 1 + 0 = 1.示例 2：输入：3输出：2解释：F(3) = F(2) + F(1) = 1 + 1 = 2.示例 3：输入：4输出：3解释：F(4) = F(3) + F(2) = 2 + 1 = 3.</code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题有三种方法，依次优化</p><ul><li>递归</li><li>动态规划：使用数组存储每个位置的值</li><li>优化版本动态规划：不使用数组存储每个位置的值，而用两个变量分别存储<code>前一个pre</code>和前前一个<code>prepre</code>的值，在循环中计算前一个与后一个相加再把值重新赋给这两个变量</li></ul><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><pre><code class="java">public class Solution {    public int Fibonacci(int n) {        if(n == 0){            return 0;        }else if(n == 1){            return 1;        }else{            return Fibonacci(n-1) + Fibonacci(n-2);        }    }}</code></pre><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p><strong>使用数组存储计算过的值，需要的时候再拿出来，典型的动态规划</strong></p><pre><code class="java">public class Solution {    public int Fibonacci(int n) {        if(n==0){            return 0;        }else if(n==1){            return 1;        }        int [] dp = new int[n+1];//用该数组存储计算过的值        for(int i=0;i&lt;n+1;i++){            if(i==0){                dp[i] = 0;            }else if(i==1){                dp[i] = 1;            }else{                dp[i] = dp[i-2]+dp[i-1];            }        }        return dp[n];    }}</code></pre><h3 id="更优化的动态规划"><a href="#更优化的动态规划" class="headerlink" title="更优化的动态规划"></a>更优化的动态规划</h3><p><strong>不使用数组存储每个位置的值，而用两个变量分别存储<code>前一个pre</code>和前前一个<code>prepre</code>的值，在循环中计算前一个与后一个相加再把值重新赋给这两个变量</strong></p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/algorithm/5.png"><pre><code class="java">public class Solution {    public int Fibonacci(int n) {        if(n==0){            return 0;        }else if(n&lt;=2){            return 1;        }else{            int pre = 1;//前一个数值            int prepre = 1;//前前一个数值            for(int i=3;i&lt;n+1;i++){                int temp = pre + prepre;//计算当前数值                prepre = pre;//给前前一个赋值为前一个                pre = temp;//给前一个赋值为当前            }            return pre;//循环结束返回前一个数值        }    }}</code></pre><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><h4 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h4><ul><li>题目描述</li></ul><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><ul><li>递归</li></ul><pre><code class="java">public class Solution {    public int JumpFloor(int target) {        if(target&lt;=1){            return 1;        }else{            return JumpFloor(target-1)+JumpFloor(target-2);        }    }}</code></pre><ul><li>优化的循环</li></ul><pre><code class="java">class Solution {    public int climbStairs(int n) {        if(n&lt;=2){            return n;        }else{            int pre = 2;//前一个数值            int prepre = 1;//前前一个数值            for(int i=3;i&lt;n+1;i++){                int temp = pre + prepre;//计算当前数值                prepre = pre;//给前前一个赋值为前一个                pre = temp;//给前一个赋值为当前            }            return pre;//循环结束返回前一个数值        }    }}</code></pre><h4 id="变态跳台阶"><a href="#变态跳台阶" class="headerlink" title="变态跳台阶"></a>变态跳台阶</h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><ol><li>找规律</li><li>台阶可以看成存在或者不存在两种情况，要跳上第n个台阶则第n个台阶一定存在，前n-1个台阶可以存在或者不存在，所以一共有2的n-1次方中情况</li></ol><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">public class Solution {    public int JumpFloorII(int n) {        return 1&lt;&lt;(n-1);    }}</code></pre><h4 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/algorithm/6.png"><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><pre><code class="java">public class Solution {    public int RectCover(int target) {        if(target&lt;=2){            return target;        }else{            return RectCover(target-1)+RectCover(target-2);        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      剑指offer—斐波那契数列.斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。
    
    </summary>
    
      <category term="算法" scheme="https://www.dzou.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="算法" scheme="https://www.dzou.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="牛客" scheme="https://www.dzou.top/tags/%E7%89%9B%E5%AE%A2/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="剑指offer" scheme="https://www.dzou.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="笔试" scheme="https://www.dzou.top/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>牛客网算法编程题 剑指offer—反转链表 解答</title>
    <link href="https://www.dzou.top/post/reverse-linked-list.html"/>
    <id>https://www.dzou.top/post/reverse-linked-list.html</id>
    <published>2019-09-05T08:29:32.000Z</published>
    <updated>2019-09-12T10:55:18.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer—反转链表"><a href="#剑指offer—反转链表" class="headerlink" title="剑指offer—反转链表"></a>剑指offer—反转链表</h2><h3 id="反转链表一"><a href="#反转链表一" class="headerlink" title="反转链表一"></a>反转链表一</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个链表，反转链表后，输出新链表的表头。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>方法一：使用辅助空间遍历链表并保存，再次循环翻转插入链表</li></ul><blockquote><p>时间复杂度和空间复杂度都较大，不推荐使用</p></blockquote><ul><li><strong>方法二：迭代一次链表，用指针保存前一个和后一个的引用，然后通过迭代反转链表指向</strong></li></ul><blockquote><p>时间复杂度O(N)，空间复杂度O(1)，我们就使用该方法</p></blockquote><h4 id="执行翻转一个节点的关键代码"><a href="#执行翻转一个节点的关键代码" class="headerlink" title="执行翻转一个节点的关键代码"></a>执行翻转一个节点的关键代码</h4><p>在看具体算法之前，有必要先弄清楚链接反转的原理以及需要哪些指针。举例而言，有一个三个不同结点组成的链表 <code>A → B → C</code>，需要反转结点中的链接成为 <code>A ← B ← C</code>。</p><p>假设我们有两个指针，一个指向结点<code>A</code>，一个指向结点<code>B</code>。 分别记为 <code>pre</code> 和 <code>head</code>。则可以用这两个指针简单地实现 A 和 B 之间的链接反转：</p><pre><code class="java">ListNode node = head.next;//保存下一个节点的引用(用于把head往后移动)head.next = pre;//把head next节点指向前驱节点pre = head;//把pre移动到head节点上head = node;//把head节点移动到下一个节点上</code></pre><blockquote><p>只需要迭代执行该过程，整个链表就被翻转了</p></blockquote><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/algorithm/9.png"><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code class="java">/*public class ListNode {    int val;    ListNode next = null;    ListNode(int val) {        this.val = val;    }}*/public class Solution {    public ListNode ReverseList(ListNode head) {        ListNode pre = null;        while(head!=null){            ListNode node = head.next;            head.next = pre;            pre = head;            head = node;        }        return pre;    }}</code></pre><h3 id="反转链表二"><a href="#反转链表二" class="headerlink" title="反转链表二"></a>反转链表二</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p><p>说明:<br>1 ≤ m ≤ n ≤ 链表长度。</p><pre><code>示例:输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code></pre><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><blockquote><p>根据要求只循环一次，那就只能使用第一题的思想，当然可以使用O(1)的辅助空间</p></blockquote><ul><li><p>反转节点还是使用上面的思想，只是我们需要在反转节点结束后把m前面和n后面的节点调整到正确的位置</p></li><li><p>注意我们要引入两个额外指针，分别称为 <code>startPre</code> 和 <code>startNext</code>。<code>startNext</code> 指针指向从链表头起的第<code>m</code>个结点，此结点是反转后链表的尾部。<code>startPre</code> 指针指向第 <code>m</code> 个结点的前一个结点，此结点是新链表的头部。</p></li></ul><ul><li>两个指针都已经到达最终位置。我们完成了子链表的反转工作。然而，还有一些链接需要调整。下图展示了利用 <code>startPre</code> 和 <code>startNext</code> 指针完成链接调整的过程。</li></ul><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/algorithm/10.png"><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public ListNode reverseBetween(ListNode head, int m, int n) {        if(head==null){            return null;        }        ListNode h,pre,startPre,startNext;        h = startNext = head; pre = null; startPre = new ListNode(0);//startPre初始化，为空的话无法调整位置        int i = 1;        while(i&lt;=n+1){//前n次翻转，第n+1次调整m、n外面的节点位置            if(i&lt;=m){                pre = head;                head = head.next;                if(i&lt;m){                    startPre = pre;//保存startPre位置                    startNext = startNext.next;//保存startNext位置                }            }else if(i&lt;=n){//开始翻转                ListNode node = head.next;                head.next = pre;                pre = head;                head = node;            }else{//调整位置                startPre.next = pre;//指向开始反转的前一个节点，这个节点就是新的反转链表的前面一个节点                startNext.next = head;//指向开始反转的第一个节点，反转结束需要与链表末尾连接            }            i++;        }        return m==1?pre:h;//当m==1时，第一个节点就被反转，pre节点就是反转链表的头结点，否则h保存的head节点就是头结点        // if(head==null){        //     return null;        // }        // final ListNode h = head;        // ListNode pre = null;        // ListNode startPre = new ListNode(0);        // ListNode startNext = head;        // int i = 1;        // while(head!=null){        //     if(i&lt;m){        //         pre = head;        //         head = head.next;        //         if(i&lt;m){        //             // startPre = pre;        //             startNext = startNext.next;        //         }else if(i==m){        //             startPre = pre;        //         }        //     }else if(i&lt;=n){        //         final ListNode node = head.next;        //         head.next = pre;        //         startPre.next = head;        //         pre = head;        //         head = node;        //     }else{        //         startNext.next = head;        //         head = head.next;        //     }        //     i++;        // }        // return h;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      剑指offer—反转链表.输入一个链表，反转链表后，输出新链表的表头。
    
    </summary>
    
      <category term="算法" scheme="https://www.dzou.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="算法" scheme="https://www.dzou.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="牛客" scheme="https://www.dzou.top/tags/%E7%89%9B%E5%AE%A2/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="剑指offer" scheme="https://www.dzou.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="笔试" scheme="https://www.dzou.top/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>牛客网算法编程题 剑指offer—二进制数中的1的个数 解答</title>
    <link href="https://www.dzou.top/post/binary-one-counts.html"/>
    <id>https://www.dzou.top/post/binary-one-counts.html</id>
    <published>2019-09-04T08:29:32.000Z</published>
    <updated>2019-09-12T10:54:27.515Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer—二进制数中的1的个数"><a href="#剑指offer—二进制数中的1的个数" class="headerlink" title="剑指offer—二进制数中的1的个数"></a>剑指offer—二进制数中的1的个数</h2><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>依次无符号右移判断最右位是否为1，为1累加，当右移至0后结束循环</strong></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="需要循环二进制位数"><a href="#需要循环二进制位数" class="headerlink" title="需要循环二进制位数"></a>需要循环二进制位数</h4><pre><code class="java">public class Solution {    public int NumberOf1(int n) {        int m = 0;        /*计算机负数存储的是补码        if(n&lt;0){            n = ~n + 1;        }*/        while(n!=0){            if((n&amp;1)!=0){                m++;            }            n = n&gt;&gt;&gt;1;        }        return m;    }}</code></pre><h4 id="只需要循环1的个数次循环"><a href="#只需要循环1的个数次循环" class="headerlink" title="只需要循环1的个数次循环"></a>只需要循环1的个数次循环</h4><blockquote><p>优化后方法：一个数减去1的话，它的<code>最后一个二进制1位</code>将由<code>1</code>变为<code>0</code>，它后面的数本来都为0，将由<code>0</code>全部变为<code>1</code>，相当于最后一个<code>1位</code>到最后的二进制取反了，再把它<code>与上自己原来的值(减一之前)</code>则就是把从<code>最后一个1位</code>到最后全变为0，此时最后一个<code>1位</code>将为原数倒数第二个<code>1位</code></p><p>例子：</p><p>10110</p><p>减一后：</p><p>10101</p><p>与上10110后：</p><p>10100</p><p>循环遍历次数就是1的个数</p></blockquote><pre><code class="java">public class Solution {    public int NumberOf1(int n) {        int m = 0;        while(n!=0){            m++;            n = (n-1)&amp;n;        }        return m;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      剑指offer—二进制数中的1的个数.输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
    
    </summary>
    
      <category term="算法" scheme="https://www.dzou.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="算法" scheme="https://www.dzou.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="牛客" scheme="https://www.dzou.top/tags/%E7%89%9B%E5%AE%A2/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="剑指offer" scheme="https://www.dzou.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="笔试" scheme="https://www.dzou.top/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>牛客网算法编程题 剑指offer—二叉树的子树 解答</title>
    <link href="https://www.dzou.top/post/son-of-binarytree.html"/>
    <id>https://www.dzou.top/post/son-of-binarytree.html</id>
    <published>2019-09-03T08:29:32.000Z</published>
    <updated>2019-09-12T10:53:38.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer—二叉树的子树"><a href="#剑指offer—二叉树的子树" class="headerlink" title="剑指offer—二叉树的子树"></a>剑指offer—二叉树的子树</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><pre><code class="java">示例 2:给定的树 s：     3    / \   4   5  / \ 1   2    /   0给定的树 t：   4  / \ 1   2返回 true</code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p><code>s</code>树为需要查找的树，<code>t</code>树为判断是否存在的子树</p></blockquote><p>分为两步骤：</p><ol><li><strong>找到和<code>t</code>树根节点元素相等的<code>s</code>树中的节点</strong></li><li><strong>判断该节点下面的子树是否符合<code>t</code>树的结构和值</strong></li></ol><p>首先我们可以用<code>递归</code>找到元素值<code>相等</code>的节点，找到后执行判断是否为子树，如果为<code>false</code>，接着往该节点左边找，还为<code>false</code>往右边找，最后遍历完<code>s</code>树返回结果</p><p><strong>判断是否为子树：</strong></p><ul><li>先判断t节点是否为空，为空说明<code>s</code>中包含该t子树，返回true</li><li>再判断<code>s</code>是否为空，这是在t不为空的基础上，则说明不包含t子树，返回false</li><li>如果<code>s、t</code>都不为空，判断两值是否相等，不相等返回false</li><li>如果相等再使用递归判断它们的左子数和右子树是否为子树</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="java">/**public class TreeNode {    int val = 0;    TreeNode left = null;    TreeNode right = null;    public TreeNode(int val) {        this.val = val;    }}*/public class Solution {    public boolean HasSubtree(TreeNode s,TreeNode t) {        boolean result = false;        if(s!=null&amp;&amp;t!=null){//s和t都不为空            if(s.val==t.val){//找到了相等元素                //判断s下面的结构有没有t                result = isEquals(s,t);            }            if(!result){//如果没有找到或者找到的不满足子树要求，再找左节点                result = HasSubtree(s.left,t);            }            if(!result){//如果没有找到或者找到的不满足子树要求，再找右节点                result = HasSubtree(s.right,t);            }        }        return result;    }    //判断是否为子树    public boolean isEquals(TreeNode s,TreeNode t){        if(t==null){//为null说明包含            return true;        }        if(s==null){//t不为null s为null说明不包含            return false;        }        if(s.val!=t.val){//不相等说明不包含            return false;        }        return isEquals(s.left,t.left)&amp;&amp;isEquals(s.right,t.right);//相等则判断左节点和有节点是否满足    }}</code></pre><h3 id="扩展—LeetCode572"><a href="#扩展—LeetCode572" class="headerlink" title="扩展—LeetCode572"></a>扩展—LeetCode572</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p><pre><code class="java">示例 2:给定的树 s：     3    / \   4   5  / \ 1   2    /   0给定的树 t：   4  / \ 1   2返回 false。</code></pre><blockquote><p>当s子树和t不完全相同时(有多余元素)，则返回false</p></blockquote><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>只需要更改判断<code>子树</code>条件即可</li></ul><ol><li>如果s或者t其中只有一个为null，说明子树不完全相同，返回false</li><li>如果同时为null说明完全相同，返回true</li><li>如果值不相同，返回false</li></ol><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre><code class="java">class Solution {    public boolean isSubtree(TreeNode s, TreeNode t) {        boolean result = false;        if(s!=null&amp;&amp;t!=null){            if(s.val==t.val){                //判断s下面的结构有没有t                result = isEquals(s,t);            }            if(!result){                result = isSubtree(s.left,t);            }            if(!result){                result = isSubtree(s.right,t);            }        }        return result;    }    public boolean isEquals(TreeNode s,TreeNode t){        if((t==null&amp;&amp;s!=null)||(t!=null&amp;&amp;s==null)){            return false;        }        if(s==null&amp;&amp;t==null){            return true;        }        if(s.val!=t.val){            return false;        }else{            return isEquals(s.left,t.left)&amp;&amp;isEquals(s.right,t.right);        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      剑指offer—二叉树的子树.输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
    
    </summary>
    
      <category term="算法" scheme="https://www.dzou.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="算法" scheme="https://www.dzou.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="牛客" scheme="https://www.dzou.top/tags/%E7%89%9B%E5%AE%A2/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="剑指offer" scheme="https://www.dzou.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="笔试" scheme="https://www.dzou.top/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>牛客网算法编程题 剑指offer—二叉树的镜像 解答</title>
    <link href="https://www.dzou.top/post/binary-tree-mirror.html"/>
    <id>https://www.dzou.top/post/binary-tree-mirror.html</id>
    <published>2019-09-02T08:29:32.000Z</published>
    <updated>2019-09-12T10:53:12.424Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer—二叉树的镜像"><a href="#剑指offer—二叉树的镜像" class="headerlink" title="剑指offer—二叉树的镜像"></a>剑指offer—二叉树的镜像</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h4><pre><code>二叉树的镜像定义：源二叉树             8           /  \          6   10         / \  / \        5  7 9 11        镜像二叉树            8           /  \          10   6         / \  / \        11 9 7  5</code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>我们可以分析一下对称的规律，可以发现<code>该二叉树的每个节点都交换了它的左儿子和右儿子</code>，由此我们可以递归交换它的节点</strong></p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/algorithm/11.png"><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="java">/**public class TreeNode {    int val = 0;    TreeNode left = null;    TreeNode right = null;    public TreeNode(int val) {        this.val = val;    }}*/public class Solution {    public void Mirror(TreeNode root) {        if(root==null){            return;        }        if(root.left==null&amp;&amp;root.right==null){            return;        }        //swap        TreeNode temp = root.right;        root.right = root.left;        root.left = temp;        Mirror(root.left);        Mirror(root.right);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      二叉树的镜像.操作给定的二叉树，将其变换为源二叉树的镜像。
    
    </summary>
    
      <category term="算法" scheme="https://www.dzou.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="算法" scheme="https://www.dzou.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="牛客" scheme="https://www.dzou.top/tags/%E7%89%9B%E5%AE%A2/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="剑指offer" scheme="https://www.dzou.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="笔试" scheme="https://www.dzou.top/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>牛客网算法编程题 剑指offer—调整数组使得奇数在偶数前面 解答</title>
    <link href="https://www.dzou.top/post/change-array-odd-front.html"/>
    <id>https://www.dzou.top/post/change-array-odd-front.html</id>
    <published>2019-09-01T08:29:32.000Z</published>
    <updated>2019-09-12T10:51:52.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer—调整数组使得奇数在偶数前面"><a href="#剑指offer—调整数组使得奇数在偶数前面" class="headerlink" title="剑指offer—调整数组使得奇数在偶数前面"></a>剑指offer—调整数组使得奇数在偶数前面</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个非负整数数组 A，返回一个数组，在该数组中， A 的所有偶数元素之后跟着所有奇数元素。</p><p>你可以返回满足此条件的任何数组作为答案。</p><pre><code>示例：输入：[3,1,2,4]输出：[2,4,3,1]输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。</code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li><p><code>遍历数组，之前是偶数就移动到数组末尾(把后面的数都往前移动一位)</code>：时间复杂度$N^2$</p></li><li><p><code>快排(前后指针依次移动，前面碰到偶数停下，后面碰到奇数停下，都停下后进行交换)</code>：时间复杂度O(N)</p></li></ul><blockquote><p>优化：使用位运算判断奇偶数</p></blockquote><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/algorithm/7.png"><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="java">public class Solution {    public void reOrderArray(int [] array) {        int low = 0;int high = array.length-1;        while(low&lt;high){            while((low&lt;high)&amp;&amp;(array[low]&amp;1)==1){//偶数停下                low++;            }            while((low&lt;high)&amp;&amp;(array[high]&amp;1)!=1){//奇数停下                high--;            }            if(low&lt;high){//交换                int temp = array[low];                array[low] = array[high];                array[high] = temp;            }        }    }}</code></pre><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul><li><p>给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。</p></li><li><p>对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。</p></li><li><p>你可以返回任何满足上述条件的数组作为答案。</p></li></ul><pre><code class="java">示例：输入：[4,2,5,7]输出：[4,5,2,7]解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。</code></pre><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li><p>方法1：使用辅助空间，新开一个数组，遍历数组，偶数存储到<code>0,2,4,6</code>等偶数标位置，奇数存储到<code>1,3,5,7</code>等奇数处位置：时间复杂度N，空间复杂度N</p></li><li><p>方法2：使用双指针，分别指向数组奇数和偶数，奇数指针循环如果数组值为偶则停下，偶数指针如果遍历带数组值为奇数则停下，此时如果都在数组范围内则<code>进行交换</code>：时间复杂度N，空间复杂度O(1)</p></li></ul><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre><code class="java">class Solution {    public int[] sortArrayByParityII(int[] a) {        int i = 0,j = 1;        while(i&lt;=a.length-1&amp;&amp;j&lt;=a.length-1){//数组内循环            while(i&lt;=a.length-1&amp;&amp;(a[i]&amp;1)==0){//偶数指针循环找奇数                i+=2;            }            while(j&lt;=a.length-1&amp;&amp;(a[j]&amp;1)==1){//奇数指针循环找偶数                j+=2;            }            if((i&lt;=a.length-1)&amp;&amp;(j&lt;=a.length-1)){//如果在数组内，交换                int temp = a[i];                a[i] = a[j];                a[j] = temp;            }        }        return a;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      调整数组使得奇数在偶数前面.给定一个非负整数数组 A，返回一个数组，在该数组中， A 的所有偶数元素之后跟着所有奇数元素。
    
    </summary>
    
      <category term="算法" scheme="https://www.dzou.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="算法" scheme="https://www.dzou.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="牛客" scheme="https://www.dzou.top/tags/%E7%89%9B%E5%AE%A2/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="剑指offer" scheme="https://www.dzou.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="笔试" scheme="https://www.dzou.top/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式总结</title>
    <link href="https://www.dzou.top/post/2c936afd.html"/>
    <id>https://www.dzou.top/post/2c936afd.html</id>
    <published>2019-08-16T13:52:12.000Z</published>
    <updated>2019-08-16T16:49:19.310Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式总结"><a href="#Java设计模式总结" class="headerlink" title="Java设计模式总结"></a>Java设计模式总结</h2><p><strong>模式：在某种<code>情景</code>下，针对某<code>问题</code>的<code>解决方案</code>。</strong></p><ul><li>情景：应用某个设计模式的情况。</li><li>问题：要达到的目标。</li><li>解决方案：解决约束，达到目标的设计。</li></ul><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>设计原则：</p><ul><li>类应该对扩展开放，对修改关闭</li><li>把变化的抽取出来，不要和不变化的放在一起。</li><li>针对接口编程，不针对实现编程。</li><li>多用组合，少用继承。</li><li>单一原则：一个类应该只有一个引起变化的原因。</li><li>依赖倒置：要依赖抽象，不依赖具体类。</li><li>为了交互对象之间的松耦合的设计而努力。</li><li>好莱坞原则：别调用我们，我们会调用你。</li><li>最少设计原则：只和你的密友谈话(减少耦合)。</li></ul><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/38.png"><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/39.png"><hr><p><a href="https://www.dzou.top/post/6c84d9a1.html">Java设计模式|策略模式</a></p><p><a href="https://www.dzou.top/post/261ed4ab.html">Java设计模式|观察者模式</a></p><p><a href="https://www.dzou.top/post/1b3210b0.html">Java设计模式|装饰者模式</a></p><p><a href="https://www.dzou.top/post/4caa56ee.html">Java设计模式|工厂模式</a></p><p><a href="https://www.dzou.top/post/667421d7.html">Java设计模式|命令模式</a></p><p><a href="https://www.dzou.top/post/519a7c00.html">Java设计模式|适配器模式和外观模式</a></p><p><a href="https://www.dzou.top/post/55d3fc38.html">Java设计模式|模板方法模式</a></p><p><a href="https://www.dzou.top/post/7244f815.html">Java设计模式|迭代器模式和组合模式</a></p><p><a href="https://www.dzou.top/post/94ac76a6.html">Java设计模式|状态模式</a></p><p><a href="https://www.dzou.top/post/653661c0.html">Java设计模式|代理模式</a></p><p><a href="https://www.dzou.top/post/f90c55c.html">Java设计模式|单例模式</a></p><p><a href="https://www.dzou.top/post/7f2dd2e8.html">Java设计模式|备忘录模式</a></p><p><a href="https://www.dzou.top/post/d88fa864.html">Java设计模式|访问者模式</a></p><p><a href="https://www.dzou.top/post/ecc07d1a.html">Java设计模式|复合模式</a></p><p><a href="https://www.dzou.top/post/4855070c.html">Java设计模式|桥接模式</a></p><p><a href="https://www.dzou.top/post/4855070c.html">Java设计模式|生成器模式</a></p><p><a href="https://www.dzou.top/post/12fa71d.html">Java设计模式|享元模式/蝇量模式</a></p><p><a href="https://www.dzou.top/post/8fcaf333.html">Java设计模式|原型模式</a></p><p><a href="https://www.dzou.top/post/de32d4c3.html">Java设计模式|责任链模式</a></p><p><a href="https://www.dzou.top/post/6c0cb1a1.html">Java设计模式|中介者模式</a></p>]]></content>
    
    <summary type="html">
    
      模式：在某种`情景`下，针对某`问题`的`解决方案`。设计原则总结。模式分类。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式——中介者模式</title>
    <link href="https://www.dzou.top/post/6c0cb1a1.html"/>
    <id>https://www.dzou.top/post/6c0cb1a1.html</id>
    <published>2019-08-16T13:50:23.000Z</published>
    <updated>2019-08-16T16:50:51.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之中介者模式"><a href="#Java设计模式之中介者模式" class="headerlink" title="Java设计模式之中介者模式"></a>Java设计模式之中介者模式</h2><p><strong><em>中介者模式：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</em></strong></p><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/34.png"><p>角色：</p><ul><li><strong>Mediator（抽象中介者）</strong>：该接口用于与各同事对象之间进行通信。</li><li><strong>ConcreteMediator（具体中介者）</strong>：它是抽象中介者的子类，通过协调各个同事对象来实现协作行为，它维持了对各个同事对象的引用。</li><li><strong>Colleague（抽象同事类）</strong>：它定义各个同事类公有的方法，并声明了一些抽象方法来供子类实现，同时它维持了一个对抽象中介者类的引用，其子类可以通过该引用来与中介者通信。</li><li><strong>ConcreteColleague（具体同事类）</strong>：它是抽象同事类的子类；每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信。</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><strong>一个相亲中介所负责处理相亲者的约会请求和被约会对象的回应。</strong></p><p>如果让他们各自联系并进行约会，耗时长，还混乱，所以我们使用<code>中介者模式</code></p><ul><li>Mediator 中介类</li></ul><pre><code class="java">/** * 中介者抽象类 */public abstract class Mediator {    public abstract void register(DatingPerson person);//注册到中介所    public abstract void response(String datingPerson,String datedPerson);//回应相亲对象的是否接受}</code></pre><ul><li>DatingPerson 相亲的人 同事抽象类</li></ul><pre><code class="java">/** * 相亲的人抽象类 */public abstract class DatingPerson {    protected Mediator mediator;//保存中介所的引用    protected String name;//名字    public String getName(){        return name;    }    //相亲操作，调用的对象与传入参数名字的人发起约会请求，中介所处理，都相同所以写在抽象类实现中    public void makeOneDate(String datePersonName){        System.out.println(&quot;我想和 &quot;+datePersonName+&quot; 约个会&quot;);        mediator.response(this.getName(),datePersonName);    }    //接受    public void accept(String name){        System.out.println(&quot;我接受这次和 &quot;+name+&quot; 约会\n&quot;);    }    //拒绝    public void refuse(String name) {        System.out.println(&quot;我不想和 &quot;+name+&quot; 约会\n&quot;);    }}</code></pre><ul><li>PersonA 具体同事类</li></ul><blockquote><p>创建时调用构造方法传入中介所并注册</p></blockquote><pre><code class="java">public class PersonA extends DatingPerson {    public PersonA(Mediator mediator) {        this.mediator = mediator;        name = &quot;a&quot;;        this.mediator.register(this);    }}</code></pre><ul><li>PersonB 具体同事类</li></ul><pre><code class="java">public class PersonB extends DatingPerson {    public PersonB(Mediator mediator) {        this.mediator = mediator;        name = &quot;b&quot;;        this.mediator.register(this);    }}</code></pre><ul><li>PersonC 具体同事类</li></ul><pre><code class="java">public class PersonC extends DatingPerson{    public PersonC(Mediator mediator){        this.mediator = mediator;        name = &quot;c&quot;;        this.mediator.register(this);    }}</code></pre><ul><li>PersonD 具体同事类</li></ul><pre><code class="java">public class PersonD extends DatingPerson{    public PersonD(Mediator mediator){        this.mediator = mediator;        name = &quot;d&quot;;        this.mediator.register(this);    }}</code></pre><ul><li>DateMediator 相亲中介所 中介实现类</li></ul><pre><code class="java">/** * 相亲中介所 */public class DateMediator extends Mediator{    private Map&lt;String,DatingPerson&gt; datingPeople;//存放所有要相亲的人    public DateMediator(){        datingPeople = new HashMap&lt;&gt;();    }    //把要相亲的人注册到中介所    public void register(DatingPerson person) {        datingPeople.put(person.getName(),person);    }    //回应约会请求    @Override    public void response(String datingPerson,String datedPerson) {        DatingPerson person = datingPeople.get(datedPerson);//获取被约会对象        if(datingPerson.equals(&quot;c&quot;)){//所有人都不想和c约会            person.refuse(datingPerson);//被约会对象拒绝        }else {            person.accept(datingPerson);//被约会对象接受        }    }}</code></pre><ul><li>测试</li></ul><pre><code class="java">public class ClientTest {    public static void main(String[] args) {        Mediator mediator = new DateMediator();        DatingPerson a = new PersonA(mediator);        DatingPerson b = new PersonB(mediator);        DatingPerson c = new PersonC(mediator);        DatingPerson d = new PersonD(mediator);        a.makeOneDate(&quot;c&quot;);        b.makeOneDate(&quot;d&quot;);        c.makeOneDate(&quot;d&quot;);        d.makeOneDate(&quot;a&quot;);    }}输出：我想和 c 约个会我接受这次和 a 约会我想和 d 约个会我接受这次和 b 约会我想和 d 约个会我不想和 c 约会我想和 a 约个会我接受这次和 d 约会</code></pre><blockquote><p>MVC模式中<code>Controller</code>就是中介者</p></blockquote><p>中介者模式优点：</p><ul><li>同事间的解耦，他们只需要保存中介者的引用</li><li>同事间传递消息变得简单，系统易于维护</li></ul><p>代码地址：<a href="https://github.com/ding-zou/design_patterns/tree/master/mediator_patterns" rel="external nofollow noopener noreferrer" target="_blank">Github中介者模式</a></p><hr><p><a href="https://www.dzou.top/post/6c84d9a1.html">Java设计模式|策略模式</a></p><p><a href="https://www.dzou.top/post/261ed4ab.html">Java设计模式|观察者模式</a></p><p><a href="https://www.dzou.top/post/1b3210b0.html">Java设计模式|装饰者模式</a></p><p><a href="https://www.dzou.top/post/4caa56ee.html">Java设计模式|工厂模式</a></p><p><a href="https://www.dzou.top/post/667421d7.html">Java设计模式|命令模式</a></p><p><a href="https://www.dzou.top/post/519a7c00.html">Java设计模式|适配器模式和外观模式</a></p><p><a href="https://www.dzou.top/post/55d3fc38.html">Java设计模式|模板方法模式</a></p><p><a href="https://www.dzou.top/post/7244f815.html">Java设计模式|迭代器模式和组合模式</a></p><p><a href="https://www.dzou.top/post/94ac76a6.html">Java设计模式|状态模式</a></p><p><a href="https://www.dzou.top/post/653661c0.html">Java设计模式|代理模式</a></p><p><a href="https://www.dzou.top/post/f90c55c.html">Java设计模式|单例模式</a></p><p><a href="https://www.dzou.top/post/7f2dd2e8.html">Java设计模式|备忘录模式</a></p><p><a href="https://www.dzou.top/post/d88fa864.html">Java设计模式|访问者模式</a></p><p><a href="https://www.dzou.top/post/ecc07d1a.html">Java设计模式|复合模式</a></p><p><a href="https://www.dzou.top/post/4855070c.html">Java设计模式|桥接模式</a></p><p><a href="https://www.dzou.top/post/4855070c.html">Java设计模式|生成器模式</a></p><p><a href="https://www.dzou.top/post/12fa71d.html">Java设计模式|享元模式/蝇量模式</a></p><p><a href="https://www.dzou.top/post/8fcaf333.html">Java设计模式|原型模式</a></p><p><a href="https://www.dzou.top/post/de32d4c3.html">Java设计模式|责任链模式</a></p><p><a href="https://www.dzou.top/post/6c0cb1a1.html">Java设计模式|中介者模式</a></p>]]></content>
    
    <summary type="html">
    
      中介者模式：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式——责任链模式</title>
    <link href="https://www.dzou.top/post/de32d4c3.html"/>
    <id>https://www.dzou.top/post/de32d4c3.html</id>
    <published>2019-08-16T13:49:25.000Z</published>
    <updated>2019-08-16T16:50:47.543Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之责任链模式"><a href="#Java设计模式之责任链模式" class="headerlink" title="Java设计模式之责任链模式"></a>Java设计模式之责任链模式</h2><p><strong><em>责任链模式：为某个请求创建一个对象链，每个对象义序检查此请求，并对其进行处理，或者将其出给链中下一个对象。</em></strong></p><ul><li>Handler：抽象的处理对象接口</li><li>ConcreteHandler：具体的处理对象，有多个构成对象链，每个处理对象持有下一个处理对象的引用</li></ul><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/31.png"><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>场景：一个公司的邮件分为三类：</p><ul><li>粉丝发的：交给老板处理</li><li>抱怨产品的：交给产品部处理</li><li>垃圾邮件：交给管理员处理</li></ul><blockquote><p>先交给<code>管理员</code>处理，处理不了传给<code>产品部</code>，处理不了传给<code>老板</code>处理，<code>责任链：管理员—&gt;产品部—&gt;老板</code></p></blockquote><p>代码：</p><ul><li>EmailHandler 抽象邮件处理类接口</li></ul><pre><code class="java">public abstract class EmailHandler {    private EmailHandler nextHandler;//链中下一个处理对象    public void setNextHandler(EmailHandler handler){        this.nextHandler = handler;    }    public EmailHandler getNextHandler(){        return nextHandler;    }    public abstract void handlerEmail(Email email);}</code></pre><ul><li>ComplainEmailHandler 抱怨邮件处理类</li></ul><pre><code class="java">public class ComplainEmailHandler extends EmailHandler{    public void handlerEmail(Email email) {        if(email.equals(Email.COMPLAIN)){            System.out.println(&quot;这封邮件是：&quot;+email.getKind());            System.out.println(&quot;交给产品部处理&quot;);        }else {            getNextHandler().handlerEmail(email);        }    }}</code></pre><ul><li>FansEmailHandler 粉丝邮件处理类</li></ul><pre><code class="java">public class FansEmailHandler extends EmailHandler{    public void handlerEmail(Email email) {        if(email.equals(Email.FANS)){            System.out.println(&quot;这封邮件是：&quot;+email.getKind());            System.out.println(&quot;交给老板处理&quot;);        }    }}</code></pre><ul><li>TrashEmailHandler 垃圾邮件处理类</li></ul><pre><code class="java">public class TrashEmailHandler extends EmailHandler{    public void handlerEmail(Email email) {        if(email.equals(Email.TRASH)){            System.out.println(&quot;这封邮件是：&quot;+email.getKind());            System.out.println(&quot;交给管理员处理&quot;);        }else {            getNextHandler().handlerEmail(email);        }    }}</code></pre><ul><li>Email 邮件枚举类</li></ul><pre><code class="java">public enum Email {    FANS(1,&quot;粉丝邮件&quot;),    COMPLAIN(2,&quot;抱怨产品邮件&quot;),    TRASH(3,&quot;垃圾邮件&quot;);    private int i;    private String kind;    Email(int i, String kind) {        this.i = i;        this.kind = kind;    }    public String getKind(){        return kind;    }}</code></pre><ul><li>Test测试</li></ul><pre><code class="java">public class Test {    //设置处理链    public static EmailHandler getAndsetEmailHandlerChain(){        EmailHandler fansHandler  = new FansEmailHandler();        EmailHandler complainHandler = new ComplainEmailHandler();        EmailHandler trashHandler = new TrashEmailHandler();        trashHandler.setNextHandler(complainHandler);        complainHandler.setNextHandler(fansHandler);        return trashHandler;    }    public static void main(String[] args) {        EmailHandler firstHandler = Test.getAndsetEmailHandlerChain();        firstHandler.handlerEmail(Email.COMPLAIN);        System.out.println(&quot;\n&quot;);        firstHandler.handlerEmail(Email.FANS);        System.out.println(&quot;\n&quot;);        firstHandler.handlerEmail(Email.TRASH);    }}输出：这封邮件是：抱怨产品邮件交给产品部处理这封邮件是：粉丝邮件交给老板处理这封邮件是：垃圾邮件交给管理员处理</code></pre><blockquote><p>tomcat的过滤器就是使用责任链模式</p><pre><code class="java">public void doFilter(ServletRequest request, ServletResponse response,         FilterChain chain) throws IOException, ServletException {     chain.doFilter(request, response); }</code></pre></blockquote><p>责任链模式优点：</p><ul><li>将请求发送者和接收者解耦</li><li>可以动态改变链顺序</li></ul><p>代码地址：<a href="https://github.com/ding-zou/design_patterns/tree/master/chain_of_response_patterns" rel="external nofollow noopener noreferrer" target="_blank">Github责任链模式</a></p><hr><p><a href="https://www.dzou.top/post/6c84d9a1.html">Java设计模式|策略模式</a></p><p><a href="https://www.dzou.top/post/261ed4ab.html">Java设计模式|观察者模式</a></p><p><a href="https://www.dzou.top/post/1b3210b0.html">Java设计模式|装饰者模式</a></p><p><a href="https://www.dzou.top/post/4caa56ee.html">Java设计模式|工厂模式</a></p><p><a href="https://www.dzou.top/post/667421d7.html">Java设计模式|命令模式</a></p><p><a href="https://www.dzou.top/post/519a7c00.html">Java设计模式|适配器模式和外观模式</a></p><p><a href="https://www.dzou.top/post/55d3fc38.html">Java设计模式|模板方法模式</a></p><p><a href="https://www.dzou.top/post/7244f815.html">Java设计模式|迭代器模式和组合模式</a></p><p><a href="https://www.dzou.top/post/94ac76a6.html">Java设计模式|状态模式</a></p><p><a href="https://www.dzou.top/post/653661c0.html">Java设计模式|代理模式</a></p><p><a href="https://www.dzou.top/post/f90c55c.html">Java设计模式|单例模式</a></p><p><a href="https://www.dzou.top/post/7f2dd2e8.html">Java设计模式|备忘录模式</a></p><p><a href="https://www.dzou.top/post/d88fa864.html">Java设计模式|访问者模式</a></p><p><a href="https://www.dzou.top/post/ecc07d1a.html">Java设计模式|复合模式</a></p><p><a href="https://www.dzou.top/post/4855070c.html">Java设计模式|桥接模式</a></p><p><a href="https://www.dzou.top/post/4855070c.html">Java设计模式|生成器模式</a></p><p><a href="https://www.dzou.top/post/12fa71d.html">Java设计模式|享元模式/蝇量模式</a></p><p><a href="https://www.dzou.top/post/8fcaf333.html">Java设计模式|原型模式</a></p><p><a href="https://www.dzou.top/post/de32d4c3.html">Java设计模式|责任链模式</a></p><p><a href="https://www.dzou.top/post/6c0cb1a1.html">Java设计模式|中介者模式</a></p>]]></content>
    
    <summary type="html">
    
      责任链模式：为某个请求创建一个对象链，每个对象义序检查此请求，并对其进行处理，或者将其出给链中下一个对象。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式——原型模式</title>
    <link href="https://www.dzou.top/post/8fcaf333.html"/>
    <id>https://www.dzou.top/post/8fcaf333.html</id>
    <published>2019-08-16T13:48:18.000Z</published>
    <updated>2019-08-16T16:50:31.751Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java设计模式之原型模式"><a href="#Java设计模式之原型模式" class="headerlink" title="Java设计模式之原型模式"></a>Java设计模式之原型模式</h2><p><strong><em>原型模式：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。</em></strong></p><p>较为简单，经常与其他模式一同使用</p><ul><li>实现<code>Cloneable</code>接口，重写<code>clone</code>方法</li></ul><img src="http://pv4qgqg7s.bkt.clouddn.com/static/images/design_mode/36.png"><blockquote><p>原型模式设计到深拷贝和浅拷贝</p></blockquote><h4 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h4><ul><li>深拷贝：对基本数据类型进行值传递，<code>对引用数据类型，创建一个新的对象，并复制其内容</code>，也就是使用<code>clone</code>方法后创建一个新的内存空间存储引用。</li><li>浅拷贝：对基本数据类型进行值传递，<code>对引用数据类型进行引用传递般的拷贝</code>，也就是使用<code>clone</code>方法后基本类型值相同，引用类型引用地址相同，指向同一个原型。</li></ul><p><strong>深拷贝与浅拷贝问题中，会发生深拷贝的有java中的8中基本类型以及他们的封装类型，另外还有String类型。其余的都是浅拷贝。</strong></p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>场景：绵羊有颜色、名字和年龄三个成员变量，其中<code>颜色是具体的类对象</code>，名字和年龄是<code>String</code>，我们知道String会发生深拷贝，但是颜色对象是浅拷贝，我们现在尝试使用原型模式创建<code>两只克隆羊</code></p><h5 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><ul><li>Color 颜色</li></ul><pre><code class="java">/** * 颜色 */public class Color implements Cloneable {    private String color;    public Color(String color) {        this.color = color;    }    public String getColor() {        return color;    }    //重写clone方法    @Override    protected Object clone() throws CloneNotSupportedException {        Color color = null;        color = (Color) super.clone();        return color;    }}</code></pre><ul><li>Sheep 绵羊类 </li></ul><p>使用了<code>lombok</code>插件提供<code>getter/setter</code>、<code>构造方法</code>，不会自行百度</p><pre><code class="java">@Data@AllArgsConstructorpublic class Sheep implements Cloneable{    private Color color;//保存引用 非基本类型    private String name;    private String age;    @Override    public String toString() {        return &quot;Sheep{&quot; +                &quot;color=&quot; + color.getColor() +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&#39;&quot; + age + &#39;\&#39;&#39; +                &#39;}&#39;;    }    @Override    protected Object clone() throws CloneNotSupportedException {        Sheep sheep = null;        sheep = (Sheep) super.clone();        return sheep;    }}</code></pre><ul><li>测试</li></ul><pre><code class="java">public class ClientTest {    public static void main(String[] args) throws CloneNotSupportedException {        Color color = new Color(&quot;white&quot;);        Sheep sheep = new Sheep(color,&quot;小白&quot;,&quot;12&quot;);        Sheep cloneSheep1 = (Sheep) sheep.clone();        Sheep cloneSheep2 = (Sheep) sheep.clone();        System.out.println(&quot;sheep:&quot;+sheep);        System.out.println(&quot;cloneSheep1:&quot;+cloneSheep1);        System.out.println(&quot;cloneSheep2:&quot;+cloneSheep2);        System.out.println(&quot;\n&quot;);        System.out.println(&quot;cloneSheep1是否等于sheep：&quot;+ (cloneSheep1 == sheep));        System.out.println(&quot;cloneSheep1是否等于cloneSheep2：&quot;+ (cloneSheep1 == cloneSheep2));        System.out.println(&quot;\n&quot;);        System.out.println(&quot;sheep中非基本类型Color是否与cloneSheep1中Color相等：&quot;+(sheep.getColor()==cloneSheep1.getColor()));        System.out.println(&quot;cloneSheep2中非基本类型Color是否与cloneSheep1中Color相等：&quot;+(cloneSheep2.getColor()==cloneSheep1.getColor()));    }}输出：sheep:Sheep{color=white, name=&#39;小白&#39;, age=&#39;12&#39;}cloneSheep1:Sheep{color=white, name=&#39;小白&#39;, age=&#39;12&#39;}cloneSheep2:Sheep{color=white, name=&#39;小白&#39;, age=&#39;12&#39;}cloneSheep1是否等于sheep：falsecloneSheep1是否等于cloneSheep2：falsesheep中非基本类型Color是否与cloneSheep1中Color相等：truecloneSheep2中非基本类型Color是否与cloneSheep1中Color相等：true</code></pre><blockquote><p>说明浅拷贝复制的对象是不同的，但是对象中的<code>引用型</code>成员变量指向同一个引用</p></blockquote><h5 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h5><blockquote><p>深拷贝有两种方法：<code>序列化</code>和<code>更改clone方法</code></p></blockquote><ul><li>Color 颜色</li></ul><pre><code class="java">@AllArgsConstructor@Datapublic class Color implements Serializable,Cloneable {    private String color;    @Override    protected Object clone() throws CloneNotSupportedException {        Color color = null;        color = (Color) super.clone();        return color;    }}</code></pre><ul><li>DeepCloneSheep</li></ul><pre><code class="java">/** * 深拷贝绵羊，让它的颜色Color拷贝时创建新的引用 */@Data@AllArgsConstructorpublic class DeepCloneSheep implements Serializable,Cloneable {    private Color color;//保存引用 非基本类型    private String name;//String类型    private String age;    /**     * 深克隆方法一 修改clone方法     * @return     * @throws CloneNotSupportedException     */    @Override    protected Object clone() throws CloneNotSupportedException {        DeepCloneSheep sheep = null;        sheep = (DeepCloneSheep) super.clone();//sheep先克隆        sheep.color = (Color) color.clone();//其中非基本类型再克隆        return sheep;    }    /**     * 方法2.使用序列化     * @return     */    public Object deepClone(){        Object o = null;        ByteArrayOutputStream bos;        ObjectOutputStream oos;        ByteArrayInputStream bis;        ObjectInputStream ois;        try{            //序列化 对象流            bos = new ByteArrayOutputStream();            oos = new ObjectOutputStream(bos);            oos.writeObject(this);            //反序列化            bis = new ByteArrayInputStream(bos.toByteArray());            ois = new ObjectInputStream(bis);            o = ois.readObject();            bos.close();            bis.close();            ois.close();            bis.close();        } catch (ClassNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }        return o;    }    @Override    public String toString() {//重写toString打印颜色        return &quot;DeepCloneSheep{&quot; +                &quot;color=&quot; + color.getColor() +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&#39;&quot; + age + &#39;\&#39;&#39; +                &#39;}&#39;;    }}</code></pre><ul><li>测试</li></ul><pre><code class="java">public class ClientTest {    @Test//方法一：修改clone，让颜色也被clone    public void testCloneMethod1() throws CloneNotSupportedException {        Color color = new Color(&quot;white&quot;);        DeepCloneSheep sheep = new DeepCloneSheep(color,&quot;小白&quot;,&quot;12&quot;);        DeepCloneSheep cloneSheep1 = (DeepCloneSheep) sheep.clone();        DeepCloneSheep cloneSheep2 = (DeepCloneSheep) sheep.clone();        System.out.println(&quot;sheep:&quot;+sheep);        System.out.println(&quot;cloneSheep1:&quot;+cloneSheep1);        System.out.println(&quot;cloneSheep2:&quot;+cloneSheep2+&quot;\n&quot;);        System.out.println(&quot;方法一：修改clone方法&quot;);        System.out.println(&quot;cloneSheep1是否等于sheep：&quot;+ (cloneSheep1 == sheep));        System.out.println(&quot;cloneSheep1是否等于cloneSheep2：&quot;+ (cloneSheep1 == cloneSheep2)+&quot;\n&quot;);        System.out.println(&quot;sheep中非基本类型Color是否与cloneSheep1中Color相等：&quot;+(sheep.getColor()==cloneSheep1.getColor()));        System.out.println(&quot;cloneSheep2中非基本类型Color是否与cloneSheep1中Color相等：&quot;+(cloneSheep2.getColor()==cloneSheep1.getColor())+&quot;\n&quot;);    }//方法二：序列化    @Test    public void testCloneMethod2(){        Color color = new Color(&quot;white&quot;);        DeepCloneSheep sheep = new DeepCloneSheep(color,&quot;小白&quot;,&quot;12&quot;);        DeepCloneSheep cloneSheep3 = (DeepCloneSheep) sheep.deepClone();        DeepCloneSheep cloneSheep4 = (DeepCloneSheep) sheep.deepClone();        System.out.println(&quot;sheep:&quot;+sheep);        System.out.println(&quot;cloneSheep3:&quot;+cloneSheep3);        System.out.println(&quot;cloneSheep4:&quot;+cloneSheep4+&quot;\n&quot;);        System.out.println(&quot;方法二：序列化方法&quot;);        System.out.println(&quot;cloneSheep3是否等于sheep：&quot;+ (cloneSheep3 == sheep));        System.out.println(&quot;cloneSheep3是否等于cloneSheep4：&quot;+ (cloneSheep3 == cloneSheep4)+&quot;\n&quot;);        System.out.println(&quot;sheep中非基本类型Color是否与cloneSheep3中Color相等：&quot;+(sheep.getColor()==cloneSheep3.getColor()));        System.out.println(&quot;cloneSheep3中非基本类型Color是否与cloneSheep4中Color相等：&quot;+(cloneSheep3.getColor()==cloneSheep4.getColor()));    }}</code></pre><p>输出：两种方法输出一样</p><pre><code class="java">sheep:DeepCloneSheep{color=white, name=&#39;小白&#39;, age=&#39;12&#39;}cloneSheep1:DeepCloneSheep{color=white, name=&#39;小白&#39;, age=&#39;12&#39;}cloneSheep2:DeepCloneSheep{color=white, name=&#39;小白&#39;, age=&#39;12&#39;}cloneSheep1是否等于sheep：falsecloneSheep1是否等于cloneSheep2：falsesheep中非基本类型Color是否与cloneSheep1中Color相等：falsecloneSheep2中非基本类型Color是否与cloneSheep1中Color相等：false</code></pre><blockquote><p>可以看到，深拷贝中引用类型<code>颜色</code>在clone过程中没有再指向同一引用</p></blockquote><h4 id="Spring中原型模式使用"><a href="#Spring中原型模式使用" class="headerlink" title="Spring中原型模式使用"></a>Spring中原型模式使用</h4><blockquote><p>我们都知道在Spring中，创建bean的scope域可以为<code>Singleton</code>或者是<code>protoType</code>，这就是使用到了原型模式</p></blockquote><p>我们创建一个<code>Conponent</code>，使用xml配置声明为<code>原型模式protoType</code>，加入到容器，我们获取两次该Bean看它们是否相等</p><pre><code class="java">@Componentpublic class Bean {}</code></pre><pre><code class="xml">&lt;bean id=&quot;bean&quot; scope=&quot;prototype&quot; name=&quot;bean&quot; class=&quot;top.dzou.prototype_pattern.spring.Bean&quot;/&gt;</code></pre><p>测试：</p><pre><code class="java">public class SpringBeanTest {    public static void main(String[] args) {        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);        Object bean = context.getBean(&quot;bean&quot;);//获取该bean        Object bean2 = context.getBean(&quot;bean&quot;);//再获取一个        //打印是否相等，测试原型模式        //调用BeanFactory中 doGetBean方法 其中判断是否为if (mbd.isPrototype())        System.out.println(&quot;bean是否等于bean2：&quot;+(bean==bean2));    }}</code></pre><p>输出：<code>bean是否等于bean2：false</code></p><p>源码：</p><p>调用<code>getBean</code>时调用了<code>AbstractBeanFactory</code>类中的<code>doGetBean</code>方法，其中有下面部分代码</p><pre><code class="java">if (mbd.isSingleton()) {//判断是否为单例模式                    bean = this.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);                } else if (mbd.isPrototype()) {//判断是否为原型模式                        this.beforePrototypeCreation(beanName);                        prototypeInstance = this.createBean(beanName, mbd, args);</code></pre><blockquote><p>这就是Spring中<code>原型模式</code>的使用，当然也使用了单例模式</p></blockquote><p><strong>原型模式优点：</strong></p><ul><li>某些情况，复制对象比创建对象更有效，<code>clone</code>方法是本地方法，直接操作内存，比创建对象高效不少</li><li>简化对象的创建，不被构造方法束缚</li></ul><p>代码地址：<a href="https://github.com/ding-zou/design_patterns/tree/master/prototype_patterns" rel="external nofollow noopener noreferrer" target="_blank">Github原型模式</a></p><hr><p><a href="https://www.dzou.top/post/6c84d9a1.html">Java设计模式|策略模式</a></p><p><a href="https://www.dzou.top/post/261ed4ab.html">Java设计模式|观察者模式</a></p><p><a href="https://www.dzou.top/post/1b3210b0.html">Java设计模式|装饰者模式</a></p><p><a href="https://www.dzou.top/post/4caa56ee.html">Java设计模式|工厂模式</a></p><p><a href="https://www.dzou.top/post/667421d7.html">Java设计模式|命令模式</a></p><p><a href="https://www.dzou.top/post/519a7c00.html">Java设计模式|适配器模式和外观模式</a></p><p><a href="https://www.dzou.top/post/55d3fc38.html">Java设计模式|模板方法模式</a></p><p><a href="https://www.dzou.top/post/7244f815.html">Java设计模式|迭代器模式和组合模式</a></p><p><a href="https://www.dzou.top/post/94ac76a6.html">Java设计模式|状态模式</a></p><p><a href="https://www.dzou.top/post/653661c0.html">Java设计模式|代理模式</a></p><p><a href="https://www.dzou.top/post/f90c55c.html">Java设计模式|单例模式</a></p><p><a href="https://www.dzou.top/post/7f2dd2e8.html">Java设计模式|备忘录模式</a></p><p><a href="https://www.dzou.top/post/d88fa864.html">Java设计模式|访问者模式</a></p><p><a href="https://www.dzou.top/post/ecc07d1a.html">Java设计模式|复合模式</a></p><p><a href="https://www.dzou.top/post/4855070c.html">Java设计模式|桥接模式</a></p><p><a href="https://www.dzou.top/post/4855070c.html">Java设计模式|生成器模式</a></p><p><a href="https://www.dzou.top/post/12fa71d.html">Java设计模式|享元模式/蝇量模式</a></p><p><a href="https://www.dzou.top/post/8fcaf333.html">Java设计模式|原型模式</a></p><p><a href="https://www.dzou.top/post/de32d4c3.html">Java设计模式|责任链模式</a></p><p><a href="https://www.dzou.top/post/6c0cb1a1.html">Java设计模式|中介者模式</a></p>]]></content>
    
    <summary type="html">
    
      原型模式：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="https://www.dzou.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
