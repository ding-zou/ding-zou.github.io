<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dzou&#39;s Blog</title>
  
  <subtitle>No pains,no gains.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.dzou.top/"/>
  <updated>2019-11-13T16:25:14.534Z</updated>
  <id>https://www.dzou.top/</id>
  
  <author>
    <name>dzou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>扫码登录功能—轮询or长连接WebSocket—Zxing生成二维码</title>
    <link href="https://www.dzou.top/post/qrcode-scan.html"/>
    <id>https://www.dzou.top/post/qrcode-scan.html</id>
    <published>2019-11-12T15:55:55.000Z</published>
    <updated>2019-11-13T16:25:14.534Z</updated>
    
    <content type="html"><![CDATA[<h2 id="扫码登录功能—轮询or长连接WebSocket—Zxing生成二维码"><a href="#扫码登录功能—轮询or长连接WebSocket—Zxing生成二维码" class="headerlink" title="扫码登录功能—轮询or长连接WebSocket—Zxing生成二维码"></a>扫码登录功能—轮询or长连接WebSocket—Zxing生成二维码</h2><p>扫码登录其实就是一个登录请求，只不过信息存储在用户手机上，还需要通过二维码验证是否匹配的方式就可以登录，免去了用户多次输入密码的场景，现在越来越多登录方式，其中扫码登录算是比较人性化的了</p><p><strong>我们把一个全局唯一id保存在二维码中，使用手机扫码可以获取到二维码中的信息，此时就把该二维码和你的手机用户账号建立一种绑定的关系，这个二维码就只归你所有了，当你登录完后这个二维码就废弃了，二维码起的作用就是一种认证的机制</strong></p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>具体流程如下图：</p><img src="http://dzou.wangminwei.top/static/images/pj/2.png"><ol><li>Step 1、用户 A 访问网页客户端，服务器为这个会话生成一个全局唯一的 ID，此时系统并不知道访问者是谁。</li><li>Step 2、用户A打开自己的手机App并扫描这个二维码，并提示用户是否确认登录。</li><li>Step 3、手机上的是登录状态，用户点击确认登录后，手机上的客户端将账号和这个扫描得到的 ID 一起提交到服务器</li><li>Step 4、服务器将这个 ID 和用户 A 的账号绑定在一起，并通知网页版，这个 ID 对应的微信号为用户 A，网页版加载用户 A 的信息，至此，扫码登录全部流程完成</li></ol><h3 id="创建二维码"><a href="#创建二维码" class="headerlink" title="创建二维码"></a>创建二维码</h3><p>我们选取使用自己在服务器端根据创建的全局唯一id生成一个二维码，使用<code>google</code>的<code>zxing</code>二维码生成类库</p><ul><li>依赖</li></ul><pre><code class="xml">&lt;dependency&gt;            &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;            &lt;artifactId&gt;javase&lt;/artifactId&gt;            &lt;version&gt;3.2.1&lt;/version&gt;        &lt;/dependency&gt;</code></pre><ul><li>生成二维码</li></ul><p>根据content内容和指定高度和宽度生成二维码的base64格式图片，可以直接在前端显示</p><pre><code class="java">public String createQrCode(String content, int width, int height) throws IOException {        String resultImage = &quot;&quot;;        if (!StringUtils.isEmpty(content)) {            ServletOutputStream stream = null;            ByteArrayOutputStream os = new ByteArrayOutputStream();            @SuppressWarnings(&quot;rawtypes&quot;)            HashMap&lt;EncodeHintType, Comparable&gt; hints = new HashMap&lt;&gt;();            hints.put(EncodeHintType.CHARACTER_SET, &quot;utf-8&quot;); // 指定字符编码为“utf-8”            hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.M); // 指定二维码的纠错等级为中级            hints.put(EncodeHintType.MARGIN, 2); // 设置图片的边距            try {                QRCodeWriter writer = new QRCodeWriter();                BitMatrix bitMatrix = writer.encode(content, BarcodeFormat.QR_CODE, width, height, hints);                BufferedImage bufferedImage = MatrixToImageWriter.toBufferedImage(bitMatrix);                ImageIO.write(bufferedImage, &quot;png&quot;, os);                /**                 * 原生转码前面没有 data:image/png;base64 这些字段，返回给前端是无法被解析，可以让前端加，也可以在下面加上                 */                resultImage = new String(&quot;data:image/png;base64,&quot; + Base64.encode(os.toByteArray()));                return resultImage;            } catch (Exception e) {                e.printStackTrace();            } finally {                if (stream != null) {                    stream.flush();                    stream.close();                }            }        }        return null;    }</code></pre><h3 id="二维码状态管理"><a href="#二维码状态管理" class="headerlink" title="二维码状态管理"></a>二维码状态管理</h3><p><strong>我们使用redis来存储每一张二维码的状态</strong></p><p>状态:</p><ol><li>NOT_SCAN 未被扫描</li><li>SCANNED 被扫描</li><li>VERIFIED 确认完后</li><li>EXPIRED 过期</li><li>FINISH 完成</li></ol><blockquote><p>由于一张二维码只能被扫描一次，所以我们每一次扫描一张二维码后，把状态设置为<code>SCANNED</code>，<code>SCANNED</code>状态的二维码无法再次被扫描，抛出已被扫描的信息</p></blockquote><p>状态转移：</p><blockquote><p>NOT_SCANNED-&gt;SCANNED-&gt;VERIFIED-&gt;FINISH</p><p>其中EXPIRED状态可以插在其中任意一个位置，过期了的二维码也自动过期</p></blockquote><h3 id="生成二维码接口"><a href="#生成二维码接口" class="headerlink" title="生成二维码接口"></a>生成二维码接口</h3><ul><li>创建二维码</li></ul><p><strong>使用UUID工具类生成全局唯一id，也可以使用snowflake生成自增的全局唯一id，然后保存到redis中，key为uuid，val为当前二维码状态，我们这里维护了一个map保存所有uuid对应的二维码base格式，用于建立对应关系，前端传递二维码base64过来我们来判断这张二维码对应的uuid是多少</strong></p><blockquote><p>很多人问为什么不让前端传递扫描过后的uuid呢？第一，我们只能使用postman模拟请求，我们无法根据手机app扫码获取二维码信息，所以暂时采取传输图片，实际中肯定采用uuid去传输，因为base64本来就很大，尽量传输数据量小的数据</p></blockquote><pre><code class="java">@GetMapping(&quot;/createQr&quot;)    @ResponseBody    public Result&lt;String&gt; createQrCode() throws IOException {        String uuid = UUIDUtil.uuid();        log.info(uuid);        String qrCode = qrCodeService.createQrCode(uuid,200,200);        qrCodeMap.put(qrCode,uuid);        redisService.set(QrCodeKey.UUID,uuid,QrCodeStatus.NOT_SCAN);        return Result.success(qrCode);    }</code></pre><h3 id="前端轮询法判断二维码是否被扫描"><a href="#前端轮询法判断二维码是否被扫描" class="headerlink" title="前端轮询法判断二维码是否被扫描"></a>前端轮询法判断二维码是否被扫描</h3><p><strong>目前阿里云登录控制台就是使用轮询的方法，具体为什么不使用长连接我也不清楚，但是说明这种方法也是比较常见的</strong></p><p>后端只需要处理app登录请求和确认请求以及网页端响应的请求就好了</p><h4 id="二维码是否被扫描接口—前端只需要轮询该接口"><a href="#二维码是否被扫描接口—前端只需要轮询该接口" class="headerlink" title="二维码是否被扫描接口—前端只需要轮询该接口"></a>二维码是否被扫描接口—前端只需要轮询该接口</h4><p>获取到redis保存对应uuid的状态，返回给前端，前端轮询判断做处理</p><pre><code class="java">@GetMapping(&quot;/query&quot;)    @ResponseBody    public Result&lt;String&gt; queryIsScannedOrVerified(@RequestParam(&quot;img&quot;)String img){        String uuid = qrCodeMap.get(img);        QrCodeStatus s = redisService.get(QrCodeKey.UUID, uuid, QrCodeStatus.class);        return Result.success(s.getStatus());    }</code></pre><h4 id="app扫描接口"><a href="#app扫描接口" class="headerlink" title="app扫描接口"></a>app扫描接口</h4><p>app扫描二维码后，拿到对应的二维码信息发送一个扫描请求给后端，携带app用户参数，这里demo演示就模拟一个绝对的用户信息</p><p><em>*之后就是判断redis中uuid的状态，</em></p><ul><li><strong>如果为<code>NOT_SCAN</code>，就修改为<code>SCANNED</code></strong></li><li><strong>如果为<code>SCANNED</code>，就返回重复扫描的错误</strong></li><li><strong>如果为<code>VERIFIED</code>，就完成本次二维码登录逻辑，用户登录成功</strong></li></ul><pre><code class="java">@GetMapping(&quot;/doScan&quot;)    @ResponseBody    public Result doAppScanQrCode(@RequestParam(&quot;username&quot;)String username,                               @RequestParam(&quot;password&quot;)String password,                               @RequestParam(&quot;uuid&quot;)String uuid){        QrCodeStatus status = redisService.get(QrCodeKey.UUID,uuid,QrCodeStatus.class);        log.info(status.getStatus());        if(status.getStatus().isEmpty()) return Result.error(ErrorCodeEnum.UUID_EXPIRED);        switch (status){            case NOT_SCAN:                //等待确认 todo                if(username.equals(&quot;dzou&quot;)&amp;&amp;password.equals(&quot;1234&quot;)){                    redisService.set(QrCodeKey.UUID,uuid, QrCodeStatus.SCANNED);                    return Result.success(&quot;请手机确认&quot;);                }else{                    return Result.error(ErrorCodeEnum.LOGIN_FAIL);                }            case SCANNED:                return Result.error(ErrorCodeEnum.QRCODE_SCANNED);            case VERIFIED:                return Result.success(&quot;你已经确认过了&quot;);        }        return Result.error(ErrorCodeEnum.SEVER_ERROR);    }</code></pre><h4 id="app确认登录接口"><a href="#app确认登录接口" class="headerlink" title="app确认登录接口"></a>app确认登录接口</h4><p><strong>app扫描成功后，二维码状态变为<code>SCANNED</code>，需要发送一个请求给app前端请求用户确认，用户点击确认后请求这个接口，完成登录</strong></p><pre><code class="java">@GetMapping(&quot;/verify&quot;)    @ResponseBody    public Result verifyQrCode(@RequestParam(&quot;uuid&quot;)String uuid){        String status = redisService.get(QrCodeKey.UUID,uuid,String.class);        if(status.isEmpty()) return Result.error(ErrorCodeEnum.UUID_EXPIRED);        redisService.set(QrCodeKey.UUID,uuid,QrCodeStatus.VERIFIED);        return Result.success(&quot;确认成功&quot;);    }</code></pre><h4 id="前端—JQuery"><a href="#前端—JQuery" class="headerlink" title="前端—JQuery"></a>前端—JQuery</h4><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;扫描二维码&lt;/title&gt;  &lt;!-- jquery --&gt;  &lt;script type=&quot;text/javascript&quot; th:src=&quot;@{/js/jquery.min.js}&quot;&gt;&lt;/script&gt;  &lt;!-- bootstrap --&gt;  &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; th:href=&quot;@{/bootstrap/css/bootstrap.min.css}&quot;/&gt;  &lt;script type=&quot;text/javascript&quot; th:src=&quot;@{/bootstrap/js/bootstrap.min.js}&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;h1&gt;二维码&lt;/h1&gt;  &lt;div&gt;    &lt;table&gt;      &lt;tr&gt;        &lt;td&gt;&lt;img id=&quot;qrCode&quot; width=&quot;200&quot; height=&quot;200&quot;/&gt;&lt;/td&gt;      &lt;/tr&gt;    &lt;/table&gt;  &lt;/div&gt;&lt;/body&gt;&lt;script&gt;  var img = &quot;&quot;;  $.ajax({    url: &quot;/api/createQr&quot;,    type:&quot;GET&quot;,    success:function (data) {      $(&quot;#qrCode&quot;).attr(&quot;src&quot;,data.data);      img = data.data;      callbackScan($(&quot;#qrCode&quot;).attr(&quot;src&quot;))    }  });    //使用setTimeOut来循环请求判断是否被扫描，被扫描以后调用下面一个函数循环判断是否被确认  function callbackScan(img) {    var tID = setTimeout(function() {      $.ajax({        url : &#39;/api/query&#39;,        dataType: &quot;json&quot;,        type: &#39;GET&#39;,        data:{&quot;img&quot;:img},        success : function(res) {          //process data here          console.log(&quot;img:&quot;+img);          console.log(res.data);          if(res.data==&quot;scanned&quot;) {            clearTimeout(tID);            console.log(&quot;请求确认&quot;)            callbackVerify(img)          }else {            callbackScan(img)          }        }      }) }, 1500);  }//循环判断是否被确认  function callbackVerify(img) {    var tID = setTimeout(function() {      $.ajax({        url : &#39;/api/query&#39;,        dataType: &quot;json&quot;,        type: &#39;GET&#39;,        data:{&quot;img&quot;:img},        success : function(res) {          //process data here          console.log(res.data);          if(res.data==&quot;verified&quot;) {            clearTimeout(tID);            console.log(&quot;确认成功&quot;)            window.location.href = &quot;success&quot;;          }else {            callbackVerify(img)          }        }      }) }, 1500);  }&lt;/script&gt;&lt;/html&gt;</code></pre><p><strong>成功后跳转到成功页面</strong></p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><ul><li>打开主页创建二维码</li></ul><img src="http://dzou.wangminwei.top/static/images/pj/3.png"><ul><li>拿到服务器端创建的uuid请求扫描接口</li></ul><img src="http://dzou.wangminwei.top/static/images/pj/4.png"><ul><li>拿uuid请求确认接口</li></ul><img src="http://dzou.wangminwei.top/static/images/pj/5.png"><ul><li>确认完成，跳转到登录界面</li></ul><img src="http://dzou.wangminwei.top/static/images/pj/6.png"><h3 id="长连接WebSocket来传输二维码被扫描的信息"><a href="#长连接WebSocket来传输二维码被扫描的信息" class="headerlink" title="长连接WebSocket来传输二维码被扫描的信息"></a>长连接WebSocket来传输二维码被扫描的信息</h3><blockquote><p>除了轮询还有一种相对来说更好的实现方式就是WebSocket长连接，但是有些浏览器不支持WebSocket，考虑到这点我们决定使用<code>SockJs</code>，他是一种优先Websocket的连接方式，不支持的话它会去使用其他类似轮询的方式</p></blockquote><p><strong>我们服务器端需要编写对应的WebSocket处理逻辑，我们在加载页面时建立长连接，扫描时请求接口，把状态发送给前端WebSocket，如果为被扫描，发送请求确认的信息，请求确认接口完成确认后发送状态给前端WebSocket，跳转到success页面</strong></p><blockquote><p>我们使用Springboot提供的WebSocket支持类库编写，如果有需要使用netty编写的同学，可以参考我的另外一篇netty的文章</p></blockquote><p>maven依赖</p><pre><code class="xml">&lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;            &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;        &lt;/dependency&gt;</code></pre><h4 id="WebSocket配置类"><a href="#WebSocket配置类" class="headerlink" title="WebSocket配置类"></a>WebSocket配置类</h4><ul><li>其中第一个方法<code>registerStompEndpoints</code>相当于指定代理服务器的WebSocket路由</li><li>第二个方法就是客户端订阅路由，客户端可以接收到这个路由发送的信息</li></ul><pre><code class="java">@Configuration@EnableWebSocketMessageBrokerpublic class IWebSocketConfig implements WebSocketMessageBrokerConfigurer {    @Override    public void registerStompEndpoints(StompEndpointRegistry registry) {//注册一个Stomp 协议的endpoint,并指定 SockJS协议        registry.addEndpoint(&quot;/websocket&quot;).withSockJS();    }    @Override    public void configureMessageBroker(MessageBrokerRegistry registry) {        registry.enableSimpleBroker(&quot;/topic&quot;);        //registry.setApplicationDestinationPrefixes(&quot;/app&quot;);    }}</code></pre><h4 id="注入WebSocket发送消息模板"><a href="#注入WebSocket发送消息模板" class="headerlink" title="注入WebSocket发送消息模板"></a>注入WebSocket发送消息模板</h4><pre><code class="java">@Autowired    private SimpMessagingTemplate simpMessagingTemplate;</code></pre><h4 id="扫描二维码接口"><a href="#扫描二维码接口" class="headerlink" title="扫描二维码接口"></a>扫描二维码接口</h4><p><strong>我们只需要稍微改一下代码，在第一次扫描后使用WebSocket发送一个信息请求确认给前端WebSocket</strong></p><pre><code class="java">@GetMapping(&quot;/doScan&quot;)    @ResponseBody    public Result doAppScanQrCode(@RequestParam(&quot;username&quot;)String username,                                  @RequestParam(&quot;password&quot;)String password,                                  @RequestParam(&quot;uuid&quot;)String uuid){        QrCodeStatus status = redisService.get(QrCodeKey.UUID,uuid,QrCodeStatus.class);        log.info(                status.getStatus());        if(status.getStatus().isEmpty()) return Result.error(ErrorCodeEnum.UUID_EXPIRED);        switch (status){            case NOT_SCAN:                if(username.equals(&quot;dzou&quot;)&amp;&amp;password.equals(&quot;1234&quot;)){                    redisService.set(QrCodeKey.UUID,uuid, QrCodeStatus.SCANNED);                    simpMessagingTemplate.convertAndSend(&quot;/topic/ws&quot;,&quot;请确认&quot;);                    return Result.success(&quot;请手机确认&quot;);                }else{                    return Result.error(ErrorCodeEnum.LOGIN_FAIL);                }            case SCANNED:                return Result.error(ErrorCodeEnum.QRCODE_SCANNED);            case VERIFIED:                return Result.success(&quot;你已经确认过了&quot;);        }        return Result.error(ErrorCodeEnum.SEVER_ERROR);    }</code></pre><h4 id="确认登录接口"><a href="#确认登录接口" class="headerlink" title="确认登录接口"></a>确认登录接口</h4><p><strong>我们需要稍改确认的代码，因为确认成功我们需要向客户端订阅的指定路由发送一条消息</strong></p><p>调用<code>convertAndSend</code>发送指定消息到指定路由下</p><pre><code class="java">@GetMapping(&quot;/verify&quot;)    @ResponseBody    public Result verifyQrCode(@RequestParam(&quot;uuid&quot;)String uuid){        String status = redisService.get(QrCodeKey.UUID,uuid,String.class);        if(status.isEmpty()) return Result.error(ErrorCodeEnum.UUID_EXPIRED);        redisService.set(QrCodeKey.UUID,uuid,QrCodeStatus.VERIFIED);        simpMessagingTemplate.convertAndSend(&quot;/topic/ws&quot;,&quot;已经确认&quot;);        return Result.success(&quot;确认成功&quot;);    }</code></pre><h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><p><strong>前端就不需要轮询的那两个方法了，只需要连接SockJs就好了，根据WebSocket发送的信息进行处理，我们这里需要客户端连接上后进行订阅，指定接收服务器哪个路由发送的消息</strong></p><pre><code class="js">function connect() {    var socket = new SockJS(&#39;/websocket&#39;);    stompClient = Stomp.over(socket);    stompClient.connect({}, function (frame) {      console.log(&#39;Connected: &#39; + frame);      stompClient.subscribe(&#39;/topic/ws&#39;, function (response) {//订阅路由消息        console.log(response);        if(response.body==&quot;请确认&quot;){          layer.msg(&quot;请在你的app上确认登录&quot;)        }else if(response.body==&quot;已经确认&quot;){          window.location.href = &quot;success&quot;        }      });    });  }</code></pre><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><ul><li>打开主页创建二维码，连接WebSocket</li></ul><img src="http://dzou.wangminwei.top/static/images/pj/7.png"><ul><li>拿到服务器端创建的uuid请求扫描接口</li></ul><img src="http://dzou.wangminwei.top/static/images/pj/8.png"><ul><li>控制台打印请求确认信息</li></ul><img src="http://dzou.wangminwei.top/static/images/pj/9.png"><ul><li>拿uuid请求确认接口</li></ul><img src="http://dzou.wangminwei.top/static/images/pj/10.png"><ul><li>确认完成，跳转到登录界面，发送已经确认</li></ul><img src="http://dzou.wangminwei.top/static/images/pj/11.png">]]></content>
    
    <summary type="html">
    
      信息存储在用户手机上，通过二维码验证是否匹配的方式就可以登录，免去了用户多次输入密码的场景。.我们把一个全局唯一id保存在二维码中，使用手机扫码可以获取到二维码中的信息，此时就把该二维码和你的手机用户账号建立一种绑定的关系，这个二维码就只归你所有了，当你登录完后这个二维码就废弃了，二维码起的作用就是一种认证的机制
    
    </summary>
    
      <category term="项目" scheme="https://www.dzou.top/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="项目" scheme="https://www.dzou.top/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>动态规划—搞懂01背包和完全背包算法</title>
    <link href="https://www.dzou.top/post/napzack-algorithm.html"/>
    <id>https://www.dzou.top/post/napzack-algorithm.html</id>
    <published>2019-10-30T08:29:32.000Z</published>
    <updated>2019-10-30T15:48:27.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><p><strong>有N件物品和一个容量为V的背包。第i件物品的费用是v[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。</strong></p><p><strong>要么拿，要么不拿</strong></p><ul><li>dp解决方法</li></ul><img src="http://dzou.wangminwei.top/static/images/algorithm/28.png"><blockquote><p>关键就在于找到它的最优子问题，物品为N个，体积为V，我们需要取二维状态的dp</p><p><code>将前i个物品放入体积为j的背包中可以获得的最大价值</code>-&gt;<code>dp[i][j]</code></p><p>只有单件物品就只需要考虑放或者不放，如果放入，体积就需要减去v[i]，价值就加上w[i]</p></blockquote><img src="http://dzou.wangminwei.top/static/images/algorithm/29.png"><p><strong>比如我们想要知道前5个物品放入体积为9的背包中最大价值是多少，物品id为0-4</strong></p><blockquote><p>也就是求<code>dp[4][9]，</code>需要知道<code>dp[3][j]</code>,<code>0&lt;j&lt;V</code>,然后再对物品4进行选取，根据01背包状态转移方程计算dp[4][9]最大价值；</p><p>要知道<code>dp[3][j]</code>,我们就要知道<code>dp[2][j]</code>,再对物品3进行选取，根据01背包状态转移方程计算<code>dp[3][j]</code>最大价值；</p><p>要知道<code>dp[2][j]</code>,我们就要知道<code>dp[1][j]</code>,再对物品3进行选取，根据01背包状态转移方程计算<code>dp[2][j]</code>最大价值；</p><p>要知道<code>dp[1][j]</code>,我们就要知道<code>dp[0][j]</code>,再对物品3进行选取，根据01背包状态转移方程计算<code>dp[0][j]</code>最大价值；</p><p>把<code>dp[i][0]</code>初始化为0(0&lt;=i&lt;N)，体积为0最大价值为0</p></blockquote><img src="http://dzou.wangminwei.top/static/images/algorithm/31.png"><ul><li>计算流程</li></ul><img src="http://dzou.wangminwei.top/static/images/algorithm/30.png"><pre><code class="java">public int napzack01_first(int []w,int []v,int V,int N){        int [][]dp = new int[N][V+1];        for(int i=0;i&lt;N;i++)            for(int j=1;j&lt;=V;j++)                if(j&gt;=v[i])                    if(i==0) dp[0][j] = w[i];                    else dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-v[i]]+w[i]);                else                    dp[i][j] = dp[i-1][j];        return dp[N-1][V];    }</code></pre><p><strong>第一次优化：二维数组优化为一维数组</strong></p><p>我们可以从表格发现，当前行的数据只与上一行的数据有关，所以我们只要每次循环后确保数组保存了上一次计算的结果</p><blockquote><p>问题以及解决：</p><p>我们从当前循环来看，计算体积为<code>5</code>的dp值最多只需要<code>0-4</code>的上一次计算的结果，如果顺序从小到大更新的话，我们计算<code>5</code>时，此时之前的<code>0-4</code>的值都被更新了，不是上一次计算的结果(而是当前计算的结果)，而后面的需要上一次前面的数据；所以我们不能从头开始，而应该从最后开始更新，从后往前，这样可以保证优先更新体积大的值而让体积小的值保留上一次就算的结果。</p></blockquote><pre><code class="java">//1维01背包    public int napzack01_second(int []w,int []v,int V,int N){        int []dp = new int[V+1];        for(int i=0;i&lt;N;i++)            for(int j=V;j&gt;=0;j--)                if(j&gt;=v[i])                    if(i==0) dp[j] = w[i];                    else dp[j] = Math.max(dp[j],dp[j-v[i]]+w[i]);        return dp[V];    }</code></pre><p><strong>全部放满01背包：</strong></p><blockquote><p>我们之前讨论了一种是不要求全部放满的01背包，我们再看如果要求全部放满会有什么不同</p></blockquote><p>如果我们把物品表换成这样：</p><img src="http://dzou.wangminwei.top/static/images/algorithm/32.png"><p>如果我们想要全部放满，就拿不到物品4，即使它价值50，但是我们想要的是要把背包装满，这就涉及到初始化时的问题</p><blockquote><p>我们需要为每一次循环放入物品到j的背包中设置一个能否放满的标志，每次判断这个标志来检查当前物品放入能否使得背包装满</p></blockquote><p><strong>我们只需要在初始化时把一维数组的<code>1-V</code>初始化为<code>-1</code>，表示当前0个物品放入背包，不能装满这些体积的背包，把数组<code>dp[0]</code>正常设置为0，表示体积为0的背包可以被0个物品装满；然后我们在计算数组值时先判断<code>dp[j-v[i]]</code>是否为-1，为-1说明当前物品放入无法装满背包，则不进行修改数组的值；只有不为-1才能继续放入，说明当前物品放入可以放满体积为<code>j</code>的背包</strong></p><img src="http://dzou.wangminwei.top/static/images/algorithm/33.png"><pre><code class="java">//全部放满01背包    public int napzack01_fourth(int []w,int []v,int V,int N){        int []dp = new int[V+1];        for(int i=0;i&lt;dp.length;i++){            dp[i] = -1;        }        dp[0] = 0;        for(int i=0;i&lt;N;i++)            for(int j=V;j&gt;=0;j--)                if(j&gt;=v[i]&amp;&amp;dp[j-v[i]]!=-1)                    dp[j] = Math.max(dp[j],dp[j-v[i]]+w[i]);        return dp[V];    }</code></pre><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p><strong>有N件物品（每个物品都有无限个）和一个容量为V的背包。第i件物品的费用是v[i]，价值是w[i]。求解将哪些物品（每个物品都可以装多个）装入背包可使价值总和最大。</strong></p><ul><li>优化前</li></ul><p>我们每种物品最多有选取<code>V/v[i]</code>个，我们可以再多一次循环，计算选取<code>0-V/v[i]</code>个的最大价值</p><blockquote><p>时间复杂度：每种物品有V/v[i]个，共需要求解N<em>V中状态，时间为O（NV</em>Σ(V/v[i])）</p><p>空间复杂度：O(N)</p></blockquote><p>状态转移方程：</p><p><code>dp[j] = max{dp[j-1],dp[j-k*v[i]]+k*w[i]}</code></p><p><code>code</code></p><pre><code class="java">//完全背包    //状态转移方程 dp[j] = dp[j-k*v[i]]+k*w[i]    public int napzack_complete(int []w,int []v,int N,int V){        int dp[] = new int [V+1];        for(int i=0;i&lt;N;i++)            for(int j=0;j&lt;=V;j++)                for(int k=0;k*v[i]&lt;=j;k++)                    dp[j] = Math.max(dp[j-1],dp[j-k*v[i]]+k*w[i]);        return dp[V];    }</code></pre><ul><li>优化为01背包</li></ul><p><strong>我们记得在优化01背包时，我们为了获取到上一次计算的值，我们选择从后往前计算，但是完全背包<code>正好相反，这才是它此昂要的</code>，完全背包因为需要累计多个同一物品的值，前一次计算可能是1个、2个等等，下一次j变化了以后，计算的可能是3个或者更多，所以我们需要保存实时计算出来的多个同一物品的最大价值，我们选取从前往后的顺序，这样每次前面计算的我们都可以在j增大以后累加获得更多个同一物品的最大价值(根据状态转移方程可知，我们计算一个位置的最大价值只需要当前位置的上一次计算的值和当前次循环内更前面的值)</strong></p><p>例如：</p><p>在我们计算第2个物品dp[5]的时候，物品2的体积为2，价值为5，我们需要上一次计算也就是第一个物品的dp[5]的值，还需要dp[5-2]=dp[3]的值，dp[3]我们在本次循环内计算dp[5]之前就已经算过了，dp[3]可能选了一个物品2，也可能没有选，我们计算dp[5]就根据这个dp[3]的大小在进行选取，就可以进行多次选取。</p><p><code>根本上就是把一类物品转化为多个一种物品</code></p><blockquote><p>我们不需要体积从0开始计算。而只需要在每个物品的循环内从当前物品的最小个数1开始，也就是<code>v[i]</code>（不需要0个是因为初始化的时候已经把体积为0的dp值设置为0了）</p></blockquote><p>参数依然使用</p><img src="http://dzou.wangminwei.top/static/images/algorithm/29.png"><img src="http://dzou.wangminwei.top/static/images/algorithm/34.png"><p><code>code</code></p><pre><code class="java">//把完全背包优化为01背包    public int napzack_comlete01(int []w,int []v,int N,int V){        int dp[] = new int[V+1];        for(int i=0;i&lt;N;i++)            for(int j=v[i];j&lt;=V;j++)                dp[j] = Math.max(dp[j],dp[j-v[i]]+w[i]);        return dp[V];    }</code></pre>]]></content>
    
    <summary type="html">
    
      有N件物品和一个容量为V的背包。第i件物品的费用是v[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。最优子问题就是：将前i个物品放入体积为j的背包中可以获得的最大价值。
    
    </summary>
    
      <category term="算法" scheme="https://www.dzou.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="算法" scheme="https://www.dzou.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://www.dzou.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>netty学习案例—实现websocket长连接和socket之间通信</title>
    <link href="https://www.dzou.top/post/netty-example-5.html"/>
    <id>https://www.dzou.top/post/netty-example-5.html</id>
    <published>2019-10-26T12:32:01.000Z</published>
    <updated>2019-10-27T12:35:34.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="netty学习—实现websocket长连接和socket之间通信"><a href="#netty学习—实现websocket长连接和socket之间通信" class="headerlink" title="netty学习—实现websocket长连接和socket之间通信"></a>netty学习—实现websocket长连接和socket之间通信</h2><p>最近正在学习netty，跟着教程写了一个基于WebSocket的网页聊天室，对netty有了一定的了解，现在正好项目使用到长连接，选用了netty。</p><p><strong>项目目标：客户端A(网页)和服务端通过WebSocket进行通信，客户端B和服务端通过Socket通信，把客户端B的数据传输到客户端A，桥梁为服务端</strong></p><blockquote><p>Socket服务端监听8090端口，长连接服务端监听8089端口，客户端A连接到8089端口，客户端B连接到8090端口</p></blockquote><img src="http://dzou.wangminwei.top/static/images/netty/1.png"><blockquote><p>由于是需要对两个端口数据进行不同处理，所以我们创建两个<code>ServerBootstrap</code>，分别绑定两个端口，一个<code>ServerGzhBootstrap</code>处理客户端B和服务端的socket通信；<code>ServerWxQBootstrap</code>处理客户端A和服务端之间的WebSocket长连接通信</p></blockquote><ul><li><strong><code>ServerInitializer</code>，实现<code>ChannelInitializer</code>，负责初始化客户端B和服务端通信的处理器Handler</strong></li><li><strong><code>WebSocketChannelInitializer</code>，实现<code>ChannelInitializer</code>，负责初始化客户端A和服务端长连接通信的处理器Handler</strong></li><li><strong><code>ServerInitializer</code>添加一个自定义<code>SimpleChannelInboundHandler</code>负责处理客户端B和服务端socket通信</strong></li><li><strong><code>WebSocketChannelInitializer</code>添加一个自定义<code>SimpleChannelInboundHandler</code>负责处理客户端A和服务端WebSocket长连接通信</strong></li></ul><blockquote><p>网页聊天室作为客户端A，客户端B通过Socket通信并接收控制台的输入作为通信数据传递给服务端，服务端再传递给客户端A</p></blockquote><p>问题：</p><p>netty中SimpleChannelInboundHandler类的泛型中指定了传入的消息的类型，只能接收这种类型的消息，客户端B发送的String类型消息与客户端A接收的TextWebSocketFrame类型不同，客户端A无法接收。</p><p>解决方法：</p><p>我们把客户端B发送的String类型消息在Socket服务端接收到，要将其发送给客户端A(需要将其封装成TextWebSocketFrame类型才能发送给客户端A)，而且我们就必须要有客户端A的channel，我们才可以调用<code>writeAndFlush</code>方法把数据写入客户端A</p><p><strong>使用什么可以得到客户端A的channel呢？</strong></p><p>那就是<code>ChannelGroup</code>，我们定义一个类保存全部Channel客户端作为全局ChannelGroup，每次有客户端Channel创建(<code>handlerAdded</code>方法)，我们就把它保存到该全局ChannelGroup中，每次channel使用完毕，ChannelGroup会为我们自动删除其中无用的channel，这样我们就可以获取所有的客户端channel</p><p><strong>任何获取到客户端A的channel？</strong></p><p>客户端A和客户端B很大一个区别就是端口号，我们可以通过端口号来判断是客户端A还是客户端B</p><ul><li>全局ChannelGroup</li></ul><pre><code class="java">public class GlobalChannelGroup {    public static ChannelGroup channelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);}</code></pre><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ul><li>服务端启动器</li></ul><pre><code class="java">public class Server {    public static void main(String[] args) throws InterruptedException {        //两个事件循环组 boss获取连接发送 worker接收处理        EventLoopGroup boss = new NioEventLoopGroup();        EventLoopGroup worker = new NioEventLoopGroup();        try {            //server启动器            ServerBootstrap serverWxQBootstrap = new ServerBootstrap();            ServerBootstrap serverGzhBootstrap = new ServerBootstrap();            // 定义组            // channel(反射)            // 定义处理器(自定义)：连接上channel后执行init            System.out.println(&quot;启动server&quot;);            serverGzhBootstrap.group(boss, worker).channel(NioServerSocketChannel.class)                    .childHandler(new ServerInitializer());            serverWxQBootstrap.group(boss, worker).channel(NioServerSocketChannel.class)                    .childHandler(new WebSocketChannelInitializer());            //绑定端口，同步            ChannelFuture wxq = serverGzhBootstrap.bind(8090).sync();            ChannelFuture gzh = serverWxQBootstrap.bind(8089).sync();            gzh.channel().closeFuture().sync();            wxq.channel().closeFuture().sync();        } finally {            boss.shutdownGracefully();            worker.shutdownGracefully();        }    }}</code></pre><ul><li>服务端Socket端口初始化器</li></ul><pre><code class="java">public class ServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; {    @Override    protected void initChannel(SocketChannel ch) throws Exception {        ChannelPipeline pipeline = ch.pipeline();        pipeline.addLast(new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,0,4,0,4));        pipeline.addLast(new LengthFieldPrepender(4));        pipeline.addLast(new StringDecoder(CharsetUtil.UTF_8));//用于解码        pipeline.addLast(new StringEncoder(CharsetUtil.UTF_8));//用于编码        pipeline.addLast(new ServerHandler());//自定义处理器    }}</code></pre><ul><li>服务端Socket端口通信处理器</li></ul><pre><code class="java">public class ServerHandler extends SimpleChannelInboundHandler&lt;String&gt; {    @Override    protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {        System.out.println(ctx.channel().remoteAddress()+&quot;,&quot;+msg);        ctx.channel().writeAndFlush(&quot;消息已经进入数据库，正在赶往微信墙!&quot;);        GlobalChannelGroup.channelGroup.forEach(o-&gt;{            //如果端口以8089结尾，说明这个channel是客户端A            if (o.localAddress().toString().endsWith(&quot;8089&quot;)){                TextWebSocketFrame text = new TextWebSocketFrame(o.remoteAddress() + &quot;发送消息：&quot; + msg + &quot;\n&quot;);                o.writeAndFlush(text);            }        });    }    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {        cause.printStackTrace();        ctx.close();    }    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception {        System.out.println(ctx.channel().remoteAddress()+&quot;:连接到微信墙模式成功!&quot;);        int size = GlobalChannelGroup.channelGroup.size();        System.out.println(&quot;当前微信墙连接数:&quot;+(size==0?0:size-1));    }    @Override    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {        Channel channel = ctx.channel();        GlobalChannelGroup.channelGroup.add(channel);    }}</code></pre><ul><li>服务端长连接通信端口初始化器</li></ul><pre><code class="java"> public class WebSocketChannelInitializer extends ChannelInitializer&lt;SocketChannel&gt; {    @Override    protected void initChannel(SocketChannel ch) throws Exception {        ChannelPipeline pipeline = ch.pipeline();        pipeline.addLast(new HttpServerCodec());        pipeline.addLast(new ChunkedWriteHandler());        //用于将http数据聚合到一起发送一个请求 fullHttpRequest        pipeline.addLast(new HttpObjectAggregator(8192));        pipeline.addLast(new WebSocketServerProtocolHandler(&quot;/&quot;));//传入websocket path        pipeline.addLast(new TextWebSocketHandler());//传入websocket path    }}</code></pre><ul><li>服务端长连接通信处理器</li></ul><pre><code class="java">public class TextWebSocketHandler extends SimpleChannelInboundHandler&lt;TextWebSocketFrame&gt; {    @Override    protected void channelRead0(ChannelHandlerContext ctx, TextWebSocketFrame msg) throws Exception {        int size = GlobalChannelGroup.channelGroup.size();        System.out.println(&quot;当前微信墙连接数:&quot;+(size==0?0:size-1));        System.out.println(&quot;收到消息：&quot;+msg.text());        Channel channel = ctx.channel();        GlobalChannelGroup.channelGroup.forEach(o-&gt;{            if (o.localAddress().toString().endsWith(&quot;8090&quot;)){                o.writeAndFlush(msg.text());            }else {                TextWebSocketFrame text = new TextWebSocketFrame(o.remoteAddress() + &quot;发送消息：&quot; + msg.text() + &quot;\n&quot;);                o.writeAndFlush(text);            }        });    }    @Override    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {        Channel ch = ctx.channel();        GlobalChannelGroup.channelGroup.add(ch);    }    @Override    public void channelInactive(ChannelHandlerContext ctx) throws Exception {        System.out.println(ctx.channel().remoteAddress()+&quot;:离开聊天室&quot;);    }    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception {        Channel ch = ctx.channel();        System.out.println(ch.remoteAddress()+&quot;：连接到聊天室&quot;);    }    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {        System.out.println(&quot;异常&quot;);        ctx.close();    }}</code></pre><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><blockquote><p>客户端把控制台的标准输入作为参数传入，创建客户端channel时将其发送</p></blockquote><ul><li>客户端B启动器</li></ul><pre><code class="java">public class GzhClient {    public static void main(String[] args) {        EventLoopGroup eventExecutors = null;        ChannelFuture channelFuture = null;        try{//            while (true) {                eventExecutors = new NioEventLoopGroup();                Scanner scanner = new Scanner(System.in);                String json = scanner.nextLine();                Bootstrap bootstrap = new Bootstrap();                bootstrap.group(eventExecutors).channel(NioSocketChannel.class)                        .handler(new GzhClientInitializer(json));                System.out.println(&quot;启动客户端&quot;);                channelFuture = bootstrap.connect(&quot;localhost&quot;, 8090).sync();//            }//            channelFuture.channel().closeFuture().sync();        } catch (InterruptedException e) {            e.printStackTrace();        } finally {            eventExecutors.shutdownGracefully();        }    }}</code></pre><ul><li>客户端B初始化器</li></ul><pre><code class="java">public class GzhClientInitializer extends ChannelInitializer&lt;SocketChannel&gt; {    private String json;    public GzhClientInitializer(String json){        this.json = json;    }    @Override    protected void initChannel(SocketChannel ch) throws Exception {        ChannelPipeline pipeline = ch.pipeline();        pipeline.addLast(new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,0,4,0,4));        pipeline.addLast(new LengthFieldPrepender(4));        pipeline.addLast(new StringDecoder(CharsetUtil.UTF_8));        pipeline.addLast(new StringEncoder(CharsetUtil.UTF_8));        pipeline.addLast(new GzhClientHandler(json));    }}</code></pre><ul><li>客户端B与服务端Socket通信处理器</li></ul><pre><code class="java">public class GzhClientHandler extends SimpleChannelInboundHandler&lt;String&gt; {    private String json;    public GzhClientHandler(String json){        this.json = json;    }    @Override    protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {        System.out.println(&quot;client receive:&quot;+msg);    }    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception {        System.out.println(&quot;进入微信墙模式，清发消息:&quot;);        ctx.writeAndFlush(json);    }}</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ol><li>启动服务端，创建两个客户端B(也就是GzhClient)</li><li>打开聊天室，建立长连接</li><li>两个客户端B从控制台发送消息</li></ol><img src="http://dzou.wangminwei.top/static/images/netty/3.png"><p>服务端接收到消息，打印出来并准备转发给客户端A(也就是网页聊天室)</p><img src="http://dzou.wangminwei.top/static/images/netty/2.png"><p>网页聊天室接收到服务端发送的消息</p><img src="http://dzou.wangminwei.top/static/images/netty/4.png">]]></content>
    
    <summary type="html">
    
      最近正在学习netty，跟着教程写了一个基于WebSocket的网页聊天室，对netty有了一定的了解，现在正好项目使用到长连接，选用了netty。客户端A(网页)和服务端通过WebSocket进行通信，客户端B和服务端通过Socket通信，把客户端B的数据传输到客户端A，桥梁为服务端
    
    </summary>
    
      <category term="netty" scheme="https://www.dzou.top/categories/netty/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="NIO" scheme="https://www.dzou.top/tags/NIO/"/>
    
      <category term="网络通信" scheme="https://www.dzou.top/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
      <category term="netty" scheme="https://www.dzou.top/tags/netty/"/>
    
      <category term="异步" scheme="https://www.dzou.top/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>多次尝试的学习—搞懂NIO</title>
    <link href="https://www.dzou.top/post/nonblocking-io.html"/>
    <id>https://www.dzou.top/post/nonblocking-io.html</id>
    <published>2019-10-26T11:32:01.000Z</published>
    <updated>2019-10-27T09:18:03.232Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NIO—NonBlocking-IO-new-IO"><a href="#NIO—NonBlocking-IO-new-IO" class="headerlink" title="NIO—NonBlocking IO(new IO)"></a>NIO—NonBlocking IO(new IO)</h2><ol><li>io面向流编程，只能作为输入或者输出流的一种，是同步阻塞的，每一个连接过来都要创建一个线程去处理，线程上下文切换开销很大，造成了很大的瓶颈</li><li>于是有了线程池实现的伪阻塞IO，一定程度解决了线程创建过多的问题，但是没有从根本上解决阻塞的问题，并且线程过多而线程池过小时也会造成很大的瓶颈</li><li>既然根本瓶颈原因是线程数和阻塞IO，那么我们有没有办法只用1个线程去处理多个客户端连接呢？这就是NIO出现的原因</li></ol><p>NIO主要有<strong>三个核心部分组成</strong>：</p><ul><li><strong>buffer缓冲区</strong></li><li><strong>Channel管道</strong></li><li><strong>Selector选择器</strong></li></ul><blockquote><p>nio面向block块，buffer缓冲区编程，底层是数组，buffer提供数据访问，channel读写到buffer，buffer读写到channel，从buffer读取到程序channel是双向的</p><p>理解NIO需要理解事件编程模型</p></blockquote><p>NIO核心：</p><p>NIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的（没有可干的事情必须要阻塞），剩余的I/O操作都是纯CPU操作，没有必要开启多线程。</p><blockquote><p>单线程处理I/O的效率确实非常高，没有线程切换，只是拼命的读、写、选择事件。</p></blockquote><p>NIO带个我们：</p><ol><li>事件驱动模型—异步编程都离不开事件</li><li>单线程处理多连接—多路复用使得处理更加高效</li><li>非阻塞IO，只阻塞获取可操作事件</li><li>基于block传输比基于流传输更加高效</li><li>零拷贝—DirectBuffer</li></ol><p>缺点：</p><p>NIO并没有完全屏蔽平台差异，它仍然是基于各个操作系统的I/O系统实现的，差异仍然存在。使用NIO做网络编程构建事件驱动模型并不容易，陷阱重重。</p><blockquote><p>推荐使用NIO成熟框架Netty</p></blockquote><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p><strong>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。</strong></p><h4 id="Capacity、Position、Limit"><a href="#Capacity、Position、Limit" class="headerlink" title="Capacity、Position、Limit"></a>Capacity、Position、Limit</h4><img src="http://dzou.wangminwei.top/static/images/nio/1.png"><p>0 <code>&lt;=</code> <em>mark</em> <code>&lt;=</code> <em>position</em> <code>&lt;=</code> <em>limit</em> <code>&lt;=</code> <em>capacity</em></p><ul><li>capacity</li></ul><blockquote><p>作为一个内存块，Buffer有一个固定的大小值，也叫“capacity”.你只能往里写capacity个byte、long，char等类型。一旦Buffer满了，需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据。</p></blockquote><ul><li>position</li></ul><blockquote><p>当你写数据到Buffer中时，position表示当前的位置。初始的position值为0.当一个byte、long等数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity – 1.</p></blockquote><p>当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式，position会被重置为0. 当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。</p><ul><li>limit</li></ul><blockquote><p>在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。 写模式下，limit等于Buffer的capacity。</p></blockquote><p>当切换Buffer到读模式时， limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。换句话说，你能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是position）</p><p><strong>同一个buffer可以存储不同数据类型的数据，但是获取的时候要指定类型获取</strong></p><pre><code class="java">ByteBuffer buffer = ByteBuffer.allocate(1024);buffer.putInt(1);buffer.putLong(387524875628742L);buffer.putChar(&#39;s&#39;);buffer.flip();System.out.println(buffer.getInt());System.out.println(buffer.getLong());System.out.println(buffer.getChar());</code></pre><blockquote><p>put方法只能放入byte型，不能放入int</p></blockquote><h4 id="flip、clear、rewind、mark"><a href="#flip、clear、rewind、mark" class="headerlink" title="flip、clear、rewind、mark"></a>flip、clear、rewind、mark</h4><ul><li>flip</li></ul><p><strong>flip方法将Buffer从写模式切换到读模式。调用flip()方法会将position设回0，并将limit设置成之前position的值。</strong></p><pre><code class="java">    public final Buffer flip() {        this.limit = this.position;        this.position = 0;        this.mark = -1;        return this;    }</code></pre><ul><li>clear</li></ul><p><strong>position将被设回0，limit被设置成 capacity的值。换句话说，Buffer 被清空了。Buffer中的数据并未清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据。</strong></p><pre><code class="java">    public final Buffer clear() {        this.position = 0;        this.limit = this.capacity;        this.mark = -1;        return this;    }</code></pre><ul><li>rewind</li></ul><p><strong>Buffer.rewind()将position设回0，所以你可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素</strong></p><pre><code class="java">    public final Buffer rewind() {        this.position = 0;        this.mark = -1;        return this;    }</code></pre><ul><li>mark</li></ul><p><strong>可以标记Buffer中的一个特定position。之后可以通过调用Buffer.reset()方法恢复到这个position。</strong></p><pre><code class="java">    public final Buffer mark() {        this.mark = this.position;        return this;    }</code></pre><ul><li>slice分片</li></ul><p>将buffer根据设置的position和limit分片一个buffer，有自己的position、limit和capacity，数据共用一个内存地址的buffer数据</p><pre><code class="java">public static void test2(){        ByteBuffer buffer = ByteBuffer.allocate(1024);        for(int i=0;i&lt;buffer.capacity();i++){            buffer.put((byte)i);        }        buffer.position(10);        buffer.limit(20);        ByteBuffer buffer1 = buffer.slice();//buffer分片        for(int m=0;m&lt;buffer1.capacity();m++){            byte b = buffer1.get();            System.out.print(b+&quot; &quot;);        }    }输出：10 11 12 13 14 15 16 17 18 19</code></pre><h4 id="ReadOnlyBuffer"><a href="#ReadOnlyBuffer" class="headerlink" title="ReadOnlyBuffer"></a>ReadOnlyBuffer</h4><p>普通的Buffer(可读可写)可以随时转换为只读Buffer，但是只读Buffer不可以转换为普通Buffer</p><pre><code class="java">ByteBuffer readOnlyBuffer = buffer.asReadOnlyBuffer();</code></pre><blockquote><p>转换后的Buffer是一个新的只读Buffer，拥有独立的position、limit和capacity</p></blockquote><h4 id="DirectBuffer"><a href="#DirectBuffer" class="headerlink" title="DirectBuffer"></a>DirectBuffer</h4><p><code>堆外内存buffer，本地JNI非JVM堆内存buffer，允许直接访问</code></p><p>普通ByteBuffer由JVM管理，在JVM堆上分配内存</p><pre><code class="java">ByteBuffer buf = ByteBuffer.allocate(1024);</code></pre><p>DirectBuffer会在本地内存中分配，脱离JVM的堆管理</p><pre><code class="java">ByteBuffer buf = ByteBuffer.allocateDirect(1024);</code></pre><blockquote><p>为什么要这样做呢？</p><p>———-又是GC——–</p><p>我们都知道JVM 在堆上的老年代中，GC时会采取<code>标记-整理</code>策略，会使得对象在堆内存中的地址发生变化，整理时会buffer太大时会很难gc整理</p></blockquote><p>所以出现了<code>DirectBuffer</code>，它使用<code>unsafe.allocateMemory</code>分配内存，是一个native方法，由buffer的<code>address</code>变量记录这个内存的地址来提供访问</p><h5 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h5><ul><li>DirectBuffer：本地方法分配内存显然没有JVM堆分配快，但是涉及<code>IO</code>和<code>网络IO</code>的话就是DirectBuffer比较快了</li></ul><blockquote><p>DirectByteBuffer继承了MappedByteBuffer</p><p>缓存的使用可以使用DirectByteBuffer和HeapByteBuffer。如果使用了DirectByteBuffer，一般来说可以减少一次系统空间到用户空间的拷贝。</p><p>数据量比较小的中小应用情况下，可以考虑使用heapBuffer；反之可以用directBuffer</p></blockquote><h4 id="MappedByteBuffer"><a href="#MappedByteBuffer" class="headerlink" title="MappedByteBuffer"></a>MappedByteBuffer</h4><p><strong>映射到堆外内存的ByteBuffer，DirectByteBuffer继承此类实现堆外内存的分配</strong></p><p>通过下面方式映射buffer到堆外内存</p><pre><code class="java">MappedByteBuffer mappedByteBuffer = channel.map(MapMode.READ_WRITE, 0, channel.size());</code></pre><p>使用拷贝文件：</p><pre><code class="java">RandomAccessFile in = new RandomAccessFile(&quot;nio/1.txt&quot;, &quot;rw&quot;);RandomAccessFile out = new RandomAccessFile(&quot;nio/2.txt&quot;, &quot;rw&quot;);FileChannel inChannel = in.getChannel();FileChannel outChannel = out.getChannel();MappedByteBuffer inputData = inChannel.map(FileChannel.MapMode.READ_ONLY,0,new File(&quot;nio/1.txt&quot;).length());Charset charset = Charset.forName(&quot;utf-8&quot;);//编码CharsetDecoder decoder = charset.newDecoder();CharsetEncoder encoder = charset.newEncoder();CharBuffer charBuffer = decoder.decode(inputData);ByteBuffer buffer = encoder.encode(charBuffer);outChannel.write(buffer);in.close();out.close();</code></pre><h3 id="Channel—通道"><a href="#Channel—通道" class="headerlink" title="Channel—通道"></a>Channel—通道</h3><h4 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h4><p>NIO提供的一种连接到文件的通道，用于文件的读写</p><p><strong>在使用FileChannel时，需要从<code>输入输出流或者RandomAccessFile</code>中获取FIleChannel</strong></p><ul><li>如果要向FileChannel中读取数据，需要申请一个ByteBuffer，将数据从FileChannel中读取到缓冲区ByteBuffer，<code>read()</code>返回多少个字节被读取，如果返回-1说明文件已经到达末尾</li><li>如果要向FileChannel中写入数据，需要先将数据写入到ByteBuffer中，在从ByteBuffer中写入到FileChannel中，调用<code>write()</code>方法</li></ul><blockquote><p>注意读写之间需要Buffer.flip();</p></blockquote><p>例子：</p><p>1.读取文件数据并打印</p><pre><code class="java">FileInputStream fileInputStream = new FileInputStream(&quot;1.log&quot;);FileChannel channel = fileInputStream.getChannel();ByteBuffer byteBuffer = ByteBuffer.allocate(512);;channel.read(byteBuffer);byteBuffer.flip();while(byteBuffer.remaining()&gt;0){    byte b = byteBuffer.get();    System.out.println((char) b);}fileInputStream.close();</code></pre><p>2.把1.txt数据写入2.txt</p><pre><code class="java">FileInputStream inputStream = new FileInputStream(&quot;1.txt&quot;);FileChannel in = inputStream.getChannel();FileOutputStream outputStream = new FileOutputStream(&quot;2.txt&quot;);FileChannel out = outputStream.getChannel();ByteBuffer byteBuffer = ByteBuffer.allocate(1024);while(true){    byteBuffer.clear();//没有的话会一直读取    int read = in.read(byteBuffer);    System.out.println(&quot;read:&quot;+read);    if(read==-1){        break;//为-1表示文件结束 返回    }    byteBuffer.flip();    out.write(byteBuffer);}inputStream.close();outputStream.close();</code></pre><h4 id="ServerSockerChannel"><a href="#ServerSockerChannel" class="headerlink" title="ServerSockerChannel"></a>ServerSockerChannel</h4><p>NIO提供了一种可以监听新进入的TCP连接的通道，就是<code>ServerSocketChannel</code>，对应IO中<code>ServerSocket</code></p><ul><li>打开监听通道</li></ul><pre><code class="java">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();serverSocketChannel.socket().bind(new InetSocketAddress(9999));while(true){    SocketChannel socketChannel = serverSocketChannel.accept();    //do something with socketChannel...}</code></pre><h4 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h4><p>NIO提供的一种连接到TCP套接字的通道，就是<code>SocketChannel</code>，对应IO中<code>Socket</code></p><ul><li>打开一个SocketChannel</li></ul><pre><code class="java">SocketChannel socketChannel = SocketChannel.open();socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));</code></pre><h4 id="Channel读写"><a href="#Channel读写" class="headerlink" title="Channel读写"></a>Channel读写</h4><ul><li>读</li></ul><pre><code class="java">ByteBuffer buf = ByteBuffer.allocate(48);int bytesRead = socketChannel.read(buf);</code></pre><ul><li>写</li></ul><pre><code class="java">ByteBuffer writeBuffer = ByteBuffer.allocate(48);String msg = &quot;hello&quot;;writeBuffer.put(msg.getBytes());writeBuffer.flip();channel.write(writeBuffer);</code></pre><ul><li>读完写</li></ul><pre><code class="java">ByteBuffer buffer = ByteBuffer.allocate(1024);int byteRead = channel.read(buffer);if(byteRead&lt;=0){    channel.close();    break;}buffer.flip();channel.write(buffer);read += byteRead;buffer.clear();</code></pre><blockquote><p>每次写完buffer，如果buffer数据不需要再使用，建议clear清空buffer，准备下一次写操作</p></blockquote><h3 id="Selector—多路复用器-选择器"><a href="#Selector—多路复用器-选择器" class="headerlink" title="Selector—多路复用器(选择器)"></a>Selector—多路复用器(选择器)</h3><p><strong>多路复用器，这个名字很形象，使用一个线程去处理多个channel，从而管理多个channel</strong></p><blockquote><p>为什么要使用一个线程管理多个channel？</p><p>线程上下文切换开销很大，线程越少处理channel更高效</p></blockquote><img src="http://dzou.wangminwei.top/static/images/nio/2.png"><h4 id="创建Selector—创建比赛"><a href="#创建Selector—创建比赛" class="headerlink" title="创建Selector—创建比赛"></a>创建Selector—创建比赛</h4><pre><code class="java">Selector selector = Selector.open();</code></pre><h4 id="注册channel—购买入场卷"><a href="#注册channel—购买入场卷" class="headerlink" title="注册channel—购买入场卷"></a>注册channel—购买入场卷</h4><p>channel通过注册到selector上来把channel的事件交给Selector管理，并且返回一个SelectionKey</p><pre><code class="java">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</code></pre><ul><li>与 Selector 一起使用时，Channel 必须处于<code>非阻塞模式</code>下。这意味着不能将 FileChannel 与 Selector 一起使用，因为 FileChannel 不能切换到非阻塞模式</li></ul><pre><code class="java">channel.configureBlocking(false);</code></pre><ul><li>通过SelectionKey获取channel和selector以及准备好的事件</li></ul><pre><code class="java">Channel  channel  = selectionKey.channel();Selector selector = selectionKey.selector();</code></pre><h4 id="Selector执行选择—拿着入场卷入场"><a href="#Selector执行选择—拿着入场卷入场" class="headerlink" title="Selector执行选择—拿着入场卷入场"></a>Selector执行选择—拿着入场卷入场</h4><p>把channel注册到Selector后，我们可以使用<code>Selector.select();</code>方法获取准备就绪的通道，返回一个int型整数，表示准备好的channel数</p><p>通过<code>selector.selectedKeys();</code>方法获取准备就绪的SelectionKey，再通过SelectionKey获取channel和selector，一般使用迭代器遍历这些准备好的channel</p><blockquote><p>在每一次处理完一个SelectionKey，必须把它从迭代器中删除，处理完，这个SelectionKey就没有用了，就像一个入场卷，你可以通过它进入赛场并且它上面有入场人和座位对应信息，比赛结束后你无法再通过它执行任何有效的操作。</p></blockquote><ul><li>看完比赛，举办者不会回收所有的票据，需要你们自己处理，不能乱丢在场地中，需要自己丢到垃圾桶中或者带回家</li></ul><pre><code class="java">iterator.remove()；</code></pre><ul><li>wakeUp()方法</li></ul><p>某个线程调用 select() 方法后阻塞了，即使没有通道已经就绪，也无法返回，wakeUp方法使得立马返回。</p><h3 id="Scatter、Gather"><a href="#Scatter、Gather" class="headerlink" title="Scatter、Gather"></a>Scatter、Gather</h3><blockquote><p>scatter / gather 经常用于需要将传输的数据分开处理的场合，例如传输一个由消息头和消息体组成的消息，你可能会将消息体和消息头分散到不同的 buffer 中，这样你可以方便的处理消息头和消息体。</p></blockquote><h4 id="Scatter"><a href="#Scatter" class="headerlink" title="Scatter"></a>Scatter</h4><p>分散（scatter）从 Channel 中读取是指在读操作时将读取的数据写入多个 buffer 中。因此，Channel 将从 Channel 中读取的数据 “分散（scatter）” 到多个 Buffer 中。</p><h4 id="Gather"><a href="#Gather" class="headerlink" title="Gather"></a>Gather</h4><p>聚集（gather）写入 Channel 是指在写操作时将多个 buffer 的数据写入同一个 Channel，因此，Channel 将多个 Buffer 中的数据 “聚集（gather）” 后发送到 Channel。</p><p>例子：用三个长度分别为3,4,5的buffer存储输入的字符串，前3个字符存储在第一个buffer，4-7字符存储在第二个buffer，长度为4,8-12存储在第三个buffer，长度为5</p><pre><code class="java">ServerSocketChannel serverSocketChannel =  ServerSocketChannel.open();        InetSocketAddress inetSocketAddress = new InetSocketAddress(8899);        serverSocketChannel.socket().bind(inetSocketAddress);        int messageLength = 3 + 4 + 5;        ByteBuffer[] byteBuffer = new ByteBuffer[3];        byteBuffer[0] = ByteBuffer.allocate(3);        byteBuffer[1] = ByteBuffer.allocate(4);        byteBuffer[2] = ByteBuffer.allocate(5);        SocketChannel socketChannel = serverSocketChannel.accept();        while (true){            int byteRead = 0;            while (byteRead&lt;messageLength){                long r = socketChannel.read(byteBuffer);                byteRead += r;                System.out.println(&quot;byteread:&quot;+byteRead);                Arrays.stream(byteBuffer).map(o-&gt;&quot;position:&quot;+o.position()+&quot;,limit:&quot;+o.limit()).forEach(System.out::println);            }            Arrays.stream(byteBuffer).forEach(Buffer::flip);            int byteWrite = 0;            while(byteWrite&lt;messageLength){                long r = socketChannel.write(byteBuffer);                byteWrite += r;                System.out.println(&quot;bytewrite:&quot;+byteWrite);                Arrays.stream(byteBuffer).map(o-&gt;&quot;position:&quot;+o.position()+&quot;,limit:&quot;+o.limit()).forEach(System.out::println);            }            Arrays.stream(byteBuffer).forEach(Buffer::clear);        }测试：使用linux nc localhost 8899测试输入：helloworld回车 输出：byteread:11position:3,limit:3position:4,limit:4position:4,limit:5解释：回车算一个字符一共11个字符，前三个存储到第一个buffer了，存满了；中间四个存储到第二个buffer，存满了；剩下多余的存储到第三个buffer，没有存满</code></pre><h3 id="NIO服务端客户端"><a href="#NIO服务端客户端" class="headerlink" title="NIO服务端客户端"></a>NIO服务端客户端</h3><p>这个程序演示使用NIO创建一个聊天室，服务端和多个客户端连接，客户端可以互发消息</p><ul><li>server服务端</li></ul><pre><code class="java">/** * 可以直接使用 linux nc命令当做客户端 * nc localhost 端口 */public class Server {    private static Map&lt;SocketChannel,String&gt; clientMap = new HashMap&lt;&gt;();    public static void main(String[] args) throws IOException {        //打开服务器channel        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();        //设置非阻塞 即将使用selector        serverSocketChannel.configureBlocking(false);        //获取服务器的socket        ServerSocket serverSocket = serverSocketChannel.socket();        //绑定端口        serverSocket.bind(new InetSocketAddress(8089));        //打开一个多路复用器，使用一条线程处理客户端channel        Selector selector = Selector.open();        //注册服务器channel到        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);        while (true){            //阻塞获取channel事件            //一旦调用了 select() 方法，并且返回值表明有一个或更多个通道就绪了            int num = selector.select();            /**             * 获取到后 拿到多路复用器的SelectionKey 核心方法channel获取注册在起上的channel             * SelectionKey 每次注册一个channel都会创建一个SelectionKey 其中常量定义channel状态            **/            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();            //对其中每一个SelectionKey进行操作            selectionKeys.forEach(selectionKey-&gt;{                    try {                        //如果该服务器SelectionKey被接收                        if(selectionKey.isAcceptable()){                            //拿到服务器channel                            ServerSocketChannel server = (ServerSocketChannel) selectionKey.channel();                            SocketChannel client = null;                            //拿到本次连接上服务器的客户端                            client = server.accept();                            client.configureBlocking(false);                            //把客户端注册到多路复用器，监听客户端的可读事件                            client.register(selector,SelectionKey.OP_READ);                            //为每个客户端分配id                            String key = &quot;[&quot;+ UUID.randomUUID()+&quot;]&quot;;                            clientMap.put(client,key);                            //如果SelectionKey读就绪，执行读操作                        }else if(selectionKey.isReadable()){                            //拿到channel                            SocketChannel channel = (SocketChannel) selectionKey.channel();                            //创建读buffer                            ByteBuffer readBuffer = ByteBuffer.allocate(1024);                            //读取channel中数据到读buffer                            int read = channel.read(readBuffer);                            String reMsg = &quot;&quot;;                            //如果有数据                            if(read&gt;0){                                //翻转进行写操作                                readBuffer.flip();                                //制定解码集utf-8，对读buffer解码打印                                Charset charset = Charset.forName(&quot;utf-8&quot;);                                reMsg = String.valueOf(charset.decode(readBuffer).array());                                System.out.println(clientMap.get(channel)+&quot; receive: &quot;+reMsg);                            }else if(read==-1) channel.close();//如果客户端关闭就关闭客户端channel                            //群发：发送数据到其他客户端channel                            for(SocketChannel ch:clientMap.keySet()){                                if(ch!=channel) {                                    String key = clientMap.get(ch);                                    ByteBuffer writeBuffer = ByteBuffer.allocate(1024);                                    writeBuffer.put((&quot;来自&quot;+key + &quot;:&quot; + reMsg).getBytes());                                    writeBuffer.flip();                                    ch.write(writeBuffer);                                }                            }                        }                    } catch (IOException e) {                        e.printStackTrace();                }            });            selectionKeys.clear();//每次处理完一个SelectionKey的事件，把该SelectionKey删除        }    }}</code></pre><ul><li>客户端</li></ul><pre><code class="java">public class Client {    public static void main(String[] args) throws IOException {        //打开客户端channel        SocketChannel socketChannel = SocketChannel.open();        //设置为非阻塞模式，可以配合selector使用        socketChannel.configureBlocking(false);        //打开selector        Selector selector = Selector.open();        //注册客户端channel到多路复用器，监听连接事件        socketChannel.register(selector, SelectionKey.OP_CONNECT);        //连接到指定地址        socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;,8089));        while (true){            try{                    //执行selector方法，阻塞获取channel事件的触发                    int num = selector.select();                    //获取注册到多路复用器上的SelectionKey                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();                    //通过迭代器遍历SelectionKey                    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();                    while (iterator.hasNext()) {                        SelectionKey selectionKey = iterator.next();                        //如果SelectionKey触发的事件为连接就绪                        if(selectionKey.isConnectable()){                            //拿到SelectionKey的客户端channel                            SocketChannel client = (SocketChannel) selectionKey.channel();                            if(client.isConnectionPending()){                                //完成连接                                client.finishConnect();                                //新建一个写buffer                                ByteBuffer writeBuffer = ByteBuffer.allocate(1024);                                //写入客户端连接成功消息                                writeBuffer.put((client.toString()+&quot;:连接成功!&quot;).getBytes());                                //翻转读写操作 执行写操作                                writeBuffer.flip();                                //写入buffer数据刅客户端                                client.write(writeBuffer);                                //开辟一个线程写，因为标准输入是阻塞的，当前线程不能阻塞写                                ExecutorService executorService = Executors.newSingleThreadExecutor();                                executorService.submit(()-&gt;{                                    while (true){                                        writeBuffer.clear();                                        InputStreamReader reader = new InputStreamReader(System.in);                                        BufferedReader br = new BufferedReader(reader);                                        String msg = br.readLine();                                        //每次读入一行，写入数据到buffer并且写入客户端channel                                        writeBuffer.put(msg.getBytes());                                        writeBuffer.flip();                                        client.write(writeBuffer);                                    }                                });                            }                            //注册客户端可读事件到多路复用器                            client.register(selector,SelectionKey.OP_READ);                            //如果多路复用器上的SelectionKey处于读就绪状态                        }else if(selectionKey.isReadable()){                            //拿到SelectionKey触发相应事件对应的客户端channel，执行读操作                            SocketChannel client = (SocketChannel) selectionKey.channel();                            //创建一个新的读buffer，                            ByteBuffer readBuffer = ByteBuffer.allocate(1024);                            //从准备好读操作的channel中读取数据                            int count = client.read(readBuffer);                            if (count&gt;0){                                //转码并数据使用String保存且打印                                String reMsg = new String(readBuffer.array(),0,count);                                System.out.println(reMsg);                            }else if(count==-1) client.close();//关闭客户端                        }                    }                    selectionKeys.clear();//每次处理完一个SelectionKey的事件，把该SelectionKey删除                }            catch (Exception e){                e.printStackTrace();            }        }    }}</code></pre><ul><li>测试</li></ul><p><strong>1.创建一个服务端和三个客户端</strong></p><p><strong>2.客户端1,2,3分别发送数据</strong></p><p>服务端拿到连接信息和三个客户端发送信息</p><img src="http://dzou.wangminwei.top/static/images/nio/6.png"><p>客户端1先创建，拿到2,3连接信息和2,3发送信息</p><img src="http://dzou.wangminwei.top/static/images/nio/3.png"><p>客户端2先于3创建，拿到3连接信息和1,3发送信息</p><img src="http://dzou.wangminwei.top/static/images/nio/4.png"><p>客户端3最后创建，只能拿到1,2发送信息</p><img src="http://dzou.wangminwei.top/static/images/nio/5.png"><p><strong>3.此时再使用nc命令创建一个客户端</strong></p><p>发送信息，客户端可以收到</p><img src="http://dzou.wangminwei.top/static/images/nio/8.png"><p>客户端2发送信息，该终端客户端也可以收到</p><img src="http://dzou.wangminwei.top/static/images/nio/7.png"><h3 id="NIO案例—跨端口传输数据—MultiServer"><a href="#NIO案例—跨端口传输数据—MultiServer" class="headerlink" title="NIO案例—跨端口传输数据—MultiServer"></a>NIO案例—跨端口传输数据—MultiServer</h3><p><strong>实现目标：服务端监听两个端口，一个8089，一个8090,8089只有唯一的一个主客户端A连接，8090有多个客户端B连接，客户端A接收多个客户端B连接的发送的消息，实现跨端口的消息转发</strong></p><img src="http://dzou.wangminwei.top/static/images/nio/9.png"><ul><li><strong>服务端</strong></li></ul><p>我们先看服务端，服务端首先需要监听两个端口，我们创建两个服务端channel；服务端接收到连接后监听客户端B的发送数据事件(也就是客户端writable服务端readable事件)；拿到客户端B的消息后，把它发送到客户端A</p><blockquote><p>服务端怎么发送数据到客户端A？</p><p>保存一个客户端channel集合，为不同端口客户端分配不同的id的结尾部分，客户端A分配为wxq]，客户端B分配为gzh]，在他们channel创建的时候保存到HashMap中，channel作为key，id作为值保存</p></blockquote><p><strong>下面说一下服务端流程：</strong></p><ol><li>创建两个服务端channel，绑定不同端口</li><li>创建一个多路复用器selector，把两个服务端注册到selector上，并监听acceptable事件</li><li>执行selector.select()方法，拿到SelectionKey集合，对不同事件做不停处理<ol><li>如果事件为<code>接收就绪</code>，通过<code>SelectionKey.channel()</code>方法拿到服务端channel，根据端口不同注册不同的监听事件，如果是8090的，说明是客户端B的连接完成，拿到客户端B的channel，监听它的<code>可读事件</code>，并且分配id后缀为gzh]并且保存；如果是8089端口的服务端channel，说明是客户端A的连接完成，客户端客户端A的channel，监听它的<code>可写事件</code>，并且分配id后缀为wxq]，保存到hashmap</li><li>如果事件是<code>读就绪</code>，说明客户端B已经完后数据的写操作，可以读取客户端B的数据，执行读取；首先把数据读取并写入到<code>readBuffer</code>，使用<code>new String(readBuffer.array()</code>创建即将发送的msg，遍历客户端channel的key，如果后缀为wxq]，说明是客户端A，则把数据写入writeBuffer中，并把数据写入客户端A的channel中</li></ol></li><li>每次SelectionKey的事件执行完毕，把该SelectionKey删除</li></ol><p><strong>代码：</strong></p><pre><code class="java">public class Server {    private static int CAPACITY = 1024;    private static ByteBuffer readBuffer = ByteBuffer.allocate(CAPACITY);    private static ByteBuffer writeBuffer = ByteBuffer.allocate(CAPACITY);    private static Map&lt;SocketChannel,String&gt; clientMap = new HashMap&lt;&gt;();    public static void main(String[] args) throws IOException {        ServerSocketChannel serverSocketChannelWxq = ServerSocketChannel.open();        ServerSocketChannel serverSocketChannelGzh = ServerSocketChannel.open();        serverSocketChannelGzh.configureBlocking(false);        serverSocketChannelWxq.configureBlocking(false);        ServerSocket serverSocketWxq = serverSocketChannelWxq.socket();        ServerSocket serverSocketGzh = serverSocketChannelGzh.socket();        serverSocketWxq.bind(new InetSocketAddress(8089));        System.out.println(&quot;监听8089：微信墙服务端口&quot;);        serverSocketGzh.bind(new InetSocketAddress(8090));        System.out.println(&quot;监听8090：公众号服务端口&quot;);        Selector selector = Selector.open();        serverSocketChannelWxq.register(selector, SelectionKey.OP_ACCEPT);        serverSocketChannelGzh.register(selector, SelectionKey.OP_ACCEPT);        while (true){            int num = selector.select();            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();            selectionKeys.forEach(selectionKey-&gt;{                try {                    if(selectionKey.isAcceptable()){                        ServerSocketChannel server = (ServerSocketChannel) selectionKey.channel();                        SocketChannel client = null;                        client = server.accept();                        client.configureBlocking(false);                        String key = &quot;&quot;;                        if(server==serverSocketChannelGzh) {//如果是公众号server，注册其客户端的可读事件                            client.register(selector, SelectionKey.OP_READ);                            key = &quot;[&quot;+ UUID.randomUUID()+&quot;:gzh]&quot;;                        }else if(server==serverSocketChannelWxq){//如果是                            client.register(selector,SelectionKey.OP_WRITE);                            key = &quot;[&quot;+ UUID.randomUUID()+&quot;:wxq]&quot;;                        }                        System.out.println(key+&quot;:连接成功!&quot;);                        clientMap.put(client,key);                    }else if(selectionKey.isReadable()){                        SocketChannel channel = (SocketChannel) selectionKey.channel();                        readBuffer.clear();                        int read = 0;                        while(true){                            int byteRead = channel.read(readBuffer);                            if(byteRead&lt;=0){                                break;                            }                            readBuffer.flip();                            channel.write(readBuffer);                            read += byteRead;                            readBuffer.clear();                        }                        String reMsg = new String(readBuffer.array(),0,read);                        System.out.println(clientMap.get(channel)+&quot; send to wxq: &quot;+reMsg);                        //写入微信墙服务                        for(SocketChannel ch:clientMap.keySet()){                            if(ch!=channel) {                                String key = clientMap.get(ch);                                if(key.endsWith(&quot;wxq]&quot;)) {                                    writeBuffer.clear();                                    writeBuffer.put((&quot;来自&quot; + clientMap.get(channel) + &quot;:&quot; + reMsg).getBytes(StandardCharsets.UTF_8));                                    writeBuffer.flip();                                    ch.write(writeBuffer);                                }                            }                        }                    }                } catch (IOException e) {                    e.printStackTrace();                }            });            selectionKeys.clear();//每次处理完一个SelectionKey的事件，把该SelectionKey删除        }    }}</code></pre><p><strong>到此，服务端写完了，你就可以使用linux或者win下的<code>nc</code>命令连接到服务端，模拟客户端A和客户端B发送消息</strong></p><img src="http://dzou.wangminwei.top/static/images/nio/10.png"><img src="http://dzou.wangminwei.top/static/images/nio/11.png"><blockquote><p>客户端发送消息后会会写一条是因为我在接收到消息后把消息写入客户端B的buffer中了</p></blockquote><ul><li><strong>客户端B—发送消息</strong></li></ul><p>客户端B负责发送消息，主要事件就是负责写数据</p><p>流程：</p><ol><li>创建一个客户端channel<code>SocketChannel</code>，打开一个多留复用器selector，绑定<code>可连接事件</code>，连接到服务端监听的8090端口</li><li>执行<code>selector.select()</code>方法，处理<code>连接就绪</code>和<code>写就绪两个事件</code><ol><li>如果事件为<code>连接就绪</code>，只需要拿到channel，执行<code>finishConnect</code>方法完成连接，并且注册监听事件为<code>可写事件</code></li><li>如果事件为<code>写就绪</code>，执行写操作，使用标准输入从控制台读取输入并且写入writebuffer中，通过<code>channel.write()</code>方法写入数据到客户端</li></ol></li><li>清理事件的SelectionKey</li></ol><p><strong>代码：</strong></p><pre><code class="java">public class GzhClient {    public static void main(String[] args) throws IOException {        SocketChannel socketChannel = SocketChannel.open();        socketChannel.configureBlocking(false);        Selector selector = Selector.open();        socketChannel.register(selector, SelectionKey.OP_CONNECT);        socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;,8090));        while (true){            try{                int num = selector.select();                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();                while (iterator.hasNext()) {                    SelectionKey selectionKey = iterator.next();                    if(selectionKey.isConnectable()){                        SocketChannel client = (SocketChannel) selectionKey.channel();                        if(client.isConnectionPending()){                            client.finishConnect();                        }                        client.register(selector,SelectionKey.OP_WRITE);                    }else if(selectionKey.isWritable()){                        SocketChannel client = (SocketChannel) selectionKey.channel();                        ByteBuffer writeBuffer = ByteBuffer.allocate(1024);                        writeBuffer.clear();                        InputStreamReader reader = new InputStreamReader(System.in);                        BufferedReader br = new BufferedReader(reader);                        String msg = br.readLine();                        //每次读入一行，写入数据到buffer并且写入客户端channel                        writeBuffer.put(msg.getBytes());                        writeBuffer.flip();                        client.write(writeBuffer);                    }                }                selectionKeys.clear();//每次处理完一个SelectionKey的事件，把该SelectionKey删除            }            catch (Exception e){                e.printStackTrace();            }        }    }}</code></pre><ul><li><strong>客户端A—接收服务端转发消息</strong></li></ul><p>客户端A负责发送消息，主要事件就是负责读数据</p><p>流程：</p><ol><li>创建一个客户端channel<code>SocketChannel</code>，打开一个多留复用器selector，绑定<code>可连接事件</code>，连接到服务端监听的8089端口</li><li>执行<code>selector.select()</code>方法，处理<code>连接就绪</code>和<code>读就绪两个事件</code><ol><li>如果事件为<code>连接就绪</code>，只需要拿到channel，执行<code>finishConnect</code>方法完成连接，并且注册监听事件为<code>可写事件</code></li><li>如果事件为<code>读就绪</code>，执行读操作，把channel中数据使用<code>read()</code>方法读取到readBuffer中，通过<code>new String(readBuffer.array()</code>方法接收String类型数据，并且打印到控制台</li></ol></li><li>清理事件的SelectionKey</li></ol><p><strong>代码：</strong></p><pre><code class="java">public class WxQClient {    public static void main(String[] args) throws IOException {        SocketChannel socketChannel = SocketChannel.open();        socketChannel.configureBlocking(false);        Selector selector = Selector.open();        socketChannel.register(selector, SelectionKey.OP_CONNECT);        socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;,8089));        while (true){            try{                int num = selector.select();                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();                while (iterator.hasNext()) {                    SelectionKey selectionKey = iterator.next();                    if(selectionKey.isConnectable()){                        SocketChannel client = (SocketChannel) selectionKey.channel();                        if(client.isConnectionPending()){                            client.finishConnect();                        }                        client.register(selector,SelectionKey.OP_READ);                    }else if(selectionKey.isReadable()){                        SocketChannel client = (SocketChannel) selectionKey.channel();                        ByteBuffer readBuffer = ByteBuffer.allocate(1024);                        int count = client.read(readBuffer);                        if (count&gt;0){                            String reMsg = new String(readBuffer.array(),0,count);                            System.out.println(reMsg);                        }else if(count==-1) client.close();//关闭客户端                    }                }                selectionKeys.clear();//每次处理完一个SelectionKey的事件，把该SelectionKey删除            }            catch (Exception e){                e.printStackTrace();            }        }    }}</code></pre><p><strong>至此，我们服务端和客户端AB都已经完后，现在我们测试一下</strong></p><ol><li>启动服务端，启动一个WxQClient也就是ClientA，启动两个GzhClient，也就是ClientB</li></ol><p>服务端显示连接成功</p><img src="http://dzou.wangminwei.top/static/images/nio/12.png"><ol start="2"><li>客户端B发送消息</li></ol><p>服务端接收到消息并打印，并转发到客户端A，客户端A打印消息</p><img src="http://dzou.wangminwei.top/static/images/nio/13.png"><img src="http://dzou.wangminwei.top/static/images/nio/14.png">]]></content>
    
    <summary type="html">
    
      io面向流编程，只能作为输入或者输出流的一种，是同步阻塞的，每一个连接过来都要创建一个线程去处理，线程上下文切换开销很大，造成了很大的瓶颈；于是有了线程池实现的伪阻塞IO，一定程度解决了线程创建过多的问题，但是没有从根本上解决阻塞的问题，并且线程过多而线程池过小时也会造成很大的瓶颈；NIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的（没有可干的事情必须要阻塞），剩余的I/O操作都是纯CPU操作，没有必要开启多线程
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="NIO" scheme="https://www.dzou.top/tags/NIO/"/>
    
      <category term="网络通信" scheme="https://www.dzou.top/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
      <category term="异步" scheme="https://www.dzou.top/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>字符集编码—ASCII/ISO-8859-1/GBK/unicode/UTF-8</title>
    <link href="https://www.dzou.top/post/charsets.html"/>
    <id>https://www.dzou.top/post/charsets.html</id>
    <published>2019-10-26T08:32:01.000Z</published>
    <updated>2019-10-27T09:22:15.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符集编码—ASCII-ISO-8859-1-GBK-unicode-UTF-8"><a href="#字符集编码—ASCII-ISO-8859-1-GBK-unicode-UTF-8" class="headerlink" title="字符集编码—ASCII/ISO-8859-1/GBK/unicode/UTF-8"></a>字符集编码—ASCII/ISO-8859-1/GBK/unicode/UTF-8</h2><p><strong>为什么要编码？</strong></p><p>答：要表示的符号太多，没有统一的标准，计算机无法识别没有标准的字符</p><p><strong>定长编码便于计算机处理,GBK不是定长编码，unicode属于定长编码</strong></p><h3 id="ASCII—美国信息交换标准代码"><a href="#ASCII—美国信息交换标准代码" class="headerlink" title="ASCII—美国信息交换标准代码"></a>ASCII—美国信息交换标准代码</h3><p>用一个字节的低 7 位表示，最早出现的字符集，美国标准，2的七次方的字符，共128种</p><blockquote><p>问题：无法包含其他国家的字符</p></blockquote><h3 id="ISO-8859-1"><a href="#ISO-8859-1" class="headerlink" title="ISO-8859-1"></a>ISO-8859-1</h3><p>一个字节(8bit 1byte)，2的八次方，共256种，相比于ASCII多了一倍字符集，包括拉丁字和西欧语</p><blockquote><p>问题：依然无法包含所有其他国家的字符，中文</p></blockquote><h3 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h3><p>两个字节表示一个汉字，中国汉字专属编码格式  例：<code>A5 B6</code></p><h4 id="GB2312-GBK-GB18030"><a href="#GB2312-GBK-GB18030" class="headerlink" title="GB2312/GBK/GB18030"></a>GB2312/GBK/GB18030</h4><ul><li>gb2312只能表示简体字</li><li>gbk编码能够用来同时表示繁体字和简体字，兼容gb2312</li><li>gb18030包含所有的中文文字</li></ul><blockquote><p>问题：无法让全世界编码规范统一，每个国家的字符集都不一样</p></blockquote><h3 id="unicode"><a href="#unicode" class="headerlink" title="unicode"></a>unicode</h3><p>为了解决全世界编码规范不同的问题，出现了unicode编码规范，它实现的编码方式可表示全世界所有的字符集，定长双字节，是一种<code>根本标准</code>，具体使用是使用它的实现</p><p><strong>Unicode 编码字符集旨在收集全球所有的字符，为每个字符分配唯一的字符编号即代码点（Code Point），从 U+0000 到 U+FFFF被划分为17个平面，现在包括1114111个编码点</strong></p><p><strong>Code Point:</strong> 码点，简单理解就是字符的数字表示。</p><blockquote><p>Unicode 当然是一本很厚的字典，记录着世界上所有字符对应的一个数字。具体是怎样的对应关系，又或者说是如何进行划分的，就不是我们考虑的问题了，我们只用知道 Unicode 给所有的字符指定了一个数字用来表示该字符。</p></blockquote><p><code>\u597d</code>-&gt;<code>好</code></p><p>问题：原来一个字节可以表示的字符现在需要两个字节了</p><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p><code>unicode translation format-8</code>，属于unicode的一种实现，使用unicode标准</p><blockquote><p>为了解决unicode原来一个字节可以表示的字符现在需要两个字节的问题，出现了相对应的utf-8,utf-16,utf-32</p></blockquote><p><strong>UTF-8是一种可变长编码，可以使用1-4个字节表示一个字符，完全兼容ASCII</strong></p><ol><li>对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题。</li><li>对于需要使用 N 个字节来表示的字符（N &gt; 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充</li></ol><table><thead><tr><th>Unicode 十六进制码点范围</th><th>UTF-8 二进制</th></tr></thead><tbody><tr><td>0000 0000 - 0000 007F</td><td>0xxxxxxx</td></tr><tr><td>0000 0080 - 0000 07FF</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>0000 0800 - 0000 FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>0001 0000 - 0010 FFFF</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><blockquote><p>由此可以根据编码表区别这个字符是1个字节还是n个字节</p></blockquote><p>参考博客：</p><p><a href="https://www.ibm.com/developerworks/cn/java/unicode-programming-language/index.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.ibm.com/developerworks/cn/java/unicode-programming-language/index.html</a></p>]]></content>
    
    <summary type="html">
    
      为了解决全世界编码规范不同的问题，出现了unicode编码规范，它实现的编码方式可表示全世界所有的字符集，定长双字节，是一种根本标准，具体使用是使用它的实现;UTF-8是一种可变长编码，可以使用1-4个字节表示一个字符，完全兼容ASCII
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="编码" scheme="https://www.dzou.top/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis源码分析之—Mapper创建和Spring的管理</title>
    <link href="https://www.dzou.top/post/mybatis-mapper-create.html"/>
    <id>https://www.dzou.top/post/mybatis-mapper-create.html</id>
    <published>2019-10-04T06:15:05.000Z</published>
    <updated>2019-10-09T16:12:56.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mybatis源码分析—Mapper创建和Spring的管理"><a href="#Mybatis源码分析—Mapper创建和Spring的管理" class="headerlink" title="Mybatis源码分析—Mapper创建和Spring的管理"></a>Mybatis源码分析—Mapper创建和Spring的管理</h2><p><strong>我们分析的时候先自己猜测实现方式再对比mybatis的源码实现方式</strong></p><h3 id="mapper-创建"><a href="#mapper-创建" class="headerlink" title="mapper 创建"></a>mapper 创建</h3><ul><li>因为mybatis可以脱离spring自己使用，所以mapper的bean创建是由mybatis完成的</li><li>创建方式，根据不同的mapper，方法都是对应与注解或者配置文件对应名称的方法，所以我们猜测使用的是spring的动态代理创建方式</li></ul><p>我们自己实现mapper创建工厂代理类：</p><pre><code class="java">public class MySessionFactoryProxy {    public static Object getMapper(Class c){        Class[] classes = new Class[]{c};        //动态代理获取mapper        Object o = Proxy.newProxyInstance(MySessionFactoryProxy.class.getClassLoader(), classes, new InvocationHandler() {            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {                //解析sql                //执行sql                Select annotation = method.getAnnotation(Select.class);                String sql = annotation.value()[0];//一个注解可能有多个sql语句                System.out.println(&quot;sql:&quot;+sql);                return null;            }        });        return o;    }}</code></pre><blockquote><p>那么由谁来调用这个getMapper方法呢，毫无疑问是mybatis，这个时候需要一个工厂bean，用来调用该方法，每次调用，创建一个factoryBean，传入一个mapper类，来创建该mapper(这样就可以解决代码写死的情况)</p></blockquote><ul><li>MyMapperFactoryBean</li></ul><pre><code class="java">public class MyMapperFactoryBean&lt;T&gt; implements FactoryBean&lt;T&gt; {    //实例化的时候传入    public MyMapperFactoryBean(Class&lt;T&gt; mapperInterface) {        this.mapperInterface = mapperInterface;    }    //使用全局变量存储不同的mapper类    private Class&lt;T&gt; mapperInterface;    public T getObject() throws Exception {        System.out.println(&quot;get mapper&quot;);        return (T) MySessionFactoryProxy.getMapper(mapperInterface);    }    public Class&lt;?&gt; getObjectType() {        return this.mapperInterface;    }}</code></pre><p><strong>再看mybatis的实现</strong></p><ul><li>mapper注册类获取mapper</li></ul><pre><code class="java">public class MapperRegistry {    public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {        //主要调用                return mapperProxyFactory.newInstance(sqlSession);    }</code></pre><ul><li>再看mybatis实现的代理工厂类：</li></ul><pre><code class="java">public class MapperProxyFactory&lt;T&gt; {    private final Class&lt;T&gt; mapperInterface;    //主要方法如下    public T newInstance(SqlSession sqlSession) {        MapperProxy&lt;T&gt; mapperProxy = new MapperProxy(sqlSession, this.mapperInterface, this.methodCache);        return this.newInstance(mapperProxy);    }}</code></pre><ul><li>调用getMapper方法的MapperFactoryBean</li></ul><pre><code class="java">public class MapperFactoryBean&lt;T&gt; extends SqlSessionDaoSupport implements FactoryBean&lt;T&gt; {    private Class&lt;T&gt; mapperInterface;    public MapperFactoryBean(Class&lt;T&gt; mapperInterface) {        this.mapperInterface = mapperInterface;    }    public T getObject() throws Exception {        return this.getSqlSession().getMapper(this.mapperInterface);    }    public Class&lt;T&gt; getObjectType() {        return this.mapperInterface;    }    public void setMapperInterface(Class&lt;T&gt; mapperInterface) {        this.mapperInterface = mapperInterface;    }    public Class&lt;T&gt; getMapperInterface() {        return this.mapperInterface;    }}</code></pre><blockquote><p>与我们创建的大体一致</p><p>创建完成mapper后，我们需要把mapper交给ioc管理</p></blockquote><h3 id="创建mapper放到Spring-IOC"><a href="#创建mapper放到Spring-IOC" class="headerlink" title="创建mapper放到Spring IOC"></a>创建mapper放到Spring IOC</h3><blockquote><p>请区别<code>添加注解或者配置，将类交个Spring管理，由Spring为我们创建对象</code>，mapper是由mybatis通过动态代理创建的</p></blockquote><p><strong>自己创建对象交给Spring管理</strong></p><ul><li>想法1：由配置类创建</li></ul><pre><code class="java">@Configuration@ComponentScan(&quot;top.dzou.mybatis&quot;)public class Appconfig {    @Bean    public UserMapper userMapper(){        return (UserMapper) MySessionFactoryProxy.getMapper(UserMapper.class);    }}</code></pre><blockquote><p>每一个都要创建一个@bean注解，不切实际，想想Spring怎么实现的？</p></blockquote><ul><li>我们想起来bean可以通过spring配置文件配置，我们想到使用xml格式配置mapper bean</li></ul><p>类似下面写法：</p><p>使用我们自己的mapper工厂代理类创建mapper</p><pre><code class="xml">    &lt;bean id=&quot;roleMapper&quot; class=&quot;top.dzou.mybatis.mapper_to_spring.my_mybatis.MyMapperFactoryBean&quot;&gt;        &lt;property name=&quot;mapperInterface&quot; value=&quot;top.dzou.mybatis.mapper_to_spring.RoleMapper&quot;/&gt;    &lt;/bean&gt;    &lt;bean id=&quot;userMapper&quot; class=&quot;top.dzou.mybatis.mapper_to_spring.my_mybatis.MyMapperFactoryBean&quot;&gt;        &lt;property name=&quot;mapperInterface&quot; value=&quot;top.dzou.mybatis.mapper_to_spring.UserMapper&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><blockquote><p>这样的代码是不是很熟悉，但是这样任然要配置很多的bean，我们想到了springboot中使用的mapperscan注解</p></blockquote><ul><li>想法3：自己实现一个注解<code>MyMapperScan</code>，包括一个包，在MapperScan注解上导入mapper导入类，把包下面的全部创建并放到spring中</li></ul><p><strong>这里我们需要知道的是Spring创建bean的时候是先加载类并创建<code>BeanDefinition</code>，在通过BeanDefinition创建相应的bean，我们因为mapper</strong></p><p>我们自己实现：</p><ul><li>MyMapperScan</li></ul><p>根据basePackages导入mapper</p><pre><code class="java">//导入ImportBeanDefinitionRegister@Import(MyBeanDefinitionRegister.class)@Retention(RetentionPolicy.RUNTIME)public @interface MyMapperScan {    String[] basePackages() default {};}</code></pre><ul><li>MyBeanDefinitionRegister</li></ul><p>使用Spring注册bean时使用的ImportBeanDefinitionRegistrar注册mapper</p><pre><code class="java">public class MyBeanDefinitionRegister implements ImportBeanDefinitionRegistrar {    //class-&gt;beanDefinition-&gt;map-&gt;bean    public void registerBeanDefinitions(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry beanDefinitionRegistry) {        //获取包信息并把包中类全部注册动态添加到beanDefinition参数中        {            //伪代码            basePackages = 获取包名下的所用mapper类，保存到集合basePackages            baseName = 从mapper类获取beanName        }        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(MyMapperFactoryBean.class);        BeanDefinition beanDefinition = beanDefinitionBuilder.getBeanDefinition();        beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(basePackages);        beanDefinitionRegistry.registerBeanDefinition(beanName,beanDefinition);    }}</code></pre><ul><li>配置类代替主启动类(用于测试)</li></ul><pre><code class="java">@Configuration@ComponentScan(&quot;top.dzou.mybatis.mapper_to_spring&quot;)@MyMapperScan(basePackages = &quot;top.dzou.mapper_to_spring.mapper&quot;)//自定义mapper扫描注解public class Appconfig {}</code></pre><p><strong>我们看一下mybatis怎么实现的</strong></p><ul><li>MapperScan</li></ul><p>它导入了一个<code>MapperScannerRegistrar</code>扫描注册mapper的类</p><pre><code class="java">@Import({MapperScannerRegistrar.class})public @interface MapperScan {</code></pre><ul><li>MapperScannerRegistrar</li></ul><p>我们可以看到它实现了<code>ImportBeanDefinitionRegistrar</code>的bean定义导入注册类，实现了具体的<code>registerBeanDefinitions</code>注册bean定义的方法，把包下的mapper全部添加到一个集合中，然后把这个集合进行注册到ioc中，和我们的想法基本一致</p><pre><code class="java">public class MapperScannerRegistrar implements ImportBeanDefinitionRegistrar, ResourceLoaderAware {    void registerBeanDefinitions(AnnotationAttributes annoAttrs, BeanDefinitionRegistry registry, String beanName) {        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);        List&lt;String&gt; basePackages = new ArrayList();        basePackages.addAll((Collection)Arrays.stream(annoAttrs.getStringArray(&quot;value&quot;)).filter(StringUtils::hasText).collect(Collectors.toList()));        basePackages.addAll((Collection)Arrays.stream(annoAttrs.getStringArray(&quot;basePackages&quot;)).filter(StringUtils::hasText).collect(Collectors.toList()));        basePackages.addAll((Collection)Arrays.stream(annoAttrs.getClassArray(&quot;basePackageClasses&quot;)).map(ClassUtils::getPackageName).collect(Collectors.toList()));        builder.addPropertyValue(&quot;basePackage&quot;, StringUtils.collectionToCommaDelimitedString(basePackages));        registry.registerBeanDefinition(beanName, builder.getBeanDefinition());    }</code></pre><blockquote><p>它使用一个集合保存了所有的mapper类，并把他们放在一个beanDefinition中进行注册</p></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>整个过程主要分为</p><ol><li>mybatis通过MapperScan把整个mybatis工厂bean注册到ioc</li><li>spring负责mybatis创建的mapper注入ioc</li></ol><p>重点：</p><ul><li>MapperScan中的ImportBeanDefinitionRegistrar的registerBeanDefinitions将工厂beanMapperFactoryBean封装成beanDefinition并且把包下的mapper添加成构造函数参数传入并注册到spring中</li><li>注册完成后再启动时spring将根据构造器参数和工厂bean调用mybatis创建mapper，并且把mapper注册到spring管理的bean中</li></ul>]]></content>
    
    <summary type="html">
    
      mybatis通过MapperScan把整个mybatis工厂bean注册到ioc，spring负责mybatis创建的mapper注入ioc，registerBeanDefinitions将工厂beanMapperFactoryBean封装成beanDefinition并且把包下的mapper添加成构造函数参数传入并注册到spring中，注册完成后再启动时spring将根据构造器参数和工厂bean调用mybatis创建mapper，并且把mapper注册到spring管理的bean中
    
    </summary>
    
      <category term="Java Web" scheme="https://www.dzou.top/categories/Java-Web/"/>
    
    
      <category term="数据库" scheme="https://www.dzou.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mybatis" scheme="https://www.dzou.top/tags/mybatis/"/>
    
      <category term="Java Web" scheme="https://www.dzou.top/tags/Java-Web/"/>
    
      <category term="Spring" scheme="https://www.dzou.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>红黑树之—TreeMap源码分析</title>
    <link href="https://www.dzou.top/post/treemap.html"/>
    <id>https://www.dzou.top/post/treemap.html</id>
    <published>2019-10-03T06:15:05.000Z</published>
    <updated>2019-10-09T15:57:15.276Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>HashMap和TreeMap区别</code>：都使用红黑树存储，HashMap不是顺序存储，TreeMap顺序存储</p></blockquote><ul><li>如果需要逆序或者自定义顺序存储：可在创建TreeMap时传入一个自定义<code>Comparator</code></li></ul><pre><code class="java">//带有比较器的构造方法：初始化comparator属性；    public TreeMap(Comparator&lt;? super K&gt; comparator) {        this.comparator = comparator;    }</code></pre><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><ul><li>put</li></ul><p>首先找到新增节点的位置，其次在判断TreeMap是否处于平衡状态，若不平衡，则对节点进行着色、旋转操作；</p><pre><code class="java">//插入key-value:public V put(K key, V value) {    //根节点赋值给t:    java.util.TreeMap.Entry&lt;K,V&gt; t = root;    //如果根节点为null，则创建第一个节点，根节点    if (t == null) {        //对传入的元素进行比较，若TreeMap没定义了Comparator，则验证传入的元素是否实现了Comparable接口；        compare(key, key);        //根节点赋值：        root = new java.util.TreeMap.Entry&lt;&gt;(key, value, null);        //长度为1：        size = 1;        //修改次数+1        modCount++;        //直接返回：此时根节点默认为黑色        return null;    }    //如果根节点不为null:    int cmp;    java.util.TreeMap.Entry&lt;K,V&gt; parent;    Comparator&lt;? super K&gt; cpr = comparator;    //判断TreeMap中自定义比较器comparator是否为null：    if (cpr != null) {        // do while循环，查找新插入节点的父节点：        do {            // 记录上次循环的节点t，首先将根节点赋值给parent:            parent = t;            //利用自定义比较器的比较方法：传入的key跟当前遍历节点比较：            cmp = cpr.compare(key, t.key);            //判断结果小于0，处于父节点的左边             if (cmp &lt; 0)                t = t.left;            else if (cmp &gt; 0)            //判断结果大于0，处于父节点的右边                 t = t.right;            else            //判断结果等于0，为当前节点，覆盖原有节点处的value：                return t.setValue(value);        // 只有当t为null，也就是找到了新节点的parent了        } while (t != null);    } else {        //没有自定义比较器：        if (key == null)            //TreeMap不允许插入key为null，抛异常：            throw new NullPointerException();        //将key转换为Comparable对象：若key没有实现Comparable接口，此处会报错        Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;        //同上：寻找新增节点的父节点：        do {            parent = t;            cmp = k.compareTo(t.key);            if (cmp &lt; 0)                t = t.left;            else if (cmp &gt; 0)                t = t.right;            else                return t.setValue(value);        } while (t != null);    }    //构造新增节点对象：    java.util.TreeMap.Entry&lt;K,V&gt; e = new java.util.TreeMap.Entry&lt;&gt;(key, value, parent);    //根据之前的比较结果，判断新增节点是在父节点的左边还是右边    if (cmp &lt; 0)        // 如果新节点key的值小于父节点key的值，则插在父节点的左侧        parent.left = e;    else        // 如果新节点key的值大于父节点key的值，则插在父节点的右侧        parent.right = e;    //核心方法：插入新的节点后，为了保持红黑树平衡，对红黑树进行调整    fixAfterInsertion(e);    size++;    modCount++;    return null;}</code></pre><ul><li>fixAfterInsertion方法</li></ul><p>插入新的节点后，为了保持红黑树平衡，对红黑树进行调整</p><pre><code class="java">//核心方法：维护TreeMap平衡的处理逻辑；private void fixAfterInsertion(java.util.TreeMap.Entry&lt;K,V&gt; x) {    //首先将新插入节点的颜色设置为红色    x.color = RED;    //TreeMap是否平衡的重要判断，当不在满足循环条件时，代表树已经平衡；    //x不为null，不是根节点，父节点是红色（三者均满足才进行维护）：    while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) {        //节点x的父节点 是 x祖父节点的左孩子：        if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {            //获取x节点的叔叔节点y:            java.util.TreeMap.Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));            //叔叔节点y是红色：            if (colorOf(y) == RED) {                //将x的父节点设置黑色：                setColor(parentOf(x), BLACK);                  //将x的叔叔节点y设置成黑色：                setColor(y, BLACK);                //将x的祖父节点设置成红色：                setColor(parentOf(parentOf(x)), RED);                //将x节点的祖父节点设置成x(进入了下一次判断)：                x = parentOf(parentOf(x));            } else {                 //叔叔节点y不为红色：                //x为其父节点的右孩子：                if (x == rightOf(parentOf(x))) {                    x = parentOf(x);                    rotateLeft(x);                }                setColor(parentOf(x), BLACK);                setColor(parentOf(parentOf(x)), RED);                //右旋：                rotateRight(parentOf(parentOf(x)));            }        } else {            //节点x的父节点 是x祖父节点的右孩子：            //获取x节点的叔叔节点y:            java.util.TreeMap.Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));            //判断叔叔节点y是否为红色：            if (colorOf(y) == RED) {                setColor(parentOf(x), BLACK);12                setColor(y, BLACK);5                setColor(parentOf(parentOf(x)), RED);10                x = parentOf(parentOf(x));            } else {                if (x == leftOf(parentOf(x))) {                    x = parentOf(x);                    rotateRight(x);                }                setColor(parentOf(x), BLACK);                setColor(parentOf(parentOf(x)), RED);                //左旋：                rotateLeft(parentOf(parentOf(x)));            }        }    }    root.color = BLACK;}</code></pre><ul><li>get</li></ul><p>TreeMap底层是红黑树结构，而红黑树本质是一颗二叉查找树，所以在获取节点方面，使用二分查找算法性能最高；</p><pre><code class="java">//通过key获取对应的value：public V get(Object key) {    //获取TreeMap中对应的节点：    java.util.TreeMap.Entry&lt;K,V&gt; p = getEntry(key);    //获取节点的值：    return (p==null ? null : p.value);}//通过key获取Entry对象：final java.util.TreeMap.Entry&lt;K,V&gt; getEntry(Object key) {    //TreeMap自定义比较器不为空，使用自定义比较器对象来获取节点：    if (comparator != null)        //获取节点：        return getEntryUsingComparator(key);    //如果key为null，则抛出异常，TreeMap中不允许存在为null的key：    if (key == null)        throw new NullPointerException();    //将传入的key转换成Comparable类型，传入的key必须实现Comparable接口    Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;    //获取根节点：    java.util.TreeMap.Entry&lt;K,V&gt; p = root;    // 使用二分查找方式，首先判断传入的key与根节点的key哪个大：    while (p != null) {        //传入的key与p节点的key进行大小比较：        int cmp = k.compareTo(p.key);        //传入的key小于p节点的key,则从根的左子树中搜索：        if (cmp &lt; 0)            //左边            p = p.left;        else if (cmp &gt; 0)            //传入的key大于p节点的key,则从根的右边子树中搜索：            //右边            p = p.right;        else            //传入的key等于p节点的key,则直接返回当前节点：            return p;    }    //以上循环没有找对对应的节点，则返回null：    return null;}</code></pre>]]></content>
    
    <summary type="html">
    
      HashMap和TreeMap区别：都使用红黑树存储，HashMap不是顺序存储，TreeMap顺序存储.首先找到新增节点的位置，其次在判断TreeMap是否处于平衡状态，若不平衡，则对节点进行着色、旋转操作；
    
    </summary>
    
      <category term="Java基础" scheme="https://www.dzou.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="数据结构" scheme="https://www.dzou.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="源码" scheme="https://www.dzou.top/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="Java容器" scheme="https://www.dzou.top/tags/Java%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之—平衡二叉树和红黑树</title>
    <link href="https://www.dzou.top/post/rbtree-and-avl.html"/>
    <id>https://www.dzou.top/post/rbtree-and-avl.html</id>
    <published>2019-10-02T06:15:05.000Z</published>
    <updated>2019-10-09T16:08:56.523Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><blockquote><p>大的在右边，小的在左边</p></blockquote><p>缺点：无限插入一边元素，一直小，一直大，造成树的深度高，退化成链表</p><h2 id="平衡二叉树—AVL树"><a href="#平衡二叉树—AVL树" class="headerlink" title="平衡二叉树—AVL树"></a>平衡二叉树—AVL树</h2><blockquote><p>左右子树的高度差不超过1(平衡因子)</p></blockquote><ol><li>可以是空树。</li><li>假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。</li></ol><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p><strong>平衡的调整共有四种情况：分别为LL,LR,RR,RL。</strong></p><p>下面我们通过不断插入数据来说明几种不同的旋转方式:</p><ul><li>左旋</li></ul><img src="http://dzou.wangminwei.top/static/images/datastruct/2.png"><ul><li>右旋</li></ul><img src="http://dzou.wangminwei.top/static/images/datastruct/1.png"><p>例子</p><img src="http://dzou.wangminwei.top/static/images/datastruct/3.png"><img src="http://dzou.wangminwei.top/static/images/datastruct/4.png"><img src="http://dzou.wangminwei.top/static/images/datastruct/5.png"><img src="http://dzou.wangminwei.top/static/images/datastruct/6.png"><h2 id="红黑树—RBT"><a href="#红黑树—RBT" class="headerlink" title="红黑树—RBT"></a>红黑树—RBT</h2><blockquote><p>Java8中红黑树、数据库索引、TreeMap、TreeSet，时间复杂度O(lgN)</p></blockquote><p><code>自平衡二叉查找树</code></p><ul><li>根节点必须黑色</li><li>叶子节点是黑色</li><li>父子不能同为红色</li><li>从任意节点出发，达到叶子节点经过的黑色节点数量一致</li></ul><p>隐藏性质：</p><ul><li>左右子树高度查最多为两倍</li></ul><p><strong>插入时默认插入红色，空的节点默认视为黑色(叶子节点)</strong></p><p><strong>修复规则：</strong></p><p><strong>根据插入情况应用处理策略调整，直到满足性质</strong></p><ul><li>旋转</li><li>变色</li></ul><h4 id="插入情况"><a href="#插入情况" class="headerlink" title="插入情况"></a>插入情况</h4><ol><li><p>被插入节点是根节点</p><p>处理：直接把其涂黑</p></li><li><p>被插入节点父节点是黑色</p><p>处理：直接插入，什么都不需要做</p></li><li><p>被插入节点父节点是红色</p><p>处理：这种情况我们分为下面三种<code>Case</code>，需要进行调整</p></li></ol><ul><li><p><strong>Case1：当前节点父节点和叔叔节点都是红色</strong></p><ol><li>将父节点设置为黑色</li><li>将叔叔节点设置为黑色</li><li>将祖父节点设置为红色</li><li>将祖父节点设置为当前节点，即继续对当前节点进行操作</li></ol></li><li><p><strong>Case2：当前节点父节点是红色，叔叔节点是黑色，且当前节点是父节点的左孩子</strong></p><ol><li>将父节点设置为黑色</li><li>将祖父节点设置为红色</li><li>以祖父节点为支点进行右旋</li></ol></li><li><p><strong>Case3：当前节点父节点是红色，叔叔节点是黑色，且当前节点是父节点的右孩子</strong></p><ol><li><p>当前结点的父结点做为新的当前结点</p></li><li><p>以父节点为支点左旋</p></li><li><p>得到Case2</p></li></ol></li></ul><p>例子：</p><img src="http://dzou.wangminwei.top/static/images/datastruct/7.png"><p><strong>此时4节点处于Case1，执行处理</strong></p><img src="http://dzou.wangminwei.top/static/images/datastruct/8.png"><p><strong>此时当前节点为7，处于Case3，执行处理</strong></p><img src="http://dzou.wangminwei.top/static/images/datastruct/9.png"><p><strong>此时当前节点为2，处于Case2，执行处理</strong></p><img src="http://dzou.wangminwei.top/static/images/datastruct/10.png"><p><strong>得到满足性质的红黑树</strong></p><p>参考博文：</p><p>平衡二叉树：<a href="https://zhuanlan.zhihu.com/p/56066942" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/56066942</a></p><p>红黑树：<a href="https://www.jianshu.com/p/e136ec79235c" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/e136ec79235c</a></p><p><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md</a></p>]]></content>
    
    <summary type="html">
    
      平衡二叉树—AVL树,可以是空树。假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。红黑树—根节点必须黑色，叶子节点是黑色，父子不能同为红色，从任意节点出发，达到叶子节点经过的黑色节点数量一致。
    
    </summary>
    
      <category term="数据结构" scheme="https://www.dzou.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="数据结构" scheme="https://www.dzou.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="二叉树" scheme="https://www.dzou.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB学习笔记—更新中</title>
    <link href="https://www.dzou.top/post/mongodb.html"/>
    <id>https://www.dzou.top/post/mongodb.html</id>
    <published>2019-09-29T06:15:05.000Z</published>
    <updated>2019-10-09T16:09:28.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MongoDB学习笔记—更新中"><a href="#MongoDB学习笔记—更新中" class="headerlink" title="MongoDB学习笔记—更新中"></a>MongoDB学习笔记—更新中</h2><p><strong>json可以为我们描述多种关系：一对一、一对多、多对一和多对多</strong></p><blockquote><p>与js语法类似</p></blockquote><p><strong>创建记录会自动生成一条<code>_id</code>主键，唯一id，代表该Object，也可以声明为自定义的数据</strong></p><blockquote><p>{_id:”123”}</p></blockquote><h3 id="BSON和JSON"><a href="#BSON和JSON" class="headerlink" title="BSON和JSON"></a>BSON和JSON</h3><p><strong>我们都知道Mongodb存储的是BSON格式数据，BSON格式数据以二进制格式存储，可以嵌套文档和数组，增加了数据类型，Date，相比JSON的字符串存储，因为是二进制存储，不需要序列化，可以直接网络传输</strong></p><p>优点：</p><ul><li>轻量</li><li>可遍历(不存储字符串，可直接通过索引获取</li><li>高效(无需序列化)</li><li>增加了额外的数据类型</li></ul><p>缺点：</p><ul><li>空间消耗多(一个整数BSON 4字节，JSON 1字节)</li></ul><p>下面是JSON：</p><pre><code class="json">  &quot;_id&quot;: 1,  &quot;name&quot; : { &quot;first&quot; : &quot;John&quot;, &quot;last&quot; : &quot;Backus&quot; },  &quot;contribs&quot; : [ &quot;Fortran&quot;, &quot;ALGOL&quot;, &quot;Backus-Naur Form&quot;, &quot;FP&quot; ],  &quot;awards&quot; : [    {      &quot;award&quot; : &quot;W.W. McDowell Award&quot;,      &quot;year&quot; : 1967,      &quot;by&quot; : &quot;IEEE Computer Society&quot;    }, {      &quot;award&quot; : &quot;Draper Prize&quot;,      &quot;year&quot; : 1993,      &quot;by&quot; : &quot;National Academy of Engineering&quot;    }  ]}</code></pre><p>下面两个是BSON</p><pre><code class="json">{    title:&quot;MongoDB&quot;,    last_editor:&quot;192.168.1.122&quot;,    last_modified:new Date(&quot;27/06/2011&quot;),    body:&quot;MongoDB introduction&quot;,    categories:[&quot;Database&quot;,&quot;NoSQL&quot;,&quot;BSON&quot;],    revieved:false}{    name:&quot;lemo&quot;,    age:&quot;12&quot;,    address:{        city:&quot;suzhou&quot;,        country:&quot;china&quot;,        code:215000    } ,    scores:[        {&quot;name&quot;:&quot;english&quot;,&quot;grade:3.0},        {&quot;name&quot;:&quot;chinese&quot;,&quot;grade:2.0}    ]}</code></pre><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><ul><li><p><code>mongod</code> 是用来连接到mongodb数据库服务器的，即服务器端。</p></li><li><p><code>mongo</code> 是用来启动MongoDB shell的，是mongodb的命令行客户端。</p></li></ul><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><ul><li>use db_name 切换db</li><li>show dbs 查看所有db</li><li>show collections 查看当前db所有collections</li><li>db 查看当前db</li></ul><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><ul><li><p>db.collection.insert 插入数据</p></li><li><p>db.collection.insertOne 插入一条数据</p></li><li><p>db.collection.insertMany 插入多条数据</p></li></ul><pre><code class="js">db.people.insertOne(   { user_id: &quot;bcd001&quot;, age: 45, status: &quot;A&quot; })等价：INSERT INTO people(user_id,age,status) VALUES (&quot;bcd001&quot;,45,&quot;A&quot;)</code></pre><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><ul><li><p>db.collection.find() 查找</p></li><li><p>db.collection.findOne() 查看一个</p></li><li><p>db.collection.find().limit() 查找限制条数</p></li><li><p>db.collection.find().count() 返回找到数据条数</p></li></ul><pre><code class="js">db.people.find(    { status: &quot;A&quot; })等价：SELECT * FROM people WHERE status = &quot;A&quot;</code></pre><ul><li>投影</li></ul><blockquote><p>查询结果的显示哪些数据 select 投影字段 from collections</p><p>find({},{投影结果数据})</p><p>db.people.find(<br>    { },<br>    { user_id: 1, status: 1, _id: 0 }<br>)<br>等价：SELECT user_id, status FROM people</p></blockquote><h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><ul><li><p>update() 替换 通过<code>$set</code>更换某一属性值</p></li><li><p>db.collection.updateOne() 更新符合条件第一条</p></li><li><p>db.collection.updateMany()  更新符合条件的所有</p></li><li><p>db.collection.replaceOne() 替换符合条件的一条(所有属性)</p></li></ul><blockquote><p><code>db.getCollection(&#39;user&#39;).update({name:&quot;zfb&quot;},{$set:{name:&quot;dx&quot;,age:&quot;12&quot;}})</code></p></blockquote><h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><ul><li><p>unset删除一个属性</p></li><li><p>db.collection.remove({})全删除(一个一个) 应该使用db.collections.drop()，直接删除，效率更高</p></li><li><p>db.collection.remove() 一个或者多个，通过设置第二个参数为true则删除一个</p></li><li><p>db.collection.deleteOne() 删除一条符合条件</p></li><li><p>db.collection. deleteMany() 删除所有符合条件</p></li><li><p>db.dropDatabase() 删除db，谨慎使用</p></li></ul><blockquote><p><code>db.getCollection(&#39;user&#39;).remove({name:&quot;wgy&quot;},true)</code></p></blockquote><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><ul><li>$lt 少于</li></ul><pre><code class="js">db.people.find(   { age: { $lt: 25 } })等价：SELECT * FROM people WHERE age &lt; 25</code></pre><ul><li>$gt 大于</li></ul><pre><code class="js">db.people.find(   { age: { $gt: 25 } })等价：SELECT * FROM people WHERE age &gt; 25</code></pre><ul><li>$lte less than equal 小于等于</li></ul><pre><code class="js">db.people.find(   { age: { $gt: 25, $lte: 50 } })等价：SELECT * FROM people WHERE age &gt; 25 AND   age &lt;= 50</code></pre><ul><li>$regex <code>/关键字/</code> 模糊查询 </li></ul><pre><code class="js">db.people.find( { user_id: /bc/ } )等价：db.people.find( { user_id: { $regex: /bc/ } } )等价：SELECT * FROM people WHERE user_id like &quot;%bc%&quot;db.people.find( { user_id: /bc^/ } )等价：db.people.find( { user_id: { $regex: /bc^/ } } )等价：SELECT * FROM people WHERE user_id like &quot;%bc&quot;</code></pre><ul><li>$exists 存在某个属性</li></ul><pre><code class="js">db.people.count( { user_id: { $exists: true } } )等价：SELECT COUNT(user_id) FROM people</code></pre><ul><li>$and 条件and连接</li></ul><pre><code class="js">db.inventory.find( { $and: [ { price: { $ne: 1.99 } }, { name: &quot;dx&quot;  } ] } )等价：select * from user where price!=1.99 and name=&quot;dx&quot;</code></pre><ul><li><p>$or 条件或连接，与and对应</p></li><li><p>$ne 不等于某个值的记录</p></li></ul><pre><code class="js">db.user.find( { qty: { $ne: 20 } } )等价：select * form user where qtf!=20</code></pre><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li>explain() 解释某条sql</li></ul><pre><code class="js">db.people.find( { status: &quot;A&quot; } ).explain()等价：EXPLAIN SELECT * FROM people WHERE status = &quot;A&quot;</code></pre><ul><li>skip() 跳过指定条数记录</li></ul><pre><code class="js">db.people.find().limit(5).skip(10)等价：SELECT * FROM people LIMIT 5 SKIP 10</code></pre><ul><li>distinct()去重</li></ul><pre><code class="js">db.people.distinct( &quot;status&quot; )等价：SELECT DISTINCT(status) FROM people</code></pre><ul><li><p>count()</p></li><li><p>limit()</p></li><li><p>sort() 下面索引部分</p></li></ul><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p><strong>索引可以用于排序sort()</strong></p><p>1升 -1降</p><p><code>find().sort({user_id:1})</code>根据user_id升序排序</p><h5 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h5><p><code>db.collection.createIndex( { name: -1 } )</code></p><p><img src="https://docs.mongodb.com/manual/_images/index-for-sort.bakedsvg.svg" alt></p><h3 id="SpringBoot—MongoTemplate"><a href="#SpringBoot—MongoTemplate" class="headerlink" title="SpringBoot—MongoTemplate"></a>SpringBoot—MongoTemplate</h3><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;&lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><ul><li>MongoTemplate</li><li>MongoRepository</li></ul><p>参考博文：</p><p><a href="https://blog.lqdev.cn/2018/11/01/springboot/chapter-thirty-one/" rel="external nofollow noopener noreferrer" target="_blank">https://blog.lqdev.cn/2018/11/01/springboot/chapter-thirty-one/</a></p>]]></content>
    
    <summary type="html">
    
      Mongodb轻量，可遍历(不存储字符串，可直接通过索引获取，高效(无需序列化)，增加了额外的数据类型。我们都知道Mongodb存储的是BSON格式数据，BSON格式数据以二进制格式存储，可以嵌套文档和数组，增加了数据类型，Date，相比JSON的字符串存储，因为是二进制存储，不需要序列化，可以直接网络传输
    
    </summary>
    
      <category term="数据库" scheme="https://www.dzou.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MongoDB" scheme="https://www.dzou.top/tags/MongoDB/"/>
    
      <category term="数据库" scheme="https://www.dzou.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="NoSql" scheme="https://www.dzou.top/tags/NoSql/"/>
    
      <category term="缓存" scheme="https://www.dzou.top/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>全文搜索引擎—Solr具体实现和使用</title>
    <link href="https://www.dzou.top/post/solr.html"/>
    <id>https://www.dzou.top/post/solr.html</id>
    <published>2019-09-28T06:15:05.000Z</published>
    <updated>2019-10-20T09:02:01.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h2><h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p><strong>根据文档创建索引，再对索引进行查询获取文档。</strong></p><blockquote><p>相比与顺序查询：不需要那么多的查询(一个文档一个文档找索引，找到就匹配，需要全部查询，效率很低)，而且可以在索引上定位，出现在哪个文档哪个地方，支持高亮</p></blockquote><img src="http://dzou.wangminwei.top/static/images/8.png"><h2 id="Lucene"><a href="#Lucene" class="headerlink" title="Lucene"></a>Lucene</h2><p><strong>Lucene是一个基于Java的全文检索库，可以看成一个持久层框架，与Lucene索引交互</strong></p><img src="http://dzou.wangminwei.top/static/images/5.png"><h3 id="倒排索引存储信息"><a href="#倒排索引存储信息" class="headerlink" title="倒排索引存储信息"></a>倒排索引存储信息</h3><p>左边保存的是一系列字符串，称为<strong>词典</strong>。</p><p>每个字符串都指向包含此字符串的文档(Document)链表(每个节点还包含文档中出现该索引的频率)，此文档链表称为<strong>倒排表</strong>(Posting List)。</p><img src="http://dzou.wangminwei.top/static/images/6.png"><blockquote><p>如果我们需要查询包含两个索引的文档，只需要将两个文档共有的文档标号连接成链表</p></blockquote><h3 id="索引创建"><a href="#索引创建" class="headerlink" title="索引创建"></a>索引创建</h3><ul><li><strong>对文档进行分词，使用Tokenizer ，得到<code>词元</code></strong></li></ul><blockquote><p>分词器一般使用训练的模型，<code>Word</code>、<code>IK</code>等</p></blockquote><ol><li>去除标点</li><li>去除停用词(我、是)</li></ol><ul><li><strong>还需要把词元传递给语言处理器组件处理</strong></li></ul><p>英文：复数-&gt;单数，大写-&gt;小写</p><ul><li><strong>若索引库存在相同索引，需要合并成一个链表</strong></li></ul><h3 id="索引查询"><a href="#索引查询" class="headerlink" title="索引查询"></a>索引查询</h3><ul><li><strong>输入查询关键字词</strong></li></ul><pre><code>keyword:Java</code></pre><ul><li><strong>进行语法分析得到一棵语法分析树</strong></li></ul>{% qnimg 7.png %}<ul><li><p><strong>搜索索引库，得到符合的文档以及索引的信息</strong></p></li><li><p><strong>得到文档后，根据频率，相关性排序，分数越高的排在越前面</strong></p></li></ul><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p><strong>1. 索引过程：</strong></p><p><strong>1)</strong> <strong>有一系列被索引文件</strong></p><p><strong>2)</strong> <strong>被索引文件经过语法分析和语言处理形成一系列词(Term)**</strong>。**</p><p><strong>3)</strong> <strong>经过索引创建形成词典和反向索引表。</strong></p><p><strong>4)</strong> <strong>通过索引存储将索引写入硬盘。</strong></p><p><strong>2. 搜索过程：</strong></p><p><strong>a)</strong> <strong>用户输入查询语句。</strong></p><p><strong>b)</strong> <strong>对查询语句经过语法分析和语言分析得到一系列词(Term)**</strong>。**</p><p><strong>c)</strong> <strong>通过语法分析得到一个查询树。</strong></p><p><strong>d)</strong> <strong>通过索引存储将索引读入到内存。</strong></p><p><strong>e)</strong> <strong>利用查询树搜索索引，从而得到每个词(Term)**</strong>的文档链表，对文档链表进行交，差，并得到结果文档。**</p><p><strong>f)</strong> <strong>将搜索到的结果文档对查询的相关性进行排序。</strong></p><p><strong>g)</strong> <strong>返回查询结果给用户。</strong></p><h3 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a>Solr</h3><p><strong>Solr是Lucene的封装，提供分布式索引，负载均衡查询，配置式使用，基本只支持Java</strong></p><ul><li>安装：官网</li><li>API：SolrJ、SpringBoot中的SolrClient</li><li>core：相当于一张数据库的表</li><li>创建core：<code>solr create -c “name”</code></li><li>web客户端：<code>http://localhost:8983/solr</code></li><li>core目录：solr-8.2.0/server/solr下</li></ul><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ul><li>managed-schema</li></ul><p>在其中配置core的field字段、分词器等</p><blockquote><p>name：数据库字段，type：类型，indexed：是否索引，stored：是否缓存，required：是否必须，multiValued：是否多值</p></blockquote><pre><code class="xml">    &lt;!-- ik分词器 --&gt;    &lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot;&gt;      &lt;analyzer type=&quot;index&quot;&gt;          &lt;tokenizer class=&quot;org.wltea.analyzer.lucene.IKTokenizerFactory&quot; useSmart=&quot;false&quot; conf=&quot;ik.conf&quot;/&gt;          &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt;      &lt;/analyzer&gt;      &lt;analyzer type=&quot;query&quot;&gt;          &lt;tokenizer class=&quot;org.wltea.analyzer.lucene.IKTokenizerFactory&quot; useSmart=&quot;true&quot; conf=&quot;ik.conf&quot;/&gt;          &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt;      &lt;/analyzer&gt;    &lt;/fieldType&gt;    &lt;!-- 数据库字段 --&gt;    &lt;field name=&quot;id&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot; multiValued=&quot;false&quot; /&gt;    &lt;field name=&quot;shoes_name&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;false&quot;/&gt;    &lt;field name=&quot;price&quot; type=&quot;string&quot; indexed=&quot;false&quot; stored=&quot;true&quot; multiValued=&quot;false&quot;/&gt;    &lt;field name=&quot;details&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;false&quot;/&gt;    &lt;field name=&quot;url&quot; type=&quot;string&quot; indexed=&quot;false&quot; stored=&quot;true&quot; multiValued=&quot;false&quot;/&gt;    &lt;field name=&quot;pic_url&quot; type=&quot;string&quot; indexed=&quot;false&quot; stored=&quot;true&quot; multiValued=&quot;false&quot;/&gt;</code></pre><ul><li>solrconfig.xml</li></ul><p>当你需要使用web客户端dataimport时，需要添加：</p><pre><code class="xml">&lt;requestHandler name=&quot;/dataimport&quot; class=&quot;org.apache.solr.handler.dataimport.DataImportHandler&quot;&gt;      &lt;lst name=&quot;defaults&quot;&gt;        &lt;str name=&quot;config&quot;&gt;data-config.xml&lt;/str&gt;      &lt;/lst&gt;    &lt;/requestHandler&gt;</code></pre><ul><li>在统计目录下创建一个data-config.xml，建立数据库字段和core field映射</li></ul><pre><code class="xml"> &lt;dataConfig&gt;    &lt;dataSource type=&quot;JdbcDataSource&quot; driver=&quot;com.mysql.cj.jdbc.Driver&quot; url=&quot;jdbc:mysql://127.0.0.1:3306/priceCompare_goods&quot; user=&quot;dzou&quot; password=&quot;1234&quot;/&gt;    &lt;document&gt;       &lt;entity name=&quot;adidas_goods&quot; transformer=&quot;DateFormatTransformer&quot; query=&quot;SELECT id,shoes_name,details,pic_url,price,url,store_name,comment,shoes_kind FROM adidas_goods&quot;&gt;          &lt;field column=&quot;id&quot; name=&quot;id&quot;/&gt;          &lt;field column=&quot;shoes_name&quot; name=&quot;shoes_name&quot;/&gt;          &lt;field column=&quot;price&quot; name=&quot;price&quot;/&gt;          &lt;field column=&quot;details&quot; name=&quot;details&quot;/&gt;          &lt;field column=&quot;url&quot; name=&quot;url&quot;/&gt;          &lt;field column=&quot;pic_url&quot; name=&quot;pic_url&quot;/&gt;          &lt;field column=&quot;shoes_kind&quot; name=&quot;shoes_kind&quot;/&gt;          &lt;field column=&quot;store_name&quot; name=&quot;store_name&quot;/&gt;          &lt;field column=&quot;score&quot; name=&quot;score&quot;&gt;        &lt;/entity&gt;    &lt;/document&gt;&lt;/dataConfig&gt;</code></pre><h4 id="SolrClient-API调用"><a href="#SolrClient-API调用" class="headerlink" title="SolrClient API调用"></a>SolrClient API调用</h4><ul><li>依赖</li></ul><pre><code class="xml">&lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-data-solr&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><ul><li>添加记录到core</li></ul><pre><code class="java">@RequestMapping(&quot;/add&quot;)    public String add() throws IOException, SolrServerException {        SolrInputDocument doc = new SolrInputDocument();        doc.setField();        doc.setField();        doc.setField();        solrClient.add(&quot;&quot;,doc);        solrClient.commit(&quot;&quot;);        return &quot;&quot;;    }</code></pre><ul><li>删除core记录</li></ul><pre><code class="java">@RequestMapping(&quot;/delete&quot;)    public String delete(String id) throws IOException, SolrServerException {        solrClient.deleteById(id);        solrClient.commit(&quot;&quot;);        return &quot;&quot;;    }/**     * 删除所有的索引     * @return     */    @RequestMapping(&quot;deleteAll&quot;)    public String deleteAll(){        try {            solrClient.deleteByQuery(&quot;&quot;,&quot;*:*&quot;);            solrClient.commit(&quot;&quot;);            return &quot;success&quot;;        } catch (Exception e) {            e.printStackTrace();        }        return &quot;error&quot;;    }</code></pre><ul><li>更新记录</li></ul><pre><code class="java">Map&lt;String, String&gt; map = new HashMap&lt;&gt;();map.put(&quot;set&quot;, o.getScore());SolrInputDocument doc = new SolrInputDocument();doc.addField(&quot;id&quot;, o.getId());doc.addField(&quot;score&quot;, map);solrClient.add(&quot;am_goods&quot;, doc);solrClient.commit(&quot;am_goods&quot;);</code></pre><ul><li>查询记录</li></ul><pre><code class="java">    /**     * 根据id查询索引     * @return     * @throws Exception     */    @RequestMapping(&quot;getById&quot;)    public String getById() throws Exception {        SolrDocument document = solrClient.getById(&quot;collection1&quot;, &quot;536563&quot;);        System.out.println(document);        return document.toString();    }    /**     * 综合查询: 在综合查询中, 有按条件查询, 条件过滤, 排序, 分页, 高亮显示, 获取部分域信息     * @return     */    @RequestMapping(&quot;search/{keyword}&quot;)    public String search(@PathVariable(&quot;keyword&quot;)String keyword){        try {            SolrQuery params = new SolrQuery();            //查询条件, 这里的 q 对应 下面图片标红的地方            params.set(&quot;q&quot;, &quot;shoes_name:&quot;+keyword);            //过滤条件            //params.set(&quot;fq&quot;, &quot;product_price:[100 TO 100000]&quot;);            //排序            params.addSort(&quot;price&quot;, SolrQuery.ORDER.asc);            //分页            params.setStart(0);            params.setRows(20);            //默认域            params.set(&quot;df&quot;, &quot;shoes_name&quot;);            //只查询指定域            //params.set(&quot;fl&quot;, &quot;id,shoes_name,shoes_kind,shop_name&quot;);            //高亮            //打开开关            params.setHighlight(true);            //指定高亮域            params.addHighlightField(&quot;shoes_name&quot;);            //设置前缀            params.setHighlightSimplePre(&quot;&lt;span style=&#39;color:red&#39;&gt;&quot;);            //设置后缀            params.setHighlightSimplePost(&quot;&lt;/span&gt;&quot;);            QueryResponse queryResponse = solrClient.query(params);            /*SolrDocumentList results = queryResponse.getResults();            results.forEach(System.out::println);*/            List&lt;HupuGoods&gt; s = queryResponse.getBeans(HupuGoods.class);            return s.toString();        } catch (Exception e) {            e.printStackTrace();        }        return null;    }</code></pre><h3 id="ES和Solr区别"><a href="#ES和Solr区别" class="headerlink" title="ES和Solr区别"></a>ES和Solr区别</h3><ul><li><p>Solr是配置式，ES是基于RestFul的</p></li><li><p>ES除了搜索还可以处理分析查询</p></li><li><p>Solr更面向文本搜索，对于已有数据的查询Solr更快</p></li><li><p>ES更轻量，发展很快，使用量已经超越Solr</p></li></ul>]]></content>
    
    <summary type="html">
    
      全文检索使用到了倒排索引，相比与顺序查询：不需要那么多的查询(一个文档一个文档找索引，找到就匹配，需要全部查询，效率很低)，而且可以在索引上定位，出现在哪个文档哪个地方，支持高亮。Solr是java全文检索api工具接口lucene的封装，用于全文检索。
    
    </summary>
    
      <category term="数据库" scheme="https://www.dzou.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="全文搜索引擎" scheme="https://www.dzou.top/tags/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
      <category term="Solr" scheme="https://www.dzou.top/tags/Solr/"/>
    
      <category term="索引" scheme="https://www.dzou.top/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="分词" scheme="https://www.dzou.top/tags/%E5%88%86%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot自定义参数解析器</title>
    <link href="https://www.dzou.top/post/diy-params-resolver.html"/>
    <id>https://www.dzou.top/post/diy-params-resolver.html</id>
    <published>2019-09-12T07:55:55.000Z</published>
    <updated>2019-09-12T12:05:16.109Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringBoot自定义参数解析器"><a href="#SpringBoot自定义参数解析器" class="headerlink" title="SpringBoot自定义参数解析器"></a>SpringBoot自定义参数解析器</h2><p><strong>我们都知道SpringMvc的Controller的方法上可以接收各种各样的参数，比如<code>HttpServletRequest</code>或<code>HttpServletResponse</code>，各种注解<code>@RequestParam</code>、<code>@RequestHeader</code>、<code>@RequestBody</code>、<code>@PathVariable</code>、<code>@ModelAttribute</code>，这些参数是从哪里获取的？</strong></p><blockquote><p>这些参数都是由不同的参数解析器为我们解析出来的，可以解析类也可以解析带注解的类</p></blockquote><ul><li>我们可以利用解析器解析自定义的参数(类、注解)，在我们需要的传入的controller方法上传入它(不需要每次都要在方法内部通过<code>request</code>、<code>response</code>等参数做一系列操作来获取该类对象)</li></ul><h3 id="添加解析器"><a href="#添加解析器" class="headerlink" title="添加解析器"></a>添加解析器</h3><ul><li>我们想要自定义解析参数的时候我们就需要通过更改SpringBoot的配置来添加自己实现的解析类</li></ul><p>自定义配置类实现<code>WebMvcConfigurer</code>接口，重写其中的<code>addArgumentResolvers</code>方法来添加自己的解析类(通过自动注入的方法注入)</p><pre><code class="java">@Configurationpublic class WebConfig implements WebMvcConfigurer {    @Autowired    private SecKillUserArgumentResolvers secKillUserArgumentResolvers;    @Override    public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) {        argumentResolvers.add(secKillUserArgumentResolvers);    }}</code></pre><h3 id="实现自定义解析器"><a href="#实现自定义解析器" class="headerlink" title="实现自定义解析器"></a>实现自定义解析器</h3><ul><li>我们自定义解析器需要实现<code>HandlerMethodArgumentResolver处理器方法解析器</code>接口，并实现其中的<code>supportsParameter</code>和<code>resolveArgument</code>方法</li></ul><p><code>HandlerMethodArgumentResolver</code>的接口定义如下：</p><p>（1）<code>supportsParameter</code> 用于判断是否支持对某种参数的解析(支持则返回true)</p><p>（2）<code>resolveArgument</code> 将请求中的参数值解析为某种对象(具体的操作获取解析对象)</p><p>下面这个自定义解析器用于获取User对象(通过token获取保存在redis中的user)，无需每次使用resquest和response在controller方法内部获取，可以直接获取到作为参数传入</p><pre><code class="java">/** * 自定义参数解析器 * 解析每次都要获取的user自动传入，无需每次获取 */@Componentpublic class SecKillUserArgumentResolvers implements HandlerMethodArgumentResolver {    @Autowired    private UserService userService;    @Override    public boolean supportsParameter(MethodParameter methodParameter) {        Class&lt;?&gt; c = methodParameter.getParameterType();        return c == User.class;    }    @Override    public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {        HttpServletRequest request = nativeWebRequest.getNativeRequest(HttpServletRequest.class);        HttpServletResponse response = nativeWebRequest.getNativeResponse(HttpServletResponse.class);        assert request != null;        String paramToken = request.getParameter(UserServiceImpl.COOKIE_NAME_TOKEN);//COOKIE_NAME_TOKEN=&quot;token&quot;        String cookieToken = getCookieValue(request);        if(StringUtils.isEmpty(cookieToken)&amp;&amp;StringUtils.isEmpty(paramToken)){//通过两种方式获取，如果都获取失败则返回null            return null;        }else {            String token = StringUtils.isEmpty(paramToken)?cookieToken:paramToken;            return UserService.getUserByToken(response,token);        }    }//遍历cookie获取名称相同的那个cookie的值    private String getCookieValue(HttpServletRequest request) {        Cookie[] cookies = request.getCookies();        for(Cookie cookie:cookies){            if(cookie.getName().equals(SecKillUserServiceImpl.COOKIE_NAME_TOKEN)){                return cookie.getValue();            }        }        return null;    }}</code></pre><blockquote><p>到此，一个自定义参数解析器就实现好了，我们可以通过传入参数的形式直接通过解析器帮我们获取到</p></blockquote><h3 id="解析对象的使用"><a href="#解析对象的使用" class="headerlink" title="解析对象的使用"></a>解析对象的使用</h3><ul><li>我们在controller方法中传入该参数，可以直接为我们获取到User对象</li></ul><pre><code class="java">@RequestMapping(&quot;/to_list&quot;)    public String toList(Model model,User user){    }</code></pre><h3 id="Springboot中其他参数解析器"><a href="#Springboot中其他参数解析器" class="headerlink" title="Springboot中其他参数解析器"></a>Springboot中其他参数解析器</h3><h4 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h4><ul><li>我们知道我们可以传入<code>Model</code>对象参数就可以直接使用它，我们看看它的参数解析器</li></ul><p><code>ModelAttributeMethodProcessor</code>类</p><pre><code class="java">public boolean supportsParameter(MethodParameter parameter) {        return parameter.hasParameterAnnotation(ModelAttribute.class) || this.annotationNotRequired &amp;&amp; !BeanUtils.isSimpleProperty(parameter.getParameterType());    }    @Nullable    public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {        Assert.state(mavContainer != null, &quot;ModelAttributeMethodProcessor requires ModelAndViewContainer&quot;);        Assert.state(binderFactory != null, &quot;ModelAttributeMethodProcessor requires WebDataBinderFactory&quot;);        String name = ModelFactory.getNameForParameter(parameter);        ModelAttribute ann = (ModelAttribute)parameter.getParameterAnnotation(ModelAttribute.class);        if (ann != null) {            mavContainer.setBinding(name, ann.binding());        }        Object attribute = null;        BindingResult bindingResult = null;        if (mavContainer.containsAttribute(name)) {            attribute = mavContainer.getModel().get(name);        } else {            try {                attribute = this.createAttribute(name, parameter, binderFactory, webRequest);            } catch (BindException var10) {                if (this.isBindExceptionRequired(parameter)) {                    throw var10;                }                if (parameter.getParameterType() == Optional.class) {                    attribute = Optional.empty();                }                bindingResult = var10.getBindingResult();            }        }        if (bindingResult == null) {            WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);            if (binder.getTarget() != null) {                if (!mavContainer.isBindingDisabled(name)) {                    this.bindRequestParameters(binder, webRequest);                }                this.validateIfApplicable(binder, parameter);                if (binder.getBindingResult().hasErrors() &amp;&amp; this.isBindExceptionRequired(binder, parameter)) {                    throw new BindException(binder.getBindingResult());                }            }            if (!parameter.getParameterType().isInstance(attribute)) {                attribute = binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);            }            bindingResult = binder.getBindingResult();        }        Map&lt;String, Object&gt; bindingResultModel = bindingResult.getModel();        mavContainer.removeAttributes(bindingResultModel);        mavContainer.addAllAttributes(bindingResultModel);        return attribute;    }</code></pre><h4 id="RequestParam"><a href="#RequestParam" class="headerlink" title="RequestParam"></a>RequestParam</h4><p><code>RequestParamMethodArgumentResolver</code>类，基于注解的方式</p><p>如果传入参数parameter上有该注解，则可以解析</p><pre><code class="java">public boolean supportsParameter(MethodParameter parameter) {        if (parameter.hasParameterAnnotation(RequestParam.class)) {            if (!Map.class.isAssignableFrom(parameter.nestedIfOptional().getNestedParameterType())) {                return true;            } else {                RequestParam requestParam = (RequestParam)parameter.getParameterAnnotation(RequestParam.class);                return requestParam != null &amp;&amp; StringUtils.hasText(requestParam.name());            }        } else if (parameter.hasParameterAnnotation(RequestPart.class)) {            return false;        } else {            parameter = parameter.nestedIfOptional();            if (MultipartResolutionDelegate.isMultipartArgument(parameter)) {                return true;            } else {                return this.useDefaultResolution ? BeanUtils.isSimpleProperty(parameter.getNestedParameterType()) : false;            }        }    }</code></pre><h4 id="PathVariable"><a href="#PathVariable" class="headerlink" title="PathVariable"></a>PathVariable</h4><p><code>PathVariableMethodArgumentResolver</code>类，也是基于注解，与RequestParam类似</p><pre><code class="java">public boolean supportsParameter(MethodParameter parameter) {        if (!parameter.hasParameterAnnotation(PathVariable.class)) {            return false;        } else if (!Map.class.isAssignableFrom(parameter.nestedIfOptional().getNestedParameterType())) {            return true;        } else {            PathVariable pathVariable = (PathVariable)parameter.getParameterAnnotation(PathVariable.class);            return pathVariable != null &amp;&amp; StringUtils.hasText(pathVariable.value());        }    }</code></pre><h3 id="基于注解自定义参数解析器"><a href="#基于注解自定义参数解析器" class="headerlink" title="基于注解自定义参数解析器"></a>基于注解自定义参数解析器</h3><ul><li>编写注解类，需要解析的类需要有此注解</li></ul><pre><code class="java">@Target(value = ElementType.PARAMETER)@Retention(RetentionPolicy.RUNTIME)public @interface ParamModel {}</code></pre><ul><li>实现解析器</li></ul><pre><code class="java">public class MyArgumentResolver implements HandlerMethodArgumentResolver {    @Override    public boolean supportsParameter(MethodParameter methodParameter) {        return methodParameter.hasParameterAnnotation(ParamModel.class);//带有注解就解析    }    @Override    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer container,            NativeWebRequest webRequest, WebDataBinderFactory binderFactory) {        //实现解析对象代码    }</code></pre><ul><li>配置到<code>WebMvcConfigurer</code></li></ul><pre><code class="java">@Configurationpublic class WebConfig implements WebMvcConfigurer {    @Autowired    private MyArgumentResolvers myArgumentResolvers;    @Override    public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) {        argumentResolvers.add(myArgumentResolvers);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      SpringBoot自定义参数解析器,我们可以利用解析器解析自定义的参数(类、注解)，在我们需要的传入的controller方法上传入它(不需要每次都要在方法内部通过request、response等参数做一系列操作来获取该类对象)addArgumentResolvers
    
    </summary>
    
      <category term="Java Web" scheme="https://www.dzou.top/categories/Java-Web/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="SpringBoot" scheme="https://www.dzou.top/tags/SpringBoot/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="项目" scheme="https://www.dzou.top/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>秒杀Seckill项目总结</title>
    <link href="https://www.dzou.top/post/seckill-sum.html"/>
    <id>https://www.dzou.top/post/seckill-sum.html</id>
    <published>2019-09-12T01:55:55.000Z</published>
    <updated>2019-09-16T08:09:59.920Z</updated>
    
    <content type="html"><![CDATA[<h2 id="秒杀项目总结"><a href="#秒杀项目总结" class="headerlink" title="秒杀项目总结"></a>秒杀项目总结</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>利用了两周时间完成了一个秒杀项目，这是第一次正式做项目，收获很多，下面记录一下自己的收获</strong></p><h3 id="1-关于Service层调用dao层"><a href="#1-关于Service层调用dao层" class="headerlink" title="1.关于Service层调用dao层"></a>1.关于Service层调用dao层</h3><ul><li>Service内只调自己的mapper，其他的Service  而不调其他的mapper</li></ul><blockquote><p>Service中要更新缓存，如果你调用了其他的mapper更改了，那么缓存可能不更改，缓存不一致</p></blockquote><h3 id="2-关于Dto、Vo和实体的使用"><a href="#2-关于Dto、Vo和实体的使用" class="headerlink" title="2.关于Dto、Vo和实体的使用"></a>2.关于Dto、Vo和实体的使用</h3><ul><li>Dto：数据传输对象，用于和前端交互数据的对象，可以简单理解为需要通过controller层传递给前端数据(可能是实体、vo的封装，集合或者只包括它们其中一些成员变量)</li><li>Vo：包装类对象，用于对实体类和一些分离参数的封装，使得操作只需要操作该包装对象</li><li>entity：实体对象，直接作用于dao层的对象，是数据库字段的封装</li></ul><p>例如：</p><p><strong>DTO</strong>：我需要传递给前端我在Service或者controller层操作的一些数据(非实体内部成员)，那么我们需要把它封装为Dto对象</p><p><strong>VO</strong>：像登录参数的封装就属于Vo对象，还有就是实体之间构成的一些参数封装成的对象(多个表中某些字段构成的)</p><h3 id="3-关于枚举类定义以及结果封装"><a href="#3-关于枚举类定义以及结果封装" class="headerlink" title="3.关于枚举类定义以及结果封装"></a>3.关于枚举类定义以及结果封装</h3><p><strong>我们通常需要一个枚举类定义程序的状态，它包含两个可以获取到的元素(状态码和状态信息)，为了可以获取到这两个信息，我们会声明一个状态码的接口，声明两个get方法，再让枚举类实现该接口来获取状态信息</strong></p><pre><code class="java">public interface IError {    int getCode();    String getMessage();}</code></pre><pre><code class="java">@Getter@AllArgsConstructorpublic enum ErrorCodeEnum implements IError {    /**     * 100X  用户相关错误     * //     */    PASSWORD_EMPTY(1001, &quot;密码能不为空&quot;),    MOBILE_PATTERN_WRONG(1002, &quot;手机号格式错误&quot;),    MOBILE_NOT_EXIST(1003, &quot;手机号不存在&quot;),    LOGIN_FAIL(1004, &quot;登陆失败,密码错误&quot;),    USER_NOT_EXSIT(1005, &quot;用户不存在&quot;),    NOT_LOGIN(1006,&quot;尚未登录&quot;),    /**     * 000X 公共错误     */    SUCCESS(2000, &quot;OK&quot;),    NET_ERROR(2001, &quot;网络错误&quot;),    PARAM_ERROR(2002, &quot;参数错误&quot;),    /**     * 400X 业务错误     */    SECKILL_FAIL(4001, &quot;秒杀失败，库存不足&quot;);    private int code;    private String message;}</code></pre><h4 id="结果封装"><a href="#结果封装" class="headerlink" title="结果封装"></a>结果封装</h4><p><strong>我们把数据和状态传递给前端的时候，需要把状态信息和状态码传递过去，我们前端才可以根据状态码判断需要执行的操作</strong></p><blockquote><p>该结果类需要在网路之间传输，需要进行序列化操作，最简单的序列化操作就是实现Serializable接口，定义一个全局的版本号。在该类中，包括状态码、状态信息msg、数据对象T和是否成功(成功或者错误信息)的标志</p></blockquote><pre><code class="java">@Datapublic class Result&lt;T&gt; implements Serializable {    private static final long serialVersionUID = 3956528717501837568L;    private boolean success;    private int code;    private String msg;    private T data;    public Result() {    }    public Result(boolean success, int code, String msg, T data) {        this.success = success;        this.code = code;        this.msg = msg;        this.data = data;    }    public static &lt;T&gt; Result&lt;T&gt; error(IError error) {        return error(error.getCode(), error.getMessage());    }    public static &lt;T&gt; Result&lt;T&gt; success(T data) {        return new Result&lt;T&gt;(true, ErrorCodeEnum.SUCCESS.getCode(), ErrorCodeEnum.SUCCESS.getMessage(), data);    }    public static Result&lt;String&gt; ok() {        return success(&quot;ok&quot;);    }    public static &lt;T&gt; Result&lt;T&gt; fillArgs(IError iError, Object... args) {        return error(iError.getCode(), String.format(iError.getMessage(), args));    }}</code></pre><blockquote><p>我们可以注意到最后一个<code>fillArgs</code>方法是支持枚举类错误信息中带<code>%s</code>的，可以使用<code>String.format</code>替换，这就是支持带参数传递的错误信息</p></blockquote><h3 id="4-关于注解的使用"><a href="#4-关于注解的使用" class="headerlink" title="4.关于注解的使用"></a>4.关于注解的使用</h3><h4 id="注解效验器使用"><a href="#注解效验器使用" class="headerlink" title="注解效验器使用"></a>注解效验器使用</h4><p>我在另外一篇博文中说到了参数效验器的使用，也说到自定义效验器，就是基于注解的形式，<code>用于判断前端传来的数据在服务端再进行一次效验</code>，例如：传来的手机号是否符号格式要求</p><ul><li>声明一个注解<code>@IsMobile</code></li><li>编写验证器代码(具体任何效验)，实现<code>ConstraintValidator</code>接口，重写<code>isValid</code>方法</li><li>注解标注在具体成员变量上，再在封装类上标注<code>@Valid</code>注解</li></ul><h4 id="注解实现拦截器"><a href="#注解实现拦截器" class="headerlink" title="注解实现拦截器"></a>注解实现拦截器</h4><ul><li>声明一个注解：拦截器拦截后你想实现的功能和具体的参数</li></ul><pre><code class="java">@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface AccessLimit {    int seconds();//时间范围    int maxCount();//最大尝试次数    boolean needLogin() default true;//声明是否需要登录}</code></pre><ul><li>编写拦截器，实现<code>HandlerInterceptor</code>接口，实现具体的拦截方法，重写<code>preHandler</code>方法</li><li>在配置类中注入拦截器然后再重写方法把拦截器注册到拦截器工厂，并声明要拦截的URL</li></ul><pre><code class="java">@Configurationpublic class WebConfig implements WebMvcConfigurer {    @Autowired    private LimitAccessCountInterceptor limitAccessCountInterceptor;    @Override    public void addInterceptors(InterceptorRegistry registry) {        registry.addInterceptor(limitAccessCountInterceptor).addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/login/**&quot;);    }}</code></pre><h4 id="注解mapper"><a href="#注解mapper" class="headerlink" title="注解mapper"></a>注解mapper</h4><pre><code class="java">public interface UserMapper {    @Select(&quot;select * from user where id = #{id};&quot;)    public User getById(int id);    @Insert(&quot;insert into user (name) values(#{name});&quot;)    public Boolean insert(User user);}</code></pre><h3 id="5-异常的声明以及全局异常处理器"><a href="#5-异常的声明以及全局异常处理器" class="headerlink" title="5.异常的声明以及全局异常处理器"></a>5.异常的声明以及全局异常处理器</h3><p><strong>我们一般需要为我们的应用程序创建自己的异常，再抛出异常时打印到控制台和日志，我们可以声明一个全局异常类，并通过自定义异常处理器去操作异常</strong></p><ul><li>我们通过传入状态来创建一个异常，该异常属于运行时异常，需要继承<code>RuntimeException</code></li></ul><pre><code class="java">public class GlobalException extends RuntimeException {    private IError i;    public GlobalException(IError i) {        this.i = i;    }    public IError getI() {        return i;    }}</code></pre><ul><li>编写全局异常处理器—用于Service层抛出异常</li></ul><blockquote><p>在方法上标注上@ExceptionHandler注解来拦截指定类型异常，这里我们拦截所有的异常</p><ul><li>如果是绑定异常则获取异常信息并通过参数传入结果返回</li><li>如果是我们自定义的全局异常则作为错误信息返回</li><li>如果是其他异常则返回网络错误的状态</li></ul></blockquote><pre><code class="java">@ControllerAdvice@ResponseBody@Slf4jpublic class GlobalExceptionHandler {    @ExceptionHandler(value = Exception.class)//拦截所有异常    public Result&lt;String&gt; exceptionHandler(HttpServletRequest request, Exception e) {        e.printStackTrace();        if (e instanceof BindException) {            BindException ex = (BindException) e;            List&lt;ObjectError&gt; errors = ex.getAllErrors();            String error = errors.get(0).toString();            String reg = &quot;[^\u4e00-\u9fa5]&quot;;//使用正则提取错误中的中文信息            String str = error.replaceAll(reg, &quot;&quot;);            return Result.fillArgs(ErrorCodeEnum.BIND_ERROR, str);//带参数异常        } else if (e instanceof GlobalException) {            GlobalException ex = (GlobalException) e;            return Result.error(ex.getI());        } else {            log.error(&quot;其他异常&quot;);            return Result.error(ErrorCodeEnum.NET_ERROR);        }    }}</code></pre><h3 id="6-ThreadLocal存储user"><a href="#6-ThreadLocal存储user" class="headerlink" title="6.ThreadLocal存储user"></a>6.ThreadLocal存储user</h3><p><strong>在页面中很多地方都需要用于处于登录状态才能获取并操作该页面，我们无法为每一个controller中每个方法都执行获取用户的操作，我们可以在第一次登录时把用户保存到Cookie中或者session中</strong></p><p><strong>但是当后端在很多方法中都需要用户的时候我们没办法每次都去获取，我们可以在第一次获取到时把它保存到ThreadLocal中(一个用户操作对应一个线程，所以我们可以放心保存)，需要的时候直接拿出来使用</strong></p><pre><code class="java">public class UserContext {    private static ThreadLocal&lt;User&gt; userContext = new ThreadLocal&lt;&gt;();    public static void setUserContext(User userContext) {        UserContext.userContext.set(userContext);    }    public static User getUserContext() {        return userContext.get();    }}</code></pre><blockquote><p>ThreadLocal当然可以保存很多东西，比如交易Id、票据等，当这些东西保存到数据库的话会浪费很多资源，我们可以直接放到ThreadLocal中</p></blockquote><h3 id="7-基于RabbitMQ实现商品秒杀扣减库存"><a href="#7-基于RabbitMQ实现商品秒杀扣减库存" class="headerlink" title="7.基于RabbitMQ实现商品秒杀扣减库存"></a>7.基于RabbitMQ实现商品秒杀扣减库存</h3><ul><li>初始化将库存加载到Redis</li><li>收到请求，预减库存，库存不足返回(利用Redis单线程)，已经有订单返回</li><li>成功请求入队</li><li>请求出队，生成订单；客户端轮询秒杀是否成功</li></ul><blockquote><p>这样不仅把秒杀和扣减库存解耦，还让生成订单成为了异步操作，我们只需要提交秒杀请求，而不需要等到获取到结果再返回。</p></blockquote><h3 id="8-Redis的深度使用"><a href="#8-Redis的深度使用" class="headerlink" title="8.Redis的深度使用"></a>8.Redis的深度使用</h3><h4 id="Redis根据前缀存储"><a href="#Redis根据前缀存储" class="headerlink" title="Redis根据前缀存储"></a>Redis根据前缀存储</h4><p><strong>我们使用redis存储时，通常不会考虑到不同用户不同操作不同请求的存储方式，通过这个项目我学会了使用<code>前缀</code>的方式存储数据到Redis中，不同用户根据id存储，不同操作根据方式存储，不同请求根据url存储，这样就可以区分每个<code>put</code>的key是来自哪个操作哪个请求和哪个用户，进行后台管理时也会很方便</strong></p><p><strong>最重要的一点是，我们可以通过前缀设置该<code>key</code>的过期时间</strong></p><ul><li>创建一个前缀接口</li></ul><pre><code class="java">public interface KeyPrefix {    public int expireSeconds();    public String getPrefix();}</code></pre><ul><li>创建一个抽象类实现该接口(提供一个实现模板)</li></ul><pre><code class="java">@AllArgsConstructor@RequiredArgsConstructorpublic abstract class BasePrefix implements KeyPrefix {    @NonNull    private String prefix;//前缀    private int expireSeconds;//过期时间，默认永久    @Override    public int expireSeconds() {        return expireSeconds;    }    @Override    public String getPrefix() {        String className = getClass().getSimpleName();        return className + &quot;:&quot; + prefix;    }}</code></pre><ul><li>就可以创建不同的前缀了，例如：根据用户获取方式不同的创建不同的前缀，不设置过期时间</li></ul><pre><code class="java">public class UserKey extends BasePrefix {    public UserKey(String prefix, int expireSeconds) {        super(prefix, expireSeconds);    }    public UserKey(String prefix) {        super(prefix);    }    public static UserKey getById = new UserKey(&quot;id&quot;);    public static UserKey getByName = new UserKey(&quot;name&quot;);}</code></pre><ul><li>要保存到Redis需要为RedisService实现自定义的set、get方法</li></ul><pre><code class="java"> public &lt;T&gt; boolean set(KeyPrefix prefix, String key, T value) {        Jedis jedis = null;        try {            jedis = jedisPool.getResource();            String str = beanToString(value);            if (str == null || str.length() &lt;= 0) {                return false;            }            //生成真正的key            String realKey = prefix.getPrefix() + key;            int seconds = prefix.expireSeconds();            if (seconds &lt;= 0) {                jedis.set(realKey, str);            } else {                jedis.setex(realKey, seconds, str);            }            return true;        } finally {            returnToPool(jedis);        }    }</code></pre><pre><code class="java">public &lt;T&gt; T get(KeyPrefix prefix, String key, Class&lt;T&gt; clazz) {        Jedis jedis = null;        try {            jedis = jedisPool.getResource();            //生成真正的key            String realKey = prefix.getPrefix() + key;            String str = jedis.get(realKey);            T t = stringToBean(str, clazz);            return t;        } finally {            returnToPool(jedis);        }    }</code></pre><h4 id="Redis在分布式session的使用"><a href="#Redis在分布式session的使用" class="headerlink" title="Redis在分布式session的使用"></a>Redis在分布式session的使用</h4><p><strong>在使用分布式Session的时候，我们需要把生成的token值作为key保存到redis中，依赖获取用户user对象</strong></p><pre><code class="java">private String addOrUpdateCookie(HttpServletResponse response, String token, SeckillUser user) {        if (StringUtils.isEmpty(token)) {            token = UUIDUtil.uuid();        }        redisService.set(UserKey.token, token, user);//用户前缀中的token前缀，存储时将加上“token”        Cookie cookie = new Cookie(COOKIE_NAME_TOKEN, token);        int ex = SecKillUserKey.token.expireSeconds();        cookie.setMaxAge(ex);//过期时间子在前缀中获取        cookie.setPath(&quot;/&quot;);        response.addCookie(cookie);        return token;    }</code></pre><h4 id="Redis缓存验证码结果"><a href="#Redis缓存验证码结果" class="headerlink" title="Redis缓存验证码结果"></a>Redis缓存验证码结果</h4><p><strong>我们为秒杀操作添加验证码的时候，我们需要有一个地方保存验证码的计算结果，我们选择Redis保存</strong></p><h4 id="Redis缓存页面"><a href="#Redis缓存页面" class="headerlink" title="Redis缓存页面"></a>Redis缓存页面</h4><p><strong>页面每次渲染需要很长时间，我们可以把html缓存到redis中，过期时间短一些，防止页面不刷新</strong></p><h4 id="Redis缓存库存数量"><a href="#Redis缓存库存数量" class="headerlink" title="Redis缓存库存数量"></a>Redis缓存库存数量</h4><p><strong>我们可以在加载商品信息页面的时候把商品的库存缓存到redis中，避免高并发情况下每次都去访问数据库，redis中预减库存为0后，其他线程都将直接返回秒杀失败</strong></p><h4 id="Redis缓存加密后的秒杀接口需要的参数"><a href="#Redis缓存加密后的秒杀接口需要的参数" class="headerlink" title="Redis缓存加密后的秒杀接口需要的参数"></a>Redis缓存加密后的秒杀接口需要的参数</h4><p><strong>为了防止秒杀接口被刷，我们要携带参数请求并判断参数的正确性，该参数加密后存储到redis中，需要判断的时候拿出来与前端传来的进行判断</strong></p><h3 id="9-加密"><a href="#9-加密" class="headerlink" title="9.加密"></a>9.加密</h3><h4 id="用户密码加密"><a href="#用户密码加密" class="headerlink" title="用户密码加密"></a>用户密码加密</h4><p><strong>只在前端进行加密是不行的，我们后端拿到表单密码(第一次加密后的密码)还需要在进行一次加密，在与数据库中的值进行比对，防止一次加密，前端直接获取到最终数据库中的密码</strong></p><h4 id="秒杀请求接口加密"><a href="#秒杀请求接口加密" class="headerlink" title="秒杀请求接口加密"></a>秒杀请求接口加密</h4><p><strong>防止秒杀请求接口被获取到，直接访问接口秒杀商品，我们就需要对秒杀请求传入一个必须的参数，在后端进行加密后保存到redis并返回给前端，前端拿到数据后提交给真正的秒杀请求，后端判断拿到的数据和redis存储的是否对应，不对应则请求失败</strong></p><pre><code class="java">1.前端携带id请求秒杀接口，实际上是获取秒杀路径的接口2.后端获取id加密保存到redis，并返回加密数据给前端3.前端成功获取到数据后跳转请求到真正的秒杀接口(携带后端传过来的加密数据)4.后端秒杀接口判断该参数和redis中的数据是否相等，不相等说明参数过期或者参数是错误的(伪造的)</code></pre><h3 id="10-layer-web组件使用"><a href="#10-layer-web组件使用" class="headerlink" title="10.layer web组件使用"></a>10.layer web组件使用</h3><blockquote><p>弹窗显示后端传来的结果中的msg信息</p></blockquote><h3 id="11-JMeter压测工具使用"><a href="#11-JMeter压测工具使用" class="headerlink" title="11.JMeter压测工具使用"></a>11.JMeter压测工具使用</h3><p><strong>用来压测秒杀可以承受的并发量</strong></p><p>下载地址：<a href="https://jmeter.apache.org/download_jmeter.cgi" rel="external nofollow noopener noreferrer" target="_blank">https://jmeter.apache.org/download_jmeter.cgi</a></p><p><code>bin/JMeter</code>就是可运行程序，Java GUI写的</p><ul><li>配置环境变量</li></ul><pre><code>vim /etc/profile在最后加入：export JMETER=/home/jmeter/apache-jmeter-2.13export CLASSPATH=${JMETER}/lib/ext/ApacheJMeter_core.jar:${JMETER}/lib/jorphan.jar:$JMETER/lib/logkit-2.0.jar:${CLASSPATH}export PATH=${JMETER}/bin/:${PATH}保存后，source /etc/profile 使环境变量生效。jmeter -v 确认是否配置成功。</code></pre><ul><li>在电脑中创建好测试文件<code>.jmx</code>文件，上传到服务器</li></ul><p>通过执行<code>jmeter -n -t**/路径/*.jmx -l  *.jtl</code>进行压测，得到<code>.jtl</code>结果文件，下载到电脑就可以在JMeter中打开查看了</p><h3 id="12-页面优化"><a href="#12-页面优化" class="headerlink" title="12.页面优化"></a>12.页面优化</h3><h4 id="页面缓存、URL缓存、对象缓存"><a href="#页面缓存、URL缓存、对象缓存" class="headerlink" title="页面缓存、URL缓存、对象缓存"></a>页面缓存、URL缓存、对象缓存</h4><p><strong>使用Springboot提供的Thymeleaf模板引擎获取页面html缓存到Redis中</strong></p><blockquote><p>首先我们要把前端需要的数据放到model对象中</p></blockquote><ul><li>为Controller注入Thymeleaf解析器</li></ul><pre><code class="java">@Autowired    private ThymeleafViewResolver thymeleafViewResolver;</code></pre><ul><li>在请求方法中获取WebContext</li></ul><pre><code class="java">WebContext context = new WebContext(request, response, request.getServletContext(), request.getLocale(), model.asMap());</code></pre><ul><li>通过解析器和context参数获取html</li></ul><pre><code class="java">html = thymeleafViewResolver.getTemplateEngine().process(&quot;goods_list&quot;, context);</code></pre><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><ol><li>加载页面时先查缓存，缓存有就直接获取</li><li>没有的话执行完获取操作添加到model中后</li><li>用Thymeleaf解析器解析页面并写入缓存</li></ol><pre><code class="java">@RequestMapping(value = &quot;/to_list&quot;, produces = &quot;text/html&quot;)    @ResponseBody    public String toList(HttpServletResponse response, HttpServletRequest request,                         Model model, SeckillUser user) throws IOException {        WebContext context = new WebContext(request, response, request.getServletContext(), request.getLocale(), model.asMap());        if (user == null) {            response.sendRedirect(&quot;/login/to_login&quot;);            return &quot;not login&quot;;        } else {            //查缓存            String html = redisService.get(GoodsKey.goodsList, &quot;&quot;, String.class);            if (!StringUtils.isEmpty(html)) {                return html;            }            model.addAttribute(&quot;user&quot;, user);            List&lt;GoodsVo&gt; goodsVoList = goodsService.getGoodsVoList();            log.info(&quot;goods list:{}&quot;, goodsVoList);            model.addAttribute(&quot;goodsList&quot;, goodsVoList);            /**             * 使用页面缓存             * 1.取缓存             * 2.为空则渲染写入缓存             */            html = thymeleafViewResolver.getTemplateEngine().process(&quot;goods_list&quot;, context);            redisService.set(GoodsKey.goodsList, &quot;&quot;, html);            return html;        }    }</code></pre><h4 id="页面静态化"><a href="#页面静态化" class="headerlink" title="页面静态化"></a>页面静态化</h4><p><strong>在前后端分离后，静态资源不需要从服务器端加载渲染，浏览器会帮我们缓存到客户端，当然我们也可以使用CDN等加速(有限从最近节点获取)保存静态资源</strong></p><ul><li>JS/CSS压缩</li><li>CDN加速</li><li>合并CSS/JS文件，减少连接数</li></ul><h3 id="13-唯一索引防止超卖"><a href="#13-唯一索引防止超卖" class="headerlink" title="13.唯一索引防止超卖"></a>13.唯一索引防止超卖</h3><p><strong>除了在sql中加上库存判断外，我们为了保证商品不超卖还需要添加一个唯一索引</strong></p><blockquote><p>唯一索引，即是唯一的意思，在数据库表结构中对字段(一个或者多个字段)添加唯一索引后进行数据库进行存储操作时数据库会判断库中是否已经存在此数据，不存在此数据时才能进行插入操作。</p></blockquote><p>我们建立两个字段的唯一索引：商品id和用户id</p><pre><code class="java">alter table table_name add unique(column1,column2)</code></pre><ul><li>创建订单时，如果存在商品id和用户id都在存在(与待创建的一样)的订单，则不能插入</li></ul><h3 id="14-秒杀限流"><a href="#14-秒杀限流" class="headerlink" title="14.秒杀限流"></a>14.秒杀限流</h3><ul><li>使用验证码减少同一时间内的请求数量</li></ul><p>使用<code>Graphics</code>画出表达式并通过<code>BufferedImage</code>生成验证码通过<code>ImageIO</code>通过write方法写到response，并使用JDK6提供的脚本支持<code>ScriptEngine</code>来调用<code>js.eval()</code>方法计算验证码不等式的值，保存到redis中，根据用户输入的去redis中比对。</p><ol><li>生成表达式</li></ol><pre><code class="java">private static char[] ops = new char[] {&#39;+&#39;, &#39;-&#39;, &#39;*&#39;};    private String generateVerifyCode(Random rdm) {        int num1 = rdm.nextInt(10);        int num2 = rdm.nextInt(10);        int num3 = rdm.nextInt(10);        char op1 = ops[rdm.nextInt(3)];        char op2 = ops[rdm.nextInt(3)];        String exp = &quot;&quot;+ num1 + op1 + num2 + op2 + num3;        return exp;    }</code></pre><ol start="2"><li>生成验证码</li></ol><pre><code class="java">int width = 80;        int height = 32;        //create the image        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);        Graphics g = image.getGraphics();        // set the background color        g.setColor(new Color(0xDCDCDC));        g.fillRect(0, 0, width, height);        // draw the border        g.setColor(Color.black);        g.drawRect(0, 0, width - 1, height - 1);        // create a random instance to generate the codes        Random rdm = new Random();        // make some confusion        for (int i = 0; i &lt; 50; i++) {            int x = rdm.nextInt(width);            int y = rdm.nextInt(height);            g.drawOval(x, y, 0, 0);        }        // generate a random code        String verifyCode = generateVerifyCode(rdm);        g.setColor(new Color(0, 100, 0));        g.setFont(new Font(&quot;Candara&quot;, Font.BOLD, 24));        g.drawString(verifyCode, 8, 24);        g.dispose();        //把验证码存到redis中        int rnd = calc(verifyCode);        redisService.set(SecKillUserKey.getVerifyCode, user.getId()+&quot;,&quot;+goodsId, rnd);        //输出图片        return image;</code></pre><ol start="2"><li>ScriptEngine调用js的eval方法</li></ol><pre><code class="java">ScriptEngineManager manager = new ScriptEngineManager();            ScriptEngine engine = manager.getEngineByName(&quot;JavaScript&quot;);            return (Integer)engine.eval(exp);//计算表达式的值并返回结果</code></pre><ul><li>使用拦截器防止用户在几秒内多次请求(防刷)</li></ul><p>把最大限制次数在第一次请求时放到redis中，之后每请求一次redis对key执行<code>decr</code>方法，&lt;0的话则返回错误信息，限制访问。</p><pre><code class="java">@Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        if (handler instanceof HandlerMethod) {            //获取用户            SeckillUser user = getUser(request, response);            //放到UserContext的ThreadLocal存储            UserContext.setUserContext(user);            log.info(&quot;把用户{}存储到ThreadLocal中&quot;,user.getId());            HandlerMethod method = (HandlerMethod) handler;            AccessLimit limit = method.getMethodAnnotation(AccessLimit.class);            if (limit == null) {                return true;            }            int seconds = limit.seconds();            int maxCount = limit.maxCount();            boolean requiredLogin = limit.needLogin();            String key = request.getRequestURI();//用于redis查找防刷商品            if (requiredLogin) {                if (user == null) {                    log.error(&quot;用户登录信息获取错误&quot;);                    sendError(ErrorCodeEnum.NOT_LOGIN, response);                    return false;                } else {                    key += &quot;_&quot; + user.getId();                }            }            //限流防刷访问            SecKillUserKey getAccessCount = SecKillUserKey.getAccessCount(seconds);            Integer count = redisService.get(getAccessCount, key, Integer.class);            if (count == null) {                redisService.set(getAccessCount, key, maxCount);            } else if (count &gt; 0) {                redisService.decr(getAccessCount, key);            } else {                log.error(&quot;操作达到上限，稍等再试&quot;);                sendError(ErrorCodeEnum.REQUEST_TOO_MUCH, response);                return false;            }            return true;        }        return true;    }</code></pre>]]></content>
    
    <summary type="html">
    
      关于Service层调用dao层，关于Dto、Vo和实体的使用，关于枚举类定义以及结果封装，关于注解的使用，异常的声明以及全局异常处理器，ThreadLocal使用，Redis深度使用，RabbitMQ使用，加密，压测JMeter，页面优化
    
    </summary>
    
      <category term="项目" scheme="https://www.dzou.top/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="项目" scheme="https://www.dzou.top/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="秒杀" scheme="https://www.dzou.top/tags/%E7%A7%92%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ理解和使用</title>
    <link href="https://www.dzou.top/post/rabbitmq.html"/>
    <id>https://www.dzou.top/post/rabbitmq.html</id>
    <published>2019-09-11T11:55:55.000Z</published>
    <updated>2019-09-12T11:55:20.436Z</updated>
    
    <content type="html"><![CDATA[<p>##　JMS—Java消息服务</p><blockquote><p>JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。</p></blockquote><p><strong>RabbitMQ客户端、ActiveMQ、Kafka、RocketMQ等都有使用JMS API实现</strong></p><p><strong>异步：</strong>订阅者或消费者可以注册为一个消息监听器。当消息到达之后，系统自动调用监听器的onMessage方法。</p><p><strong>同步：</strong>订阅者或消费者调用receive方法来接收消息，receive方法在能够接收到消息之前（或超时之前）将一直阻塞</p><h3 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h3><h4 id="点对点"><a href="#点对点" class="headerlink" title="点对点"></a>点对点</h4><p>每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。</p><img src="http://dzou.wangminwei.top/static/images/rabbitmq/7.png"><h4 id="发布者-订阅者-Pub-Sub"><a href="#发布者-订阅者-Pub-Sub" class="headerlink" title="发布者/订阅者(Pub/Sub)"></a>发布者/订阅者(Pub/Sub)</h4><p>多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。</p><img src="http://dzou.wangminwei.top/static/images/rabbitmq/8.png"><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息（Message）是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串，也可以更复杂，可能包含嵌入对象。</p><p>消息队列（Message Queue）是一种应用间的通信方式，消息发送后可以立即返回，由消息系统来确保消息的可靠传递。消息发布者只管把消息发布到 MQ 中而不用管谁来取，消息使用者只管从 MQ 中取消息而不管是谁发布的。这样发布者和使用者都不用知道对方的存在。</p><blockquote><p>从上面的描述中可以看出消息队列是一种应用间的异步协作机制，那什么时候需要使用 MQ 呢？</p><p>以常见的订单系统为例，用户点击【下单】按钮之后的业务逻辑可能包括：扣减库存、生成相应单据、发红包、发短信通知。在业务发展初期这些逻辑可能放在一起同步执行，随着业务的发展订单量增长，需要提升系统服务的性能，这时可以将一些不需要立即生效的操作拆分出来异步执行，比如发放红包、发短信通知等。这种场景下就可以用 MQ ，在下单的主流程（比如扣减库存、生成相应单据）完成之后发送一条消息到 MQ 让主流程快速完结，而由另外的单独线程拉取MQ的消息（或者由 MQ 推送消息），当发现 MQ 中有发红包或发短信之类的消息时，执行相应的业务逻辑。</p><p>以上是用于业务解耦的情况，其它常见场景包括最终一致性、广播、错峰流控等等。</p></blockquote><ul><li>秒杀业务：把扣减库存服务和生成订单服务拆分</li><li>用户注册后发送邮件和短信，无需等待发送，只需提交给RabbitMQ队列异步处理</li></ul><h2 id="RabbitMQ—基于AMQP的消息队列"><a href="#RabbitMQ—基于AMQP的消息队列" class="headerlink" title="RabbitMQ—基于AMQP的消息队列"></a>RabbitMQ—基于AMQP的消息队列</h2><blockquote><p>使用<code>ErLang</code>编写，使用<code>JMS API</code>集成,但是RabbitMQ路由过程除了消息、发送者、接受者还有<code>交换机</code>和<code>绑定者</code>的角色，决定发送到那个队列</p></blockquote><p><strong>消息中间件：分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题。</strong></p><ul><li>异步处理</li><li>应用解耦(订单服务和库存服务)</li><li>流量削峰</li><li>不需要及时得到结果的消息放到MQ中</li></ul><img src="http://dzou.wangminwei.top/static/images/rabbitmq/1.png"><ol><li>Exchange 交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。</li><li>Binding 绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</li><li>Channel 信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内地虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</li><li>Virtual Host 虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。</li><li>Broker 表示消息队列服务器实体。</li></ol><img src="http://dzou.wangminwei.top/static/images/rabbitmq/2.png"><h3 id="Exchange类型"><a href="#Exchange类型" class="headerlink" title="Exchange类型"></a>Exchange类型</h3><h4 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a>Direct</h4><p><strong>消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为“dog”，则只转发 routing key 标记为“dog”的消息，不会转发“dog.puppy”，也不会转发“dog.guard”等等。它是完全匹配、单播的模式.</strong></p><img src="http://dzou.wangminwei.top/static/images/rabbitmq/3.png"><h4 id="Fanout"><a href="#Fanout" class="headerlink" title="Fanout"></a>Fanout</h4><p><strong>每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。fanout 交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。</strong></p><img src="http://dzou.wangminwei.top/static/images/rabbitmq/4.png"><h4 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h4><p><strong>将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。#匹配0个或多个单词，*匹配不多不少一个单词。</strong></p><img src="http://dzou.wangminwei.top/static/images/rabbitmq/5.png"><h3 id="常用命令行操作"><a href="#常用命令行操作" class="headerlink" title="常用命令行操作"></a>常用命令行操作</h3><ul><li><p><code>sudo rabbitmq-server</code>  启动RabbitMQ</p></li><li><p><code>systemctl status rabbitmq-server.service</code> 查看RabbitMQ状态</p></li><li><p><code>sudo systemctl restart rabbitmq-server</code> 重启RabbitMQ</p></li><li><p><code>sudo rabbitmq-plugins enable rabbitmq_management</code> 启用 RabbitMQ web 管理插件 可以在 <code>15672</code>端口进入RabbitMQ后台</p></li><li><p><code>sudo rabbitmqctl stop</code> 停止RabbitMQ(关闭整个节点)</p></li><li><p><code>sudo rabbitmqctl stop_app</code> 只关闭应用程序不关闭节点 </p></li><li><p><code>sudo rabbitmqctl start_app</code>启动应用程序</p></li><li><p><code>sudo rabbitmqctl list_queues</code> 查看RabbitMQ中的队列</p></li><li><p><code>sudo rabbitmqctl list_exchanges</code>查看交换器</p></li><li><p><code>sudo rabbitmqctl list_bindings</code>查看绑定</p></li><li><p><code>sudo rabbitmqctl reset</code> 重置RabbitMQ节点(清空队列)，但是在使用此命令前，要先关闭应用，否则不能清除</p></li><li><p><code>sudo rabbitmqctl add_user  dzou 1234</code> 添加用户</p></li></ul><h3 id="rabbitmq-client"><a href="#rabbitmq-client" class="headerlink" title="rabbitmq-client"></a>rabbitmq-client</h3><ul><li>maven依赖</li></ul><pre><code class="xml">        &lt;dependency&gt;            &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;            &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;            &lt;version&gt;3.6.0&lt;/version&gt;        &lt;/dependency&gt;</code></pre><ul><li>发送者</li></ul><pre><code class="java">public class P {  private final static String QUEUE_NAME = &quot;hello&quot;;  public static void main(String[] argv) throws Exception {    ConnectionFactory factory = new ConnectionFactory();    factory.setHost(&quot;localhost&quot;);    Connection connection = factory.newConnection();    Channel channel = connection.createChannel();    channel.queueDeclare(QUEUE_NAME, false, false, false, null);    String message = &quot;Hello World!&quot;;    channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes(&quot;UTF-8&quot;));    System.out.println(&quot;P [x] Sent &#39;&quot; + message + &quot;&#39;&quot;);    channel.close();    connection.close();  }}</code></pre><ul><li>接收者</li></ul><pre><code class="java">public class C {    private final static String QUEUE_NAME = &quot;hello&quot;;    public static void main(String[] argv) throws Exception {        ConnectionFactory factory = new ConnectionFactory();        factory.setHost(&quot;localhost&quot;);        Connection connection = factory.newConnection();        Channel channel = connection.createChannel();        channel.queueDeclare(QUEUE_NAME, false, false, false, null);        System.out.println(&quot;C [*] Waiting for messages. To exit press CTRL+C&quot;);        Consumer consumer = new DefaultConsumer(channel) {            @Override            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {                String message = new String(body, &quot;UTF-8&quot;);                System.out.println(&quot;C [x] Received &#39;&quot; + message + &quot;&#39;&quot;);            }        };        channel.basicConsume(QUEUE_NAME, true, consumer);    }}</code></pre><h3 id="AmqpTemplate"><a href="#AmqpTemplate" class="headerlink" title="AmqpTemplate"></a>AmqpTemplate</h3><h5 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h5><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h5 id="yml配置"><a href="#yml配置" class="headerlink" title="yml配置"></a>yml配置</h5><pre><code class="yml">spring:  rabbitmq:    host: localhost    port: 5672    username: guest    password: guest    virtual-host: /    listener:      simple:        acknowledge-mode: manual # 手动应答        concurrency: 5 # 消费端最小并发数        max-concurrency: 10 # 消费端最大并发数        prefetch: 5 # 一次请求中预处理的消息数量    cache:      channel:        size: 50 # 缓存的channel数量### 自定义配置 可不需要mq:  defaultExchange: amqpExchange # 默认交换器  queue: queue # 队列名  routeKey: queue_key # 路由key</code></pre><h5 id="配置MQ队列"><a href="#配置MQ队列" class="headerlink" title="配置MQ队列"></a>配置MQ队列</h5><pre><code class="java">@Configurationpublic class MQConfig {    public static final String SECKILL_QUEUE = &quot;seckill.queue&quot;;    @Bean    public Queue secKillQueue(){        return new Queue(SECKILL_QUEUE);    }}</code></pre><h5 id="发送者"><a href="#发送者" class="headerlink" title="发送者"></a>发送者</h5><pre><code class="java">@Service@Slf4jpublic class MQSender {    @Autowired    private AmqpTemplate amqpTemplate;    @Autowired    RedisService redisService;    public void sendSeckillInfo(SecKillMessage secKillMessage) {        String msg = redisService.beanToString(secKillMessage);        log.info(&quot;send message :{}&quot;,msg);        amqpTemplate.convertAndSend(MQConfig.SECKILL_QUEUE,msg);    }    public void send(Object message){        String msg = redisService.beanToString(message);        log.info(&quot;send message :{}&quot;,msg);        amqpTemplate.convertAndSend(MQConfig.QUEUE_NAME,msg);    }    //以Topic模式发送    public void sendTopic(Object message){        String msg = redisService.beanToString(message);        log.info(&quot;send message :{}&quot;,msg);        amqpTemplate.convertAndSend(MQConfig.TOPIC_EXCHANGE_NAME,MQConfig.ROUTING_KEY1_NAME,msg);        amqpTemplate.convertAndSend(MQConfig.TOPIC_EXCHANGE_NAME,MQConfig.ROUTING_KEY_NAME,msg+&quot;17231&quot;);    }    //以fanout模式发送    public void sendFanout(Object message) {        String msg = redisService.beanToString(message);        log.info(&quot;send fanout message:&quot;+msg);        amqpTemplate.convertAndSend(MQConfig.FANOUT_EXCHANGE_NAME, &quot;&quot;, msg);    }    //以Header模式发送    public void sendHeader(Object message) throws UnsupportedEncodingException {        String msg = redisService.beanToString(message);        log.info(&quot;send header message:&quot; + msg);        MessageProperties properties = new MessageProperties();        properties.setHeader(&quot;header1&quot;, &quot;value1&quot;);        properties.setHeader(&quot;header2&quot;, &quot;value2&quot;);        Message obj = new Message(msg.getBytes(&quot;UTF-8&quot;), properties);        amqpTemplate.convertAndSend(MQConfig.HEADERS_EXCHANGE_NAME, &quot;&quot;, obj);    }}</code></pre><h5 id="接收者"><a href="#接收者" class="headerlink" title="接收者"></a>接收者</h5><pre><code class="java">@Slf4j@Service@RabbitListener(queues = MQConfig.SECKILL_QUEUE)public class MQReceive {    @Autowired    private RedisService redisService;    @Autowired    private SecKillService secKillService;    @RabbitHandler    public void receiveMsg(String message){        log.info(&quot;receive msg:{}&quot;,message);        SecKillMessage msg = redisService.stringToBean(message,SecKillMessage.class);            //处理相应的业务逻辑    }    //测试Topic模式    @RabbitListener(queues = MQConfig.TOPIC_QUEUE1_NAME)    public void receiveMsg(String message){        log.info(&quot;receive msg:{}&quot;,message);    }    @RabbitListener(queues = MQConfig.TOPIC_QUEUE2_NAME)    public void receiveMsg2(String message){        log.info(&quot;receive msg:{}&quot;,message);    }    //测试Headers模式    @RabbitListener(queues=MQConfig.HEADERS_QUEUE2_NAME)    public void receiveHeaderQueue(byte[] message) throws UnsupportedEncodingException {        log.info(&quot; header  queue message:&quot;+new String(message,&quot;UTF-8&quot;));    }}</code></pre><h5 id="String和Bean互转"><a href="#String和Bean互转" class="headerlink" title="String和Bean互转"></a>String和Bean互转</h5><blockquote><p>使用alibaba的<code>fastJson</code></p></blockquote><pre><code class="java">//bean转为字符串    public  &lt;T&gt; String beanToString(T value) {        if (value == null) {            return null;        }        Class&lt;?&gt; clazz = value.getClass();        if (clazz == int.class || clazz == Integer.class) {            return &quot;&quot; + value;        } else if (clazz == String.class) {            return (String) value;        } else if (clazz == long.class || clazz == Long.class) {            return &quot;&quot; + value;        } else {            return JSON.toJSONString(value);        }    }    //字符串转为bean    @SuppressWarnings(&quot;unchecked&quot;)    public  &lt;T&gt; T stringToBean(String str, Class&lt;T&gt; clazz) {        if (str == null || str.length() &lt;= 0 || clazz == null) {            return null;        }        if (clazz == int.class || clazz == Integer.class) {            return (T) Integer.valueOf(str);        } else if (clazz == String.class) {            return (T) str;        } else if (clazz == long.class || clazz == Long.class) {            return (T) Long.valueOf(str);        } else {            return JSON.parseObject(str, clazz);        }    }</code></pre><blockquote><p>RabbitMQ支持集群分发消息</p></blockquote><h3 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h3><p>将任务封装为消息并发给队列。在后台运行的工作者（consumer）将其取出，然后最终执行。当你运行多个工作者（consumer），队列中的任务被工作进行共享执行。</p><h3 id="轮询分发"><a href="#轮询分发" class="headerlink" title="轮询分发"></a>轮询分发</h3><p>一个生产者生产消息到队列，多个消费者从队列依次轮询消费消息。这里的轮询机制是你一个，我一个轮询分发机制，比如我有50个消息，无论C1、C2的消费处理能力如何，最后他们都会按照你一个我一个的方式都拿到25个消息消费，这就是所谓的轮询，轮着来的意思。</p><h3 id="消息应答和持久化—针对消费者"><a href="#消息应答和持久化—针对消费者" class="headerlink" title="消息应答和持久化—针对消费者"></a>消息应答和持久化—针对消费者</h3><h4 id="消息应答—ACK"><a href="#消息应答—ACK" class="headerlink" title="消息应答—ACK"></a>消息应答—ACK</h4><blockquote><p>默认情况下如果一个 Message 被消费者所正确接收则会被从 Queue 中移除</p></blockquote><blockquote><p>如果一个 Queue 没被任何消费者订阅，那么这个 Queue 中的消息会被 Cache（缓存），当有消费者订阅时则会立即发送，当 Message 被消费者正确接收时，就会被从 Queue 中移除</p></blockquote><p><strong>Message acknowledgment(消息应答)：当消息被消费者成功接收到时，就会告诉RabbitMQ你可以从队列删除该消息，我已经接收到了</strong></p><pre><code class="java">autoAck = true;//自动确认模式，当消息被接收，就从内存中删除</code></pre><p><strong>这种情况下，杀死消费者就会导致消息丢失。</strong></p><pre><code class="java">autoAck = false;//手动确认模式，如果有消息挂了，就把该消息交给其他消费者</code></pre><p><strong>这种情况下，消费者挂了不会丢失消息，但是如果服务器宕机RabbitMQ挂了，消息也会丢失。</strong></p><blockquote><p>所以我们需要使用其他机制把消息存储起来。</p></blockquote><h4 id="持久化—durable"><a href="#持久化—durable" class="headerlink" title="持久化—durable"></a>持久化—durable</h4><ul><li>声明好的队列无法更改持久化</li></ul><p><strong>默认队列和消息都是放在内存中的，当RabbitMQ退出或者崩溃，将会丢失队列和消息。为了保证即使RabbitMQ崩溃也不会丢失消息，我们必须把“队列”和“消息”设为持久化，当队列和消息持久化以后即使RabbitMQ崩溃，消息还存在磁盘中，当RabbitMQ再次启动的时候，队列和消息仍然还在。</strong></p><ul><li><strong>durable</strong>设置为true</li></ul><pre><code class="java">// 队列持久化boolean durable = true;  channel.queueDeclare(&quot;hello&quot;, durable, false, false, null); // 消息持久化 方式一channel.basicPublish(&quot;&quot;, &quot;key&quot;, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes(&quot;UTF-8&quot;));// 消息持久化 方式二AMQP.BasicProperties.Builder properties = new AMQP.BasicProperties().builder();properties.deliveryMode(2);  // 设置消息是否持久化，1： 非持久化 2：持久化channel.basicPublish(&quot;&quot;, &quot;key&quot;, properties.build(), message.getBytes(&quot;UTF-8&quot;));</code></pre><p><strong>但是消息任然可以没有保存到内存中，如果要完全100%保证写入RabbitMQ的数据必须落地磁盘，不会丢失，需要依靠其他的机制。</strong></p><h3 id="消息确认机制—针对生产者"><a href="#消息确认机制—针对生产者" class="headerlink" title="消息确认机制—针对生产者"></a>消息确认机制—针对生产者</h3><p><strong>当消息的发布者在将消息发送出去之后，消息到底有没有正确到达broker代理服务器呢？</strong></p><blockquote><p>如果到不了，那么持久化将无法使用，为此，我们还需要对生产者发送消息建立确认机制</p></blockquote><p>RabbitMQ提供两种消息确认机制：</p><ul><li>事务：通过AMQP事务机制实现</li><li>confirm：通过将channel设置成confirm模式来实现</li></ul><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p><strong>RabbitMQ中与事务机制有关的方法有三个：txSelect(), txCommit()以及txRollback(), txSelect用于将当前channel设置成transaction模式，txCommit用于提交事务，txRollback用于回滚事务，在通过txSelect开启事务之后，我们便可以发布消息给broker代理服务器了，如果txCommit提交成功了，则消息一定到达了broker了，如果在txCommit执行之前broker异常崩溃或者由于其他原因抛出异常，这个时候我们便可以捕获异常通过txRollback回滚事务了。</strong></p><pre><code class="java">channel.txSelect();//开启事务模式channel.basicPublish(ConfirmConfig.exchangeName, ConfirmConfig.routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, ConfirmConfig.msg_10B.getBytes());channel.txCommit();</code></pre><blockquote><p>只有消息成功被服务器接受，事务提交才能成功，否则我们便可以在捕获异常进行事务回滚操作同时进行消息重发，但是使用事务机制的话会降低RabbitMQ的性能,<code>下面我们还用一种更高效的方法确认消息的提交：confirm</code></p></blockquote><h4 id="confirm"><a href="#confirm" class="headerlink" title="confirm"></a>confirm</h4><p><strong>消息的确认是指生产者投递消息后，如果 Broker 代理服务器接收到消息，则会给生产者一个应答(根据一个指定的唯一id确认消息)。生产者进行接收应答，用来确认这条消息是否正常的发送到 Broker，这种方式也是消息可靠性投递的核心保障</strong></p><img src="http://dzou.wangminwei.top/static/images/rabbitmq/6.png"><ul><li>设置为confirm模式</li></ul><pre><code class="java">channel.confirmSelect();</code></pre><h5 id="confirm模式有三种："><a href="#confirm模式有三种：" class="headerlink" title="confirm模式有三种："></a>confirm模式有三种：</h5><ul><li>普通confirm模式：每发送一条消息后，调用<code>waitForConfirms()</code>方法，等待服务器端confirm。实际上是一种串行confirm。</li></ul><pre><code class="java">channel.basicPublish(ConfirmConfig.exchangeName, ConfirmConfig.routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, ConfirmConfig.msg_10B.getBytes());if(!channel.waitForConfirms()){    System.out.println(&quot;send message failed.&quot;);}</code></pre><ul><li>批量confirm模式：每发送一批消息后，调用<code>waitForConfirms()</code>方法，等待服务器端confirm。</li></ul><pre><code class="java">channel.confirmSelect();for(int i=0;i&lt;batchCount;i++){    channel.basicPublish(ConfirmConfig.exchangeName, ConfirmConfig.routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, ConfirmConfig.msg_10B.getBytes());}if(!channel.waitForConfirms()){    System.out.println(&quot;send message failed.&quot;);}</code></pre><blockquote><p>其中一个消息返回false需要消息全部重发</p></blockquote><ul><li>异步confirm模式：提供一个回调方法(监听器)，服务端confirm了一条或者多条消息后Client端会回调这个方法。</li></ul><pre><code class="java"> channel.confirmSelect();        channel.addConfirmListener(new ConfirmListener() {            //发送成功            public void handleAck(long deliveryTag, boolean multiple) throws IOException {                //成功进入这，根据业务实现            }            //发送失败            public void handleNack(long deliveryTag, boolean multiple) throws IOException {                System.out.println(&quot;Nack, SeqNo: &quot; + deliveryTag + &quot;, multiple: &quot; + multiple);                //失败进入这，根据业务实现            }        });        while (true) {            long nextSeqNo = channel.getNextPublishSeqNo();            channel.basicPublish(ConfirmConfig.exchangeName, ConfirmConfig.routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, ConfirmConfig.msg_10B.getBytes());            confirmSet.add(nextSeqNo);        }</code></pre><p>参考博文：</p><p><a href="https://juejin.im/post/5a67f7836fb9a01cb74e8931" rel="external nofollow noopener noreferrer" target="_blank">https://juejin.im/post/5a67f7836fb9a01cb74e8931</a></p><p><a href="https://segmentfault.com/a/1190000017130224" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000017130224</a></p><p>安装参考：</p><p><a href="https://blog.csdn.net/nextyu/article/details/79250174#commentBox" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/nextyu/article/details/79250174#commentBox</a></p>]]></content>
    
    <summary type="html">
    
      RabbitMQ—基于AMQP的消息队列.JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。消息中间件：分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题。
    
    </summary>
    
      <category term="消息中间件" scheme="https://www.dzou.top/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="项目" scheme="https://www.dzou.top/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="消息队列" scheme="https://www.dzou.top/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
      <category term="JMS" scheme="https://www.dzou.top/tags/JMS/"/>
    
      <category term="消息中间件" scheme="https://www.dzou.top/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot读取配置文件的方法</title>
    <link href="https://www.dzou.top/post/read-config-springboot.html"/>
    <id>https://www.dzou.top/post/read-config-springboot.html</id>
    <published>2019-09-11T07:55:55.000Z</published>
    <updated>2019-09-12T12:05:24.301Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>推荐两种方法</p><ul><li>@Value注解 <code>org.springframework.beans.factory.annotation.Value</code></li><li>@ConfigurationProperties注解 <code>org.springframework.boot.context.properties.ConfigurationProperties</code></li></ul></blockquote><h3 id="Value注解"><a href="#Value注解" class="headerlink" title="@Value注解"></a>@Value注解</h3><ul><li>需要声明为<code>Component</code>，在需要的的地方可以直接注入并使用<code>getter</code>方法获取</li></ul><p>下面以redis配置为例</p><pre><code class="java">@Data@Componentpublic class RedisConfig {    @Value(&quot;${redis.host}&quot;)    private String host;    @Value(&quot;${redis.port}&quot;)    private int port;    @Value(&quot;${redis.timeout}&quot;)    private int timeout;//秒    @Value(&quot;${redis.password}&quot;)    private String password;    @Value(&quot;${redis.pool-max-active}&quot;)    private int poolMaxActive;    @Value(&quot;${redis.pool-max-idle}&quot;)    private int poolMaxIdle;    @Value(&quot;${redis.pool-max-wait}&quot;)    private int poolMaxWait;//秒}</code></pre><ul><li>在yml配置文件中写入</li></ul><pre><code class="yml">redis:  host: 127.0.0.1  port: 6379  timeout: 100  password: ××××  pool-max-active: 2000  pool-max-idle: 10  pool-max-wait: 10000</code></pre><ul><li>在需要的地方自动注入并获取值，例如redispool连接池</li></ul><pre><code class="java">public class RedisPoolFactory {    @Autowired    RedisConfig redisConfig;    @Bean    public JedisPool JedisPoolFactory() {        JedisPoolConfig poolConfig = new JedisPoolConfig();        poolConfig.setMaxIdle(redisConfig.getPoolMaxIdle());        poolConfig.setMaxTotal(redisConfig.getPoolMaxActive());        poolConfig.setMaxWaitMillis(redisConfig.getPoolMaxWait() * 1000);        JedisPool jp = new JedisPool(poolConfig, redisConfig.getHost(), redisConfig.getPort(),                redisConfig.getTimeout(), redisConfig.getPassword(), 0);        return jp;    }}</code></pre><h3 id="ConfigurationProperties注解"><a href="#ConfigurationProperties注解" class="headerlink" title="@ConfigurationProperties注解"></a>@ConfigurationProperties注解</h3><blockquote><p>也需要注上Component被扫描到 通过<code>prefix</code>前缀的方式获取配置文件<code>properties</code>或者<code>yml</code>的值</p></blockquote><ul><li>yml如下：</li></ul><pre><code class="yml">info:   name: dx   tel: 1271286123   add: China   # list结构   recipients[0]: admin@mail.com   recipients[1]: owner@mail.com   # Map结构   hobby:       sports: basketball       music: gentle</code></pre><ul><li>配置文件获取类如下</li></ul><pre><code class="java">@Data@Component@ConfigurationProperties(prefix = &quot;info&quot;)public class RedisConfig {    private String name;    private String tel;    private String add;    Map&lt;String,String&gt; hobby;    List&lt;String&gt; recipients;}</code></pre><h3 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h3><ul><li>当然，两种方法都可以指定配置文件的路径，通过<code>@PropertySource</code>注解，注到获取配置信息类上</li></ul><pre><code class="java">@PropertySource(&quot;classpath:application.properties&quot;)</code></pre>]]></content>
    
    <summary type="html">
    
      Springboot读取配置文件方式，@Value注解，@ConfigurationProperties注解 ，@PropertySource
    
    </summary>
    
      <category term="Java Web" scheme="https://www.dzou.top/categories/Java-Web/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="SpringBoot" scheme="https://www.dzou.top/tags/SpringBoot/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="项目" scheme="https://www.dzou.top/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>JSR参数效验以及自定义参数效验器</title>
    <link href="https://www.dzou.top/post/params-valid.html"/>
    <id>https://www.dzou.top/post/params-valid.html</id>
    <published>2019-09-11T02:55:55.000Z</published>
    <updated>2019-09-12T11:52:02.939Z</updated>
    
    <content type="html"><![CDATA[<p><strong>我们在写Controller或者Service时经常在方法中写入大量的数据校验代码，如下</strong></p><pre><code class="java">       if(StringUtils.isEmpty(pass)){            return Result.error(ErrorCodeEnum.PASSWORD_EMPTY);        }else if(!ValidatorUtil.isMobile(mobile)){            return Result.error(ErrorCodeEnum.MOBILE_PATTERN_WRONG);        }</code></pre><p><strong>不仅浪费时间，还让业务逻辑代码更复杂，下面我们使用JSR303为我们提供的校验工具避免过多的代码校验</strong></p><h2 id="JSR303"><a href="#JSR303" class="headerlink" title="JSR303"></a>JSR303</h2><blockquote><p>JSR 303 – Bean Validation 是一个数据验证的规范，不符合规范的将返回一条具体的信息说明该规范的错误</p></blockquote><ul><li>有以下注解为我们提供校验</li></ul><pre><code class="java">@Null    被注释的元素必须为 null@NotNull    被注释的元素必须不为 null@AssertTrue    被注释的元素必须为 true@AssertFalse    被注释的元素必须为 false@Min(value)    被注释的元素必须是一个数字，其值必须大于等于指定的最小值@Max(value)    被注释的元素必须是一个数字，其值必须小于等于指定的最大值@DecimalMin(value)    被注释的元素必须是一个数字，其值必须大于等于指定的最小值@DecimalMax(value)    被注释的元素必须是一个数字，其值必须小于等于指定的最大值@Size(max, min)    被注释的元素的大小必须在指定的范围内@Digits (integer, fraction)    被注释的元素必须是一个数字，其值必须在可接受的范围内@Past    被注释的元素必须是一个过去的日期@Future    被注释的元素必须是一个将来的日期@Pattern(value)    被注释的元素必须符合指定的正则表达式</code></pre><ul><li>例如：一个封装的登录信息类<code>LoginVo</code></li></ul><pre><code class="java">@Datapublic class LoginVo {    @NotNull    @Length(max = 11,min = 11)    private String mobile;//手机号    @NotNull    @Length(min = 32)    private String password;//密码}</code></pre><blockquote><p>我们使用@NotNull注解为该字段声明为非空，也就是前端传过来的该参数必须有具体的值，不能为null</p><p>@Length注解为字段声明字符串最长最短的临界条件，前端传来的数据必须符合要求</p></blockquote><ul><li>最后我们在使用到登录封装类的地方(如Controller参数)打上<code>@Valid</code>注解，就会帮我们的封装类进行校验</li></ul><pre><code class="java">public Result doLogin( @Valid LoginVo loginVo)</code></pre><h3 id="自定义验证器"><a href="#自定义验证器" class="headerlink" title="自定义验证器"></a>自定义验证器</h3><blockquote><p>为了深入了解JSR303，我们将实现一个自定义验证器(自定义注解实现具体的验证代码)，观察它是如何工作的</p></blockquote><ul><li><p>现在我们需要为登录信息类里的<code>mobile</code>字段进行手机号校验(校验是否为手机号，格式错误返回格式错误信息)</p></li><li><p>我们将其声明为<code>@IsMobile</code>注解</p></li></ul><p><strong>通过观察上述众多注解，发现验证器的一般代码如下</strong></p><ul><li>validatedBy：就是要传入一个具体的自定义验证器类(实现验证器逻辑)</li><li>message方法：这里返回具体的校验失败的错误信息</li></ul><pre><code class="java">@Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})@Retention(RetentionPolicy.RUNTIME)@Repeatable(IsMobile.List.class)@Documented@Constraint(        validatedBy = {MobileValidator.class}//这里的validatedBy就是要传入一个具体的自定义验证器类(实现验证器逻辑))public @interface IsMobile {    boolean required() default true;//可以使用该字段声明是否必须    String message() default &quot;手机号格式不合法&quot;;//这里返回具体的校验失败的错误信息    Class&lt;?&gt;[] groups() default {};    Class&lt;? extends Payload&gt;[] payload() default {};    @Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})    @Retention(RetentionPolicy.RUNTIME)    @Documented    public @interface List {        IsMobile[] value();    }}</code></pre><ul><li><p>所以我们需要编写一个类实现验证器逻辑<code>MobileValidator</code></p><blockquote><p>验证器需要实现<code>ConstraintValidator</code>接口，该接口用泛型指定两个参数</p><ul><li>&lt;A extends Annotation, T&gt;</li><li>第一个参数A：就是自定义注解的类</li><li>T就是具体需要校验的值的类型</li></ul></blockquote></li></ul><p><strong>重写其中的<code>isValid</code>方法</strong></p><pre><code class="java">public class MobileValidator implements ConstraintValidator&lt;IsMobile, String&gt; {    private boolean required = true;    @Override    public void initialize(IsMobile constraintAnnotation) {    }    @Override    public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) {        if(required){//如果必须 说明以传入  则进行效验            return ValidatorUtil.isMobile(s);        }else {//如果不必须 说明可以没有 先判断是否为空再校验            if (StringUtils.isEmpty(s)) {                return false;            } else return ValidatorUtil.isMobile(s);        }    }}</code></pre><ul><li>ValidatorUtil 工具类 用户验证</li></ul><pre><code class="java">public class ValidatorUtil {    //使用正则匹配1开头的11位数字    private static final Pattern mobile_pattern = Pattern.compile(&quot;1\\d{10}&quot;);//如果匹配返回true，手机号格式正确    public static boolean isMobile(String s){        if(StringUtils.isEmpty(s)){            return false;        }        Matcher m = mobile_pattern.matcher(s);        return m.matches();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      JSR 303 – Bean Validation 是一个数据验证的规范，不符合规范的将返回一条具体的信息说明该规范的错误，我们使用@NotNull注解为该字段声明为非空，也就是前端传过来的该参数必须有具体的值，不能为null，为了深入了解JSR303，我们将实现一个自定义验证器(自定义注解实现具体的验证代码)，观察它是如何工作的
    
    </summary>
    
      <category term="Java Web" scheme="https://www.dzou.top/categories/Java-Web/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="参数效验" scheme="https://www.dzou.top/tags/%E5%8F%82%E6%95%B0%E6%95%88%E9%AA%8C/"/>
    
      <category term="JSR" scheme="https://www.dzou.top/tags/JSR/"/>
    
      <category term="项目" scheme="https://www.dzou.top/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>分布式session的几种实现</title>
    <link href="https://www.dzou.top/post/distributed-session.html"/>
    <id>https://www.dzou.top/post/distributed-session.html</id>
    <published>2019-09-11T01:55:55.000Z</published>
    <updated>2019-09-12T11:58:18.296Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SpringBoot-分布式session"><a href="#SpringBoot-分布式session" class="headerlink" title="SpringBoot 分布式session"></a>SpringBoot 分布式session</h3><blockquote><p>在如今服务器集群的情况下，用户登录会话状态的保存也从单机的变成了分布式要求的，下面详细说一下几种分布式session存储方案。</p></blockquote><ol><li><p>session复制：在支持session复制的服务器上进行，同步session，保持session一致</p><p>方案：<code>tomcat-redis-session-manager</code></p></li><li><p>session粘滞：强行分发session到各个服务器</p><p>方案：负载均衡</p></li><li><p>cookie存储session：把sessionid存储到cookie中(不安全，cookie容易被盗取，可以存储不重要的数据)</p></li><li><p>session集中管理：把用户的session存储在单台或者集群服务器的缓存中，所有web服务器从中拿取session，实现session共享</p><p>方案：Redis存储用户生成的sessionId或者存储保存sessionId的cookie</p></li></ol><blockquote><p>这里只讲解第四种方案，使用最多最稳定</p></blockquote><h3 id="Redis做缓存持久化存储session"><a href="#Redis做缓存持久化存储session" class="headerlink" title="Redis做缓存持久化存储session"></a>Redis做缓存持久化存储session</h3><h4 id="Redis存储cookie，里面保存用户生成的uuid-token作为sessionId"><a href="#Redis存储cookie，里面保存用户生成的uuid-token作为sessionId" class="headerlink" title="Redis存储cookie，里面保存用户生成的uuid(token作为sessionId)"></a>Redis存储cookie，里面保存用户生成的uuid(token作为sessionId)</h4><ul><li>cookie名称和过期时间</li></ul><pre><code class="java">public static final String COOKIE_NAME_TOKEN = &quot;token&quot;;private static final ex  = 3600;</code></pre><ul><li>创建cookie并存储到redis</li></ul><pre><code class="java">private String addCookie(HttpServletResponse response,SeckillUser user){        String token = UUIDUtil.uuid();        redisService.set(token,user);//使用redis把token作为键存储user作为值 我使用jedis自己实现的也可以使用redisTemplate        Cookie cookie = new Cookie(COOKIE_NAME_TOKEN, token);//设置cookie 名称为token        cookie.setMaxAge(ex);//设置过期时间         cookie.setPath(&quot;/&quot;);        response.addCookie(cookie);        return token;    }</code></pre><ul><li>uuid作为sessionid生成工具</li></ul><pre><code class="java">public class UUIDUtil {    public static String uuid(){        return UUID.randomUUID().toString();    }}</code></pre><h4 id="使用Shiro集成的crazy-cake-使用Redis存储SessionId"><a href="#使用Shiro集成的crazy-cake-使用Redis存储SessionId" class="headerlink" title="使用Shiro集成的crazy-cake(使用Redis存储SessionId)"></a>使用Shiro集成的<code>crazy-cake</code>(使用Redis存储SessionId)</h4><ul><li>shiro是一个Web安全框架，用于登录认证，用户身份授权，使用易于<code>spring-security</code>，还可以继承session、cookie分布式存储</li></ul><p>不了解的可以看这篇博文：<a href="https://www.dzou.top/post/712f837.html">Shiro的使用以及集成redis做缓存</a></p><h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><ul><li><strong>使用缓存存储session（单服务器使用EhCacheManager）</strong></li><li><strong>但是在分布式系统中，服务器集群情况下，EhCacheManager无法解决数据共享（会多次查询数据库），则选择使用redis作为缓存</strong></li></ul><h5 id="Redis实现shiro缓存"><a href="#Redis实现shiro缓存" class="headerlink" title="Redis实现shiro缓存"></a>Redis实现shiro缓存</h5><ul><li><p><strong>分布式共享session和授权信息需要把session和授权持久化到数据库或者缓存 shiro集群为了防止多次插查询数据库</strong></p></li><li><p><strong>自定义实现类:或者使用crazycake开源shiro-redis实现好的工具</strong></p><ul><li><strong>RedisSessionDAO</strong> 可以继承EnterpriseCacheSessionDAO实现session控制</li><li><strong>RedisCache</strong> 继承Cache类实现具体redis操作缓存（remove、get、set、keys</li><li><strong>RedisCacheManager</strong> 实现接口CacheManager的getCache获得RedisCache交给securityManager管理</li></ul><p><strong>使用了ConcurrentMap管理数据和缓存，更加高效</strong></p></li></ul><ol><li>在<code>ShiroConfig</code>配置类中把<code>sessionManager</code>交给<code>DefaultWebSecurityManager</code>管理</li></ol><pre><code class="java">@Bean    public DefaultWebSessionManager sessionManager(){        DefaultWebSessionManager sessionManager  = new DefaultWebSessionManager();        //session时间        sessionManager.setGlobalSessionTimeout(redisConfig().getTimeout());        //删除无效session        sessionManager.setDeleteInvalidSessions(true);        log.info(&quot;sessionManager注入成功&quot;);        sessionManager.setSessionIdCookie(cookie());        // sessionDao 分布式共享session和授权信息需要把session和授权持久化到数据库或者缓存 shiro集群为了防止多次插查询数据库        sessionManager.setSessionDAO(redisSessionDao());        return sessionManager;    }</code></pre><ol start="2"><li>在<code>sessionManager</code>中注入cookie存储<code>jsessionId</code></li></ol><pre><code class="java">@Bean    public SimpleCookie cookie() {        SimpleCookie cookie = new SimpleCookie(&quot;JSESSIONID&quot;);        cookie.setHttpOnly(true);        cookie.setPath(&quot;/&quot;);        return cookie;    }</code></pre><ol start="3"><li>再在<code>sessionManager</code>中注入<code>redisSessionDao</code>负责session持久化</li></ol><pre><code class="java">@Bean    public RedisSessionDAO redisSessionDao(){        RedisSessionDAO redisSessionDAO = new RedisSessionDAO();        redisSessionDAO.setRedisManager(redisManager());        redisSessionDAO.setSessionIdGenerator(sessionIdGenerator());        return redisSessionDAO;    }</code></pre>]]></content>
    
    <summary type="html">
    
      分布式session.session复制：在支持session复制的服务器上进行，同步session，保持session一致.session集中管理：把用户的session存储在单台或者集群服务器的缓存中，所有web服务器从中拿取session，实现session共享
    
    </summary>
    
      <category term="Java Web" scheme="https://www.dzou.top/categories/Java-Web/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="SpringBoot" scheme="https://www.dzou.top/tags/SpringBoot/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="项目" scheme="https://www.dzou.top/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="Redis" scheme="https://www.dzou.top/tags/Redis/"/>
    
      <category term="秒杀" scheme="https://www.dzou.top/tags/%E7%A7%92%E6%9D%80/"/>
    
      <category term="分布式session" scheme="https://www.dzou.top/tags/%E5%88%86%E5%B8%83%E5%BC%8Fsession/"/>
    
      <category term="shiro" scheme="https://www.dzou.top/tags/shiro/"/>
    
  </entry>
  
  <entry>
    <title>前后端两次MD5加密设计</title>
    <link href="https://www.dzou.top/post/md5-encryption.html"/>
    <id>https://www.dzou.top/post/md5-encryption.html</id>
    <published>2019-09-11T01:55:55.000Z</published>
    <updated>2019-09-12T11:58:27.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MD5加密设计"><a href="#MD5加密设计" class="headerlink" title="MD5加密设计"></a>MD5加密设计</h2><blockquote><p>前端后端分别进行一次<code>md5+salt</code>加密</p></blockquote><h3 id="前端加密"><a href="#前端加密" class="headerlink" title="前端加密"></a>前端加密</h3><blockquote><p>为了防止密码明文在http上传输，则需要在前端进行一次md5+salt加密</p></blockquote><ul><li>使用<code>JQuery</code> md5</li></ul><p>前端JQuery md5工具：<a href="https://github.com/emn178/js-md5" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/emn178/js-md5</a></p><ul><li>在前端js中声明一个固定盐salt</li></ul><pre><code class="js">//saltvar g_passsword_salt=&quot;ewn576ifa12&quot;;</code></pre><ul><li>登录js方法中加密调用<code>ajax</code></li></ul><blockquote><p>这里使用<code>layer</code> Web组件，进行ajax消息弹窗</p></blockquote><pre><code class="js">function doLogin(){    var inputPass = $(&quot;#password&quot;).val();    var salt = g_passsword_salt;    //使用盐中5位组合md5加密    var str = &quot;&quot;+salt.charAt(0) + salt.charAt(2) + salt.charAt(5) + inputPass + salt.charAt(7) + salt.charAt(8);    var password = md5(str);    //使用第一次加密的密码进行ajax传输    $.ajax({        url: &quot;/login/do_login&quot;,        type: &quot;POST&quot;,        data:{            mobile:$(&quot;#mobile&quot;).val(),            password: password        },        //成功回调函数        success:function(data){            layer.closeAll();            if(data.code == 2000){                layer.msg(&quot;成功&quot;);                window.location.href=&quot;/goods/to_list&quot;;            }else{                layer.msg(data.msg);            }        },        //失败回调函数        error:function(){            layer.closeAll();        }    });}</code></pre><h3 id="后端加密存储"><a href="#后端加密存储" class="headerlink" title="后端加密存储"></a>后端加密存储</h3><blockquote><p>后端将拿到第一次md5加密的结果，这个密码就是表单提交上来的密码，我们需要在后端编写第二道md5加密方式来加密表单传来的密码后再与数据库存储的两次md5加密的密码进行比较，相同才能登陆成功</p></blockquote><ul><li>第二次加密作用：因为第一次前端加密的密码有可能被窃取的，也可能解析我们的js看到我们前端加密方式，可以直接得到明文密码，所以我们需要第二次后端加密再存储，这样即使前端密码被拿到了后端的也不符合。</li></ul><p><strong>我们将后端使用同样的方式(也可以用不同的方式)再次加密，盐值salt需要相等，用于注册时，后端进行计算出与前端第一次加密匹配的密码。</strong></p><ul><li>依赖：Apache-commons-codec</li></ul><pre><code class="xml">&lt;dependency&gt;            &lt;groupId&gt;commons-codec&lt;/groupId&gt;            &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;            &lt;version&gt;1.9&lt;/version&gt;        &lt;/dependency&gt;</code></pre><ul><li>MD5Util 类</li></ul><pre><code class="java">public class MD5Util {    public static String md5(String t){        return DigestUtils.md5Hex(t);    }    private static final String salt = &quot;ewn576ifa12&quot;;//前端输入的密码到表单提交的密码(第一次加密) 用于校验前端传入的密码与该方法返回的密码是否相等    public static String inputPassToFormPass(String pass){        String s = &quot;&quot; + salt.charAt(0) + salt.charAt(2) + salt.charAt(5) + pass + salt.charAt(7) + salt.charAt(8);        return md5(s);    }//表单提交的密码(第一次加密的密码)到数据库存储的密码(第二次加密)    public static String formPassToDb(String formPass,String salt){        String s = &quot;&quot; + salt.charAt(0) + salt.charAt(2) + salt.charAt(5) + formPass + salt.charAt(7) + salt.charAt(8);        return md5(s);    }//前端输入的明文密码到数据库存储的密码 可用于注册    public static String inputPassToDbPass(String input,String salt){        String form = inputPassToFormPass(input);        return formPassToDb(form,salt);    }}</code></pre><ul><li>登录业务代码</li></ul><pre><code class="java">public boolean login(HttpServletResponse response,String mobile, String formPass) {    //根据手机号获取User用户对象        User user = UserMapper.getById(Long.parseLong(mobile));        if(user==null){            throw new GlobalException(ErrorCodeEnum.MOBILE_NOT_EXIST);//抛出自定义异常        }        String dbPass = user.getPassword();//获取数据库的第二次加密的密码        String dbSalt = user.getSalt();//获取后端存储的盐        String calPass = MD5Util.formPassToDb(formPass,dbSalt);//根据前端表单传来的密码计算出第二次加密结果        if(!calPass.equals(dbPass)){//如果不相等            log.error(&quot;{}登录密码错误&quot;,mobile);            throw new GlobalException(ErrorCodeEnum.LOGIN_FAIL);        }        return true;    }</code></pre>]]></content>
    
    <summary type="html">
    
      前端后端分别进行一次md5+salt加密，为了防止密码明文在http上传输，则需要在前端进行一次md5+salt加密，后端将拿到第一次md5加密的结果，这个密码就是表单提交上来的密码，我们需要在后端编写第二道md5加密方式来加密表单传来的密码后再与数据库存储的两次md5加密的密码进行比较，相同才能登陆成功
    
    </summary>
    
      <category term="Java Web" scheme="https://www.dzou.top/categories/Java-Web/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="SpringBoot" scheme="https://www.dzou.top/tags/SpringBoot/"/>
    
      <category term="Web" scheme="https://www.dzou.top/tags/Web/"/>
    
      <category term="项目" scheme="https://www.dzou.top/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="加密" scheme="https://www.dzou.top/tags/%E5%8A%A0%E5%AF%86/"/>
    
      <category term="MD5" scheme="https://www.dzou.top/tags/MD5/"/>
    
  </entry>
  
  <entry>
    <title>牛客网算法编程题 剑指offer—数值的整数次方 解答</title>
    <link href="https://www.dzou.top/post/quick-mi-numm.html"/>
    <id>https://www.dzou.top/post/quick-mi-numm.html</id>
    <published>2019-09-09T08:29:32.000Z</published>
    <updated>2019-09-12T10:58:59.918Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer—数值的整数次方"><a href="#剑指offer—数值的整数次方" class="headerlink" title="剑指offer—数值的整数次方"></a>剑指offer—数值的整数次方</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><p>保证base和exponent不同时为0</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>这题首先考虑到循环遍历数值的大小次，计算出结果，<code>但是还有比这更优的方法：快速幂</code></p></blockquote><h4 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h4><blockquote><p>快速幂就是快速算底数的n次幂。其时间复杂度为 O(log₂N)，比O(N)更快</p></blockquote><p>例如</p><p><img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D103/sign=885b42e39c16fdfadc6cc2ee878d8cea/d0c8a786c9177f3e48bd45c571cf3bc79e3d5668.jpg" alt="img"></p><p>11的二进制是1011</p><p><img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D247/sign=2a9c504edfc8a786ba2a4d0a5008c9c7/aa18972bd40735fae94ebe0d90510fb30e2408c3.jpg" alt="img"></p><p>因此，我们将a¹¹转化为算</p><p><img src="https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D95/sign=257afe75a8773912c0268964f919a226/e850352ac65c1038803a760ab3119313b17e89b6.jpg" alt="img"></p><ul><li><strong>快速幂可以帮助我们使用二进制快速计算幂函数和指数函数</strong></li></ul><blockquote><p>在正数情况下，我们每次对指数右移，只要它对应二进制位为<code>1</code>，我们就需要乘上a的2的n次方(n为二进制所在位数)，我们可以利用右移每次对一个duoble变量累乘，只要当前位为<code>1</code>就乘上该变量，否则就一直累乘该变量，直到为1的位数，或者指数为0时结束循环。</p></blockquote><p>我们需要用到的：</p><ul><li>判断二进制当前位(最右边一位)是否为1</li></ul><pre><code class="java">(e&amp;1)==1</code></pre><ul><li>每次循环右移</li></ul><pre><code class="java">e&gt;&gt;=1  或者   e=e&gt;&gt;1</code></pre><blockquote><p>当然我们需要考虑到指数为负数的情况，我们知道负数的指数函数为正数的倒数，所以如果为负数我们把它取负保存到一个变量(变为正数进行计算)，最后输出结果时判断该指数为负数的话则输出倒数，反之输出结果。</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="java">public class Solution {    public double Power(double base, int exp) {        int e = exp;//存储正数的指数        double res = 1;//存储结果        double count = base;//原来存储累乘变量        if(exp==0){//指数为0返回1            return 1;        }else if(exp&lt;1){//小于1取负保存到e中            e = -exp;        }        while(e!=0){//循环计算            if((e&amp;1)==1){                res *= count;//利用快速幂，如果当前位为1则相乘            }            count *= base;//累乘操作            e&gt;&gt;=1;//右移        }        return exp&lt;0?1/res:res;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      剑指offer—数值的整数次方.给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。
    
    </summary>
    
      <category term="算法" scheme="https://www.dzou.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="算法" scheme="https://www.dzou.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="牛客" scheme="https://www.dzou.top/tags/%E7%89%9B%E5%AE%A2/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="剑指offer" scheme="https://www.dzou.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="笔试" scheme="https://www.dzou.top/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>牛客网算法编程题 剑指offer—链表倒数第k个节点 解答</title>
    <link href="https://www.dzou.top/post/last-kth-node-linedlist.html"/>
    <id>https://www.dzou.top/post/last-kth-node-linedlist.html</id>
    <published>2019-09-08T08:29:32.000Z</published>
    <updated>2019-09-12T10:57:38.182Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer—链表倒数第k个节点"><a href="#剑指offer—链表倒数第k个节点" class="headerlink" title="剑指offer—链表倒数第k个节点"></a>剑指offer—链表倒数第k个节点</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，输出该链表中倒数第k个结点。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>单向链表只能从前往后获取，而无法从后往前获取</p></blockquote><ul><li>方法1：首先我们可以想到的就是遍历一次链表存储链表长度<code>l</code>，然后再进行一次<code>l-k</code>的循环，获得第k个节点</li></ul><blockquote><p>但是该方法耗费时间太多，时间复杂度大，我们想想有没有一种方法只需要遍历一次就可以获得结果</p></blockquote><ul><li>方法2：我们使用两个指针，第一个指针在循环<code>前k次</code>指向后面一个节点，此时第一个指针指向第<code>k</code>个节点，此时开始两个指针移动，直到第一个指针移动到链表末尾，这个时候第二个指针指向的节点就是倒数第<code>k</code>个节点</li></ul><blockquote><p>这种方法就是使用一点点空间换取了大量的时间，使用一个辅助节点来判断第二个节点需要移动到的位置</p></blockquote><img src="http://dzou.wangminwei.top/static/images/algorithm/8.png"><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li>基础版本</li></ul><pre><code class="java">/*public class ListNode {    int val;    ListNode next = null;    ListNode(int val) {        this.val = val;    }}*/public class Solution {    public ListNode FindKthToTail(ListNode head,int k) {        if(head == null||k == 0){            return null;        }        ListNode node = head;        ListNode kThFlag = head;        while(kThFlag.next!=null){            if(k-1&gt;0){                k--;                kThFlag = kThFlag.next;            }else{                kThFlag = kThFlag.next;                node = node.next;            }        }        if(k&gt;=2){            return null;        }        return node;    }}</code></pre><blockquote><p>看起来很复杂，优化一下，慢慢写出漂亮的代码</p></blockquote><ul><li>简化后</li></ul><pre><code class="java">public ListNode FindKthToTail(ListNode head,int k) {        if(head == null||k == 0)            return null;        ListNode q,p;        q = p = head;        while(q.next!=null){            if(--k&gt;0){                q = q.next;            }else{                q = q.next;                p = p.next;            }        }        return k&gt;=2?null:p;    }</code></pre><h3 id="扩展—删除链表的倒数第N个节点"><a href="#扩展—删除链表的倒数第N个节点" class="headerlink" title="扩展—删除链表的倒数第N个节点"></a>扩展—删除链表的倒数第N个节点</h3><ul><li>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</li></ul><pre><code>示例：给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.说明：给定的 n 保证是有效的。</code></pre><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>根据上面一题思路，但是这里要拿到的是删除节点的前一个节点，执行删除<code>node.next=node.next.next</code></li><li>根据这样的思考，既然拿到删除节点的前一个节点，就要考虑<code>删除节点前一个节点是否为null</code>(不存在，删除节点为头结点)，想到了使用变量<code>i</code>来存储节点数量(每次循环+1)和<code>m</code>存储倒数节点数n的值<ul><li>如果<code>i=m</code>说明要删除头结点，我们需要进行单独操作把头结点指向后面一个节点</li><li>如果<code>i&gt;m</code>说明删除节点n是有效的，在链表范围内，就执行<code>node.next=node.next.next</code>操作</li></ul></li></ul><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre><code class="java">class Solution {    //拿到第n-1个节点    public ListNode removeNthFromEnd(ListNode head, int n) {        ListNode q,h;        q = h = head;        int i = 1;int m = n;        while(q.next!=null){            if(n--&gt;0){                q = q.next;            }else{                q = q.next;                head = head.next;            }            i++;        }        if(i&gt;m){            head.next = n&gt;=1||q==head?null:head.next.next;//n&gt;=1用来判断n是否有效(在链表范围内)；因为n每次减一，如果循环结束了n还不为0则说明n是无效的数(无法删除该节点)        }else if(i==m){            h = h.next;        }        return h;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      剑指offer—链表倒数第k个节点.输入一个链表，输出该链表中倒数第k个结点。
    
    </summary>
    
      <category term="算法" scheme="https://www.dzou.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="算法" scheme="https://www.dzou.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="牛客" scheme="https://www.dzou.top/tags/%E7%89%9B%E5%AE%A2/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="剑指offer" scheme="https://www.dzou.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="笔试" scheme="https://www.dzou.top/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>牛客网算法编程题 剑指offer—合并两个有序链表 解答</title>
    <link href="https://www.dzou.top/post/combine-two-sorted-linkedlist.html"/>
    <id>https://www.dzou.top/post/combine-two-sorted-linkedlist.html</id>
    <published>2019-09-07T08:29:32.000Z</published>
    <updated>2019-09-12T10:56:41.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer—合并两个有序链表"><a href="#剑指offer—合并两个有序链表" class="headerlink" title="剑指offer—合并两个有序链表"></a>剑指offer—合并两个有序链表</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>我们考虑到最优实现，时间复杂度应该为两个链表长度O(M+N)，空间复杂度为O(1)，只使用几个指针，类似归并排序思想</p></blockquote><ul><li>先从第一个链表开始迭代，如果链表1当前指针的值&lt;链表2当前指针的值则链表1指针往后移动一位，反之如果链表1当前指针的值&gt;=链表2的值，则执行插入到链表1当前指针前面一个位置，基本代码如下：<code>pre</code>指向链表1当前节点的前一个节点，用于插入</li></ul><pre><code class="java">ListNode next = list2.next;//保存链表2的下一个节点指针pre.next = list2;//pre指向新插入节点list2.next = list1;//新插入节点指向链表1当前节点pre = list2;//更新pre到pre的下一个节点也就是新插入的节点list2 = next;//更新链表2当前节点为下一个节点(保存的引用在这里使用)</code></pre><ul><li>当链表1为空或者链表2为空时，结束迭代，剩下的非空链表的所有元素都大于新链表所有元素，直接<code>接入</code>到新链表后面就可以了，代码如下</li></ul><pre><code class="java">if(list1==null&amp;&amp;list2!=null){//如果有一个不为空则执行连接链表操作    list1 = list2;    pre.next = list1;}    </code></pre><img src="http://dzou.wangminwei.top/static/images/algorithm/11.png"><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="java">public class Solution {    public ListNode Merge(ListNode list1,ListNode list2) {        if(list1==null||list2==null){            return list2==null?list1:list2;        }        ListNode head1,head2,pre;        head1 = list1;head2 = list2;pre = null;        while(list1!=null&amp;&amp;list2!=null){            if(list1.val&gt;=list2.val){                //把list2放过来                ListNode next = list2.next;                if(pre!=null){                    pre.next = list2;                }                list2.next = list1;                pre = list2;                list2 = next;            }else{                list1 = list1.next;                if(pre == null){                    pre = head1;                }else{                    pre = pre.next;                }            }        }        if(list1==null&amp;&amp;list2!=null){            list1 = list2;            pre.next = list1;        }        return head2.val&lt;=head1.val?head2:head1;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      剑指offer—合并两个有序链表.输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。
    
    </summary>
    
      <category term="算法" scheme="https://www.dzou.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="https://www.dzou.top/tags/Java/"/>
    
      <category term="基础" scheme="https://www.dzou.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="算法" scheme="https://www.dzou.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="牛客" scheme="https://www.dzou.top/tags/%E7%89%9B%E5%AE%A2/"/>
    
      <category term="面试" scheme="https://www.dzou.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="剑指offer" scheme="https://www.dzou.top/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="笔试" scheme="https://www.dzou.top/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
</feed>
